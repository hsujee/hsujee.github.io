[{"title":"MtkLog分析","date":"2017-06-29T16:00:00.000Z","path":"2017/06/30/Android/Mtk/2017-06-30-MtkLog解析/","text":"mtklog简介mtklog是由log生成工具MTKLogger生成的一系列问题追踪文件，其主要作用就是对系统或者应用产生的异常进行快速定位，从而解决问题。 mtklog 的分类：MDLog、Mobile Log、Network Log，可能出现的aee_exp log MD log：medom 相关底层的log Mobile Log：主要是Android log 和kernel log Network log：网络相关log aee_exp log ：crash ANR 重启相关的log输出 mtklog 的开启和关闭（1）在拨号盘界面输入*#9646633# ： （2）进入EngineerMode的第一个Telephony界面： （3）向左滑动进入Log and Debugging界面： （4）点击MTKLogger 菜单： 点击log设置图标可进入log设置界面，如果我只要打印MobileLog可将ModemLog，NetworkLog，GPSlog关闭，点击蓝底色1 即可： （5）点击开始（红色播放按键）按键： （6）log 开启： （7）当我们已经发现异常时，当关闭log，并截图记录时间点，下拉进入下拉栏界面，点击MTKLogger is running： （8）点击停止按键： 如图关闭成功： mtklog的导出和分析（1）MTKLogger停止后，手机USB，下拉下拉栏，点击USB for charging，切换至MTP模式： Transfer files(MTP); （2）双击：便携设备： （3）在内部存储中找到mtklog文件夹复制粘贴到本地： （4）打开mtklog文件夹： （4）关于分析log，我们主要分析mobilelog 文件夹中的对应android log 和 kernel log： 对应log文件名称为： crash_log ：崩溃日志，主要输出 程序崩溃造成的crash log events_log：事件日志，主要输出记录各个activity周期及事件 kernel_log：底层驱动，按键，低内存相关log sys_log：系统日志，Exception定位点 radio_log：输出通话，网络状态变化 main_log：详尽输出每一步的log 分析kernel log安装可查看对应kernal_log的时间点： 安装成功之后，如下操作打开kernal_log.localtime文件可查看带时间点的kernal log： 常见异常分析1.编译报错： 在build.log 中搜索unfinished 关键字，查找上文能够很快定位报错原因，或者搜索 error: 关键字能够直接定位相关报错文件（注意是搜索error和冒号） 2.程序崩溃（系统提示*已停止运行）： （1）启动崩溃：一般情况为第三方预置缺少库文件，或者兼容性问题 （2）应用间交互崩溃：startActivity找不多对应包名或者类名，或者无对应启动Activity的权限 （3）APP内部逻辑空指针异常导致程序崩溃（NullPointerException） 以上三种情况都可在mtklog\\mobilelog\\APLog_2016_0505_115433\\events_log 文件中搜索 crash 关键字快速定位问题点，crash_log中可查看对应问题产生原因： 12Line 4201: 03-29 11:25:32.894092 939 949 I am_crash:[9337,0,com.bbm,954744388,Java.lang.UnsatisfiedLinkError,dalvik.system.PathClassLoader[DexPathList[[zip file\"/system/framework/com.google.android.maps.jar\", zip file\"/data/app/com.bbm-1/base.apk\"],nativeLibraryDirectories=[/data/app-lib/com.bbm-1,/data/app/com.bbm-1/base.apk!/lib/armeabi-v7a, /vendor/lib, /system/lib]]]couldn't find \"libgnustl_shared.so\",Runtime.java,367]Line 4202: 03-29 11:25:32.910190 939 949 Iam_finish_activity: [0,198242511,14,com.bbm/.ui.activities.StartupActivity,force-crash] 3.程序闪退： （1）外部原因：物理内存不足，被kill，events_log中搜索 low_memory 关键字，以确定低内存杀死程序，kernal_log 中有存在对应时间点被 low memory kill如下： 123456789101112131415161718192021222305-10 11:36:22.588540 923 1439 Iam_low_memory: 1905-10 11:36:22.594222 923 938 I am_destroy_activity:[0,205784777,125,com.mediatek.filemanager/.MainFilemanagerActivity,finish-idle]05-10 11:36:22.599262 923 923 I notification_cancel_all:[1000,923,com.mediatek.filemanager,0,0,0,5,NULL]05-10 11:36:22.601661 923 923 I notification_cancel_all:[1000,923,com.android.providers.downloads,0,0,0,5,NULL]05-10 11:36:22.650000 2036 2036 I auditd : type=1400 audit(0.0:347): avc:denied&#123; read &#125; for comm=\"GpuAppSpectator\" name=\"cmdline\"dev=\"proc\" ino=10905 scontext=u:r:gas_srv:s0tcontext=u:r:system_app:s0 tclass=file permissive=005-10 11:36:22.869048 923 1910 Iam_proc_bound: [0,3769,com.cyin.himgr]05-10 11:36:23.403472 1532 1532 Iam_on_resume_called:[0,com.android.hios.launcher3.Launcher]05-10 11:36:23.650000 2036 2036 I auditd :type=1400 audit(0.0:348): avc: denied &#123; read &#125;forcomm=\"GpuAppSpectator\" name=\"cmdline\" dev=\"proc\"ino=10905 scontext=u:r:gas_srv:s0 tcontext=u:r:system_app:s0 tclass=filepermissive=005-10 11:36:23.965602 923 938 I am_destroy_activity:[0,102727749,125,com.android.packageinstaller/.InstallAppProgress,finish-imm]05-10 11:36:23.972491 241 241 I sf_frame_dur:[com.android.packageinstaller/com.android.packageinstaller.InstallAppProgress,2375,9,1,0,1,0,0]05-10 11:36:24.126262 923 1520 I netstats_mobile_sample: [0,0,0,0,0,0,0,0,0,0,0,0,-1]05-10 11:36:24.126560 923 1520 I netstats_wifi_sample:[64660,844,36398,408,33328,147,33388,197,32228,126,33388,197,-1]05-10 11:36:24.244910 923 934 I am_proc_died: [0,3665,com.android.packageinstaller]05-10 11:36:24.245968 923 934 I wm_task_removed: [125,removeAppToken: last token]05-10 11:36:24.246168 923 934 I wm_task_removed: [125,removeTask]05-10 11:36:24.248168 923 934 I am_low_memory: 1905-10 11:36:24.255912 923 923 I notification_cancel_all:[1000,923,com.android.packageinstaller,0,0,0,5,NULL]05-10 11:36:24.318915 923 933 Inetstats_mobile_sample: [0,0,0,0,0,0,0,0,0,0,0,0,-1] （2）内部原因：main_log/sys_log 搜索Exception 或者 died关键字定位对应包名，进而定位问题 4.ANR问题： 出现ANR应当提供traces.txt文件，直接在文件中搜索 cmd 关键字，定位问题点。锁定三个方向：memoryleak（是否为低内存），CPU block（CPU使用率过高）、iowait（IO流使用过于频繁） （1）memoryleak：首先根据Android log搜索低内存相关 low_memory 关键字，以确定是否存在低内存现象 （2）CPU block：搜索对应包出现ANR前后 TOTAL 关键字前的百分比，若百分比接近100% 说明CPU饥饿导致了ANR： （3）iowait：搜索iowait 关键字查看出现ANR前的百分比，若百分比过高，说明I/O流使用过于频繁导致ANR，此项需修改相关数据库的加载流程，如下： 1234567891011121314151617181920212223242526274-0113:12:15.872 E/ActivityManager( 220): 5.5%21404/com.android.email: 1.3% user + 4.1% kernel / faults: 10 minor04-0113:12:15.872 E/ActivityManager( 220): 4.3%220/system_server: 2.7% user + 1.5% kernel / faults: 11 minor 2 major04-0113:12:15.872 E/ActivityManager( 220): 0.9%52/spi_qsd.0: 0% user + 0.9% kernel04-0113:12:15.872 E/ActivityManager( 220): 0.5%65/irq/170-cyttsp-: 0% user + 0.5% kernel04-0113:12:15.872 E/ActivityManager( 220): 0.5%296/com.android.systemui:0.5% user + 0% kernel04-0113:12:15.872 E/ActivityManager( 220): 100%TOTAL:4.8% user + 7.6% kernel + 87% iowait04-0113:12:15.872 E/ActivityManager( 220):CPUusagefrom 3697ms to 4223ms later:-- ANR后CPU的使用量04-0113:12:15.872 E/ActivityManager( 220): 25%21404/com.android.email: 25% user + 0% kernel / faults: 191 minor04-0113:12:15.872 E/ActivityManager( 220): 16% 21603/__eas(par.hakan: 16% user + 0% kernel04-0113:12:15.872 E/ActivityManager( 220): 7.2% 21406/GC: 7.2% user + 0% kernel04-0113:12:15.872 E/ActivityManager( 220): 1.8% 21409/Compiler: 1.8% user + 0% kernel04-0113:12:15.872 E/ActivityManager( 220): 5.5%220/system_server: 0% user + 5.5% kernel / faults: 1 minor04-0113:12:15.872 E/ActivityManager( 220): 5.5% 263/InputDispatcher: 0% user + 5.5% kernel04-0113:12:15.872 E/ActivityManager( 220): 32%TOTAL:28% user + 3.7% kernel 下面是一些相关文章链接： MTK平台系统稳定性分析 如何用adb控制MTKLogger 如何分析ANR Log的总结 android anr traces日志分析方法","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"Mtk","slug":"Mtk","permalink":"https://blog.hsujee.io/tags/Mtk/"},{"name":"Gat","slug":"Gat","permalink":"https://blog.hsujee.io/tags/Gat/"}]},{"title":"Android_Framework之Init","date":"2017-06-25T16:00:00.000Z","path":"2017/06/26/Android/Framework/2017-06-26-Android_Framework之Init/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"https://blog.hsujee.io/tags/FrameWork/"}]},{"title":"Android_FrameWork之Native_Binder","date":"2017-06-19T16:00:00.000Z","path":"2017/06/20/Android/Framework/2017-06-20-Android_FrameWork之Native_Binder/","text":"Binder是Android系统提供的一种IPC（进程间通信）机制，除Binder还有Pipe和socket等。 这片文章主要分析Android系统中的Binder机制，Binder机制有4个组件构成，它们分别是：Client，Server，ServiceManager和驱动Binder。 在Android基于Binder的C/S架构中，Binder就好比大世界中的网络，在这个体系中，除C/S(client/server)端外，还有一个全局的ServiceManager来管理系统中的各种Server。 Client、Server和ServiceManager三者之间的交互关系: MediaServer解析一个Server进程可注册多个Service Server注册对应Service到ServicManager中，Client要使用某个Service，必须到ServiceManager中获得Service信息，Client根据获取的Service信息建立与Service所在的Server进程的通讯，然后开始和Service直接交互，其中相互访问的两个对象之间都为C/S架构，Android中三者交互基于Binder通信 用MediaServer为例辅助，进行Binder的解析 具体实现细节，可根据下面类图进行跟代码查看 Main_MediaServer.cpp为MediaServer的入口，其main()方法中主要做了5个操作，类图中已标示代码查看路线 获得一个ProcessState实例 MS作为ServiceManager的客户端，需要向ServiceManger注册服务，调用defaultServiceManager，得到一个IServiceManager。 多媒体系统的MediaPlayer服务，我们将以它作为主切入点 创建一个线程池。 将自己加入到刚才的线程池中 下图为binder通信层和业务层的关系图 ServiceManager 之 Binder的守护进程ServiceManager组件是用来管理Server并且向Client提供查询Server远程接口的功能。 Android系统中的Service信息都是先添加到ServiceManager中，由ServiceManager来集中管理，这样就可以随时查询当前系统中启动的Service信息，想要和Service进行交互，必须先向ServiceManager来获取该Service的信息，然后使用获取的信息去和Service交互。 下面以Android7.0版本源代码进行分析 源码位置：\\frameworks\\native\\cmds\\servicemanager\\ 主要代码：binder.c,binder.h,service_manager.c","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"https://blog.hsujee.io/tags/FrameWork/"}]},{"title":"Android FrameWork学习总纲","date":"2017-06-18T16:00:00.000Z","path":"2017/06/19/Android/Framework/nec/2017-06-19-模板/","text":"必须谈谈学习思路 从今年开始学习Android FrameWork开发，作为一个系统，Android有它相对应的成熟体系，工欲善其事必先利其器，要学习一个庞大的系统，不能一头扎进去就看代码，其实看代码的话，所有程序员都会看代码，问题是怎么看代码，看什么代码 Android源码树异常庞大，如果想一行不漏地看，不可能；就算你这么干了，效果也不见得好————《只见树木，不见森林》。 在万能网络的帮助下总结了一下学习方法： 1、先理解模块对应的要解决的“问题”是什么，再去给问题找解决方案的思路去理解源码。 几乎所有代码or模块or系统的开发初衷，都是为了解决某一问题。如果光看源码，哦这个是干嘛的，那里调用了哪个API，这样看毫无意义。 先有的问题，之后才有的代码，看一个重要模块之前，首先弄明白此模块有哪些功能？怎么使用？如果这个功能给你去做，你会用什么方式去实现，以此为向导，可以了解相关问题的解决方案，学习一些除了代码之外的知识，然后再去了解学习Android系统中的实现，细节都在代码中，掌握了宏观的框架，再去看代码，这样看到*代码，“哦，我明白这个方法这样写是为什么，他干了什么？”有种叫做直觉的东西会降临，这样的状态会让学习效率直线上升，并无—-枯燥感 2、理解源码的功夫不止在Android本身，也要提高Android之外的姿势水平。 3、学习程序最需要会的一点就是–抽象。不管是写还是看。写的抽象不必说。看的抽象是啥玩意儿？就是开始看的时候要忽略细节，跟着流程走。工作原理一般都可以文字描述，如何实现的，跟着函数调用一步一步套，流程通了，细节就不在话下了。如果一开始就纠结各种变量、各种函数名、各种模式，估计会迷路吧。 4、终目的只有一个「学会看源码」，而不是「学会源码」 5、高度抽象，构建框架，重要函数，深究细节，善用工具，及时总结 最后，不要等到万事俱备的时候才去做某一件事，一旦决定去做，天亮就出发。 推荐一个Framework里最简单的Service——LightService，一共就以下几个文件。123/services/core/java/com/android/server/lights/LightsManager.java./services/core/java/com/android/server/lights/Light.java./services/core/java/com/android/server/lights/LightsService.java","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"https://blog.hsujee.io/tags/FrameWork/"}]},{"title":"Android FrameWork学习总纲","date":"2017-06-18T16:00:00.000Z","path":"2017/06/19/Android/Framework/2017-06-19-Android FrameWork学习总纲/","text":"必须谈谈学习思路 从今年开始学习Android FrameWork开发，作为一个系统，Android有它相对应的成熟体系，工欲善其事必先利其器，要学习一个庞大的系统，不能一头扎进去就看代码，其实看代码的话，所有程序员都会看代码，问题是怎么看代码，看什么代码 Android源码树异常庞大，如果想一行不漏地看，不可能；就算你这么干了，效果也不见得好————《只见树木，不见森林》。 在万能网络的帮助下总结了一下学习方法： 1、先理解模块对应的要解决的“问题”是什么，再去给问题找解决方案的思路去理解源码。 几乎所有代码or模块or系统的开发初衷，都是为了解决某一问题。如果光看源码，哦这个是干嘛的，那里调用了哪个API，这样看毫无意义。 先有的问题，之后才有的代码，看一个重要模块之前，首先弄明白此模块有哪些功能？怎么使用？如果这个功能给你去做，你会用什么方式去实现，以此为向导，可以了解相关问题的解决方案，学习一些除了代码之外的知识，然后再去了解学习Android系统中的实现，细节都在代码中，掌握了宏观的框架，再去看代码，这样看到*代码，“哦，我明白这个方法这样写是为什么，他干了什么？”有种叫做直觉的东西会降临，这样的状态会让学习效率直线上升，并无—-枯燥感 2、理解源码的功夫不止在Android本身，也要提高Android之外的姿势水平。 3、学习程序最需要会的一点就是–抽象。不管是写还是看。写的抽象不必说。看的抽象是啥玩意儿？就是开始看的时候要忽略细节，跟着流程走。工作原理一般都可以文字描述，如何实现的，跟着函数调用一步一步套，流程通了，细节就不在话下了。如果一开始就纠结各种变量、各种函数名、各种模式，估计会迷路吧。 4、终目的只有一个「学会看源码」，而不是「学会源码」 5、高度抽象，构建框架，重要函数，深究细节，善用工具，及时总结 最后，不要等到万事俱备的时候才去做某一件事，一旦决定去做，天亮就出发。 推荐一个Framework里最简单的Service——LightService，一共就以下几个文件。123/services/core/java/com/android/server/lights/LightsManager.java./services/core/java/com/android/server/lights/Light.java./services/core/java/com/android/server/lights/LightsService.java","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"https://blog.hsujee.io/tags/FrameWork/"}]},{"title":"ContactsProvider 数据库操作","date":"2017-06-09T16:00:00.000Z","path":"2017/06/10/Android/Provider/2017-06-10-ContactsProvider数据库操作/","text":"通过之前的文章对联系人以及联系人数据做了大概的了解和梳理，这里继续深入到联系人的数据存储做出相应总结 数据结构一条Contact数据是由此账户下的所有raw contacts组合起来生成的，方便手机某一用户的所有信息，用户不允许增加Contact（只能增加raw contacts）。通常联系人应用中看到的联系人用的就是 contacts 表中的一条记录。一个 contact 可以拥有多个 raw contacts，这时候点击这个联系人的编辑界面，就会发现可以同时编辑多个 raw contacts.这边所谓的组合，也就是 raw contacts 的 contact_id，只是让这几个 raw contacts 在界面上组合起来显示，本身的数据还是完全独立的。Contacts Provider 通过 ContactsContract.RawContacts 表中的 _ID 列将 contacts 表中的数据和 raw contacts 表中的数据链接起来。 ContactsContract.RawContacts 表中 CONTACT_ID 的值就是 contacts 表中的 _ID，说明这条 raw contact 记录属于_ID所在的这个联系人。下面是Contact数据组成关系图 访问权限、用户私密信息访问读取权限：android.permission.READ_CONTACTS修改权限：android.permission.WRITE_CONTACTSContactsContract.Profile定义私密信息ProfileProvider继承自AbstractContactsProvider，负责对用户私密信息数据的操作想要访问用户私密信息除了以上两个权限还需要添加READ_PROFILE和WRITE_PROFILE两个权限 同步适配器主要用来同步Web服务器上的用户数据Contacts Provider 为了处理设备和服务器之间的同步做了特别的设计。允许用户从服务器下载数据，并且也可以上传数据。同步使得设备端总能有最新的数据，不管数据源发生什么变化。同步的另一个好处是即使没有联网，设备还是能够使用服务器上存在的数据(当然是同步号的数据)。 尽管你可以有很多办法来实现同步，Android 提供了一个插件式的同步框架，它可以自动完成下面的工作： 检查网络是否可用按照用户偏好，周期性地执行同步重新启动停止的同步操作想要使用这个框架，应该实现一个同步适配器插件。每一个同步适配器都对应一个服务器和一个 provider，但是每一个服务器下可以有多个账户名。这个框架下也允许有一个服务器和 provider 对应多个同步适配器。 数据库改变记录Contacts Provider 对数据库中数据的状态改变都有记录。 数据库操作 Entity查询 联系人的结构是由层次组织的，因此想要查找一个联系人的信息，就要先查找其下面所有RawContacts，还要查出所有RawContacts下关联的所有ContactsContract.CommonDataKinds.Email等，因此为了方便查询，Contacts Provider提供了Entity结构，它可将各个表连接起来。 Entity就像是一张从父表和子表中选出一些列重新组合的一张表。当查询 entity 时，只能根据entity中的列来定制查询结果和查询条件。查询结果的 Cursor 里包含了子表中被查询到的记录。Entity的机构可参考上图，在源码中进行查看。Entity的使用非常方便，通过查询它我们可以一次就得到一个联系人的所有数据。不许要先去查询父表，得到 ID 后，再用这个 ID 去子表中查询。Entity通常不会包含父表和子表中所有的列，如果使用的列并不在 entity 中时，程序就会抛出Exception通过下面查询示例可以帮助理解加载流程： 1234567891011121314151617181920212223242526272829303132//将Entity路径追加到URI。 在联系人提供者中//预期的URI是content：//com.google.contacts/#/entity（＃是ID值）。mContactUri = Uri.withAppendedPath( mContactUri, ContactsContract.Contacts.Entity.CONTENT_DIRECTORY);.....................//初始化由LOADER_CONTACT_ID标识的加载器，并添加加载回调mContactLoader = (ContactLoader) getLoaderManager().initLoader( LOADER_CONTACT_ID, // The identifier of the loader to initialize null, // Arguments for the loader (in this case, none) mLoaderContactCallbacks);.....................//给联系人加载器设置UrimContactLoader.setLookupUri(mContactUri);.....................//联系人加载回调private final LoaderCallbacks&lt;Contact&gt; mLoaderContactCallbacks = new LoaderCallbacks&lt;Contact&gt;() &#123; @Override public void onLoadFinished(Loader&lt;Contact&gt; loader, Contact data) &#123; //此方法中的data就是查询之后返回的结果..................... @Override public Loader&lt;Contact&gt; onCreateLoader(int id, Bundle args) &#123; if (mLookupUri == null) &#123; Log.wtf(TAG, \"Lookup uri wasn't initialized. Loader was started too early\"); &#125; //加载所有联系人数据。 我们需要loadGroupMetaData = true来确定是否 //联系是看不见的。 如果是，我们需要显示一个“添加到联系人”菜单项。 return new ContactLoader(getApplicationContext(), mLookupUri, true /*loadGroupMetaData*/, false /*loadInvitableAccountTypes*/, true /*postViewNotification*/, true /*computeFormattedPhoneNumber*/); 当 load 完成数据加载后，LoaderManager 会调用 onLoadFinished() 方法。到此就可以根据监听器中onLoadFinished()方法返回的data使用了监听器中的onCreateLoader()返回具体的加载器，在这里我们创建了联系人加载器ContactLoader() 批量修改 Contacts Provider 中执行新增、修改、删除操作时，应该尽可能地使用“批处理”，通过创建一个 ContentProviderOperation 对象的 ArrayList 集合然后调用 applyBatch() 方法。因为 Contacts Provider 会把一个 applyBatch() 中的所有操作当成一个事务来处理，你的修改将不会让数据库处于一个不一致的状态中。批处理还方便同时插入 raw contact 和它对应的 data 数据。 Yield points(挂起点)批量处理中有很多的操作，这又可能会阻塞其他进程的运行，这是很差的用户体验。为了改善这种情况，应该尽可能地将所要做的操作分散到多个集合中，同时也为了避免阻塞系统运行，应该为 ContentProviderOperation 设置一个或多个yield points. 通过让 ContentProviderOperation的 isYieldAllowed() 的返回值置为 true. 当Contacts Provider 遇到一个挂起点时，它会停止工作来让其他进程得以运行，并且会关闭当前事务。当Contacts Provider 再次工作时，它将会开启一个新的事务来进行 ArrayList 集合中的下一个操作。 挂起点会导致调用一次 applyBatch() 时开启多个事务。因此，我们应该为某一行记录所有操作的最后一个操作设置一个挂起点。比如说，在我们插入 raw contact 和它相关的 data 数据时，我们应该为最后一步操作设置一个挂起点。 挂起点是原子操作，也就是说两个挂起点之间的所有操作要么成功要么失败。如果没有设置挂起点，原子操作将会是每一步具体的操作。使用挂起点，可以阻止系统性能的下降，还可以确保一些列的操作集合具有原子性。 Modification back references修改反回参考当我们使用 ContentProviderOperation 来插入新的 raw contacts 和与它相关的 data 数据时，必须要将 data 数据的 raw contact’s _ID 这一列关联到 raw contact 的RAW_CONTACT_ID 列上。然而，这个值在创建 ContentProviderOperation 对象时还没有，因为插入 raw contact 的操作还没有完成。为了解决这个问题，ContentProviderOperation.Builder 类提供了withValueBackReference()这个方法，它允许基于上一条操作的结果来插入或者修改数据。 withValueBackReference() 方法有两个参数: key键值对的键。这个值应该是表中的列名。previousResultapplyBatch() 的结果存储在一个索引从0开始的 ContentProviderResult 对象数组中。执行批处理操作时，指向结果存储在一个中间数组中。previousResult 的值就是数组中的一个索引，它以key值来进行存取。这允许我们在插入一个 raw contact 记录时得到插入的 _ID 值，接下来在插入 data 记录时使用。结果数组在调用 applyBatch() 时就被创建完成，它的大小等于 ContentProviderOperation 的 ArrayList 数组的大小。数组初始值都是null，当我们想要获取一个还没有被执行操作的向后引用时，withValueBackReference() 方法将会抛出 异常。下面是Contact新建联系人的示例图： 下面为批量修改示例，代码出自com.android.contacts.ContactSaveService类，其中主要方法为applyBatch()请求批量插入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void createRawContact(Intent intent) &#123; //获取用户输入的所有信息 String accountName = intent.getStringExtra(EXTRA_ACCOUNT_NAME); String accountType = intent.getStringExtra(EXTRA_ACCOUNT_TYPE); String dataSet = intent.getStringExtra(EXTRA_DATA_SET); List&lt;ContentValues&gt; valueList = intent.getParcelableArrayListExtra(EXTRA_CONTENT_VALUES); Intent callbackIntent = intent.getParcelableExtra(EXTRA_CALLBACK_INTENT); //创建一个插入到ContactsContract.RawContacts表中 raw contact 记录的操作 ArrayList&lt;ContentProviderOperation&gt; operations = new ArrayList&lt;ContentProviderOperation&gt;(); operations.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI) .withValue(RawContacts.ACCOUNT_NAME, accountName) .withValue(RawContacts.ACCOUNT_TYPE, accountType) .withValue(RawContacts.DATA_SET, dataSet) .build()); int size = valueList.size(); for (int i = 0; i &lt; size; i++) &#123; ContentValues values = valueList.get(i); values.keySet().retainAll(ALLOWED_DATA_COLUMNS); operations.add(ContentProviderOperation.newInsert(Data.CONTENT_URI) .withValueBackReference(Data.RAW_CONTACT_ID, 0) .withValues(values) .build()); &#125; ContentResolver resolver = getContentResolver(); ContentProviderResult[] results; //调用 applyBatch() 来新增一个 raw contact 和与它相关的 data 记录。 try &#123; results = resolver.applyBatch(ContactsContract.AUTHORITY, operations); &#125; catch (Exception e) &#123; throw new RuntimeException(\"Failed to store new contact\", e); &#125; Uri rawContactUri = results[0].uri; callbackIntent.setData(RawContacts.getContactLookupUri(resolver, rawContactUri)); deliverCallback(callbackIntent); &#125; public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations) throws OperationApplicationException &#123; incrementStats(mBatchStats); if (VERBOSE_LOGGING) &#123; Log.v(TAG, \"applyBatch: \" + operations.size() + \" ops\"); &#125; int ypCount = 0; int opCount = 0; //开启数据操作事务，循环operations处理每一个ops，最大挂起点为500个，如果超过将抛出 //OperationApplicationException异常 ContactsTransaction transaction = startTransaction(true); try &#123; final int numOperations = operations.size(); final ContentProviderResult[] results = new ContentProviderResult[numOperations]; for (int i = 0; i &lt; numOperations; i++) &#123; if (++opCount &gt;= MAX_OPERATIONS_PER_YIELD_POINT) &#123; throw new OperationApplicationException( \"Too many content provider operations between yield points. \" + \"The maximum number of operations per yield point is \" + MAX_OPERATIONS_PER_YIELD_POINT, ypCount); &#125; final ContentProviderOperation operation = operations.get(i); if (i &gt; 0 &amp;&amp; operation.isYieldAllowed()) &#123; if (VERBOSE_LOGGING) &#123; Log.v(TAG, \"applyBatch: \" + opCount + \" ops finished; about to yield...\"); &#125; opCount = 0; try &#123; if (yield(transaction)) &#123; ypCount++; &#125; &#125; catch (RuntimeException re) &#123; transaction.markYieldFailed(); throw re; &#125; &#125; //调用ContentProviderOperation.apply(),开始具体的对数据库的操作，并返回结果 results[i] = operation.apply(this, results, i); &#125; transaction.markSuccessful(true); return results; &#125; finally &#123; endTransaction(true); &#125; &#125; 联系人批量处理过程中使用了事务，和乐观并发控制概念批处理允许我们实现乐观并发控制，它可以让我们在执行修改事务时不去锁定数据库。要是用这个方法，我们先执行事务然后检查是否有其他修改发生。如果检测到不一致的变化，应该回滚事务在重新执行。 乐观并发控制在手机上非常有用，因为只有一个用户，极少发生对一个数据库的同时访问。因为锁没有被使用，所以没有时间浪费在加锁和等待锁的操作上。 为了使用乐观并发控制，我们在更新 ContactsContract.RawContacts 表中的数据时，要遵循以下步骤: ①在获取其他数据时，一并将 VERSION 获取出来②通过 newAssertQuery(Uri) 方法来创建一个 ContentProviderOperation.Builder 对象。将 raw contact’s _ID 附在 RawContacts.CONTENT_URI 后面来形成 URI参数。③调用 ContentProviderOperation.Builder 对象的 withValue() 方法，将得到的 VERSION 的值添加进来。④调用 ContentProviderOperation.Builder 的 withExpectedCount() 方法来保证这个断言只检测一条数据记录。⑤调用 build() 创建 ContentProviderOperation 对象，并将这个对象加入到需要通过 applyBatch() 执行的 ArrayList 数组中去。⑥执行批处理。如果在读取和修改某条记录的过程中，这条记录被其他程序修改了，那么这个断言 ContentProviderOperation 将会失败，事务将会回滚。此时你可以尝试重新执行或者采取其他措施。 使用intents进行检索和修改 要去修改单个 raw contact 记录，最好是通过发送 intent 来让联系人应用去修改，而不是直接用代码进行修改。发送特定的 intent 可以通过设备的联系人应用间接接触 Contacts Provider.这些 intent 会启动联系人应用界面，用户可以在这些界面中完成联系人相关的工作。 数据的完整性（数据协议） 由于联系人数据是非常重要并且敏感的数据，所以用户期望这些数据是正确的，Contacts Provider 为了保证数据的完整性定义了一些规则。当用户修改联系人数据时，你要确保所做的操作都能够满足这些规则。下面是几个比较重要的规则: 要给每一个 ContactsContract.RawContacts 记录都添加 ContactsContract.CommonDataKinds.StructuredName 数据。一个没有 ContactsContract.CommonDataKinds.StructuredName 数据的 ContactsContract.RawContacts 记录在与其他 raw contact 进行组合时可能会遇到问题。每一条 ContactsContract.Data 记录都必须要链接到一条 ContactsContract.RawContacts 记录上去。一个没有链接到 ContactsContract.RawContacts 记录上的 ContactsContract.Data 记录将永远不会显示在联系人应用中，并且可能会影响同步适配器的工作。仅修改属于你自己 raw contact 的数据Contacts Provider 通常管理着几个账户类型的数据。你需要确保你的应用值修改属于你自己的数据，只向自己的账户下新增数据。开发时总是使用 ContactsContract 类中定义的常量来表示authorities、content URIs、URI paths、MIME、以及 TYPE 值。使用这些常量可以帮助你避免一些错误的发生。编译器将会对那些废除的常量给出警告。 自定义数据行 通过定义自己的 MIME 类型，我们可以向 ContactsContract.Data 表中添加自己的数据类型。尽管你可以为你的数据类型定义一些特别的列名（比如phone、Email）,但是还是只能使用定义在 ContactsContract.DataColumns 中的列。在联系人应用中，用户只能显示出你定义的数据类型，但是无法编辑、删除、增加它，所以需要在你自己的应用中实现这样一个界面来完成这些操作。 为了显示自定义的数据类型，需要提供一个 contacts.xml 文件，这个文件中得有一个 元素和它的子元素 .这将在 element 中详细描述。 其他 ContactsContract.StreamItems 表和 ContactsContract.StreamItemPhotos 表管理着来自与社交网络的数据。可以编写同步适配器来将网络上的数据添加到这两张表中，也可以将表中的数据显示在自己的应用中。这个功能可以将社交网络服务和应用集成到Android的社交网络体验中来。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"Contact","slug":"Contact","permalink":"https://blog.hsujee.io/tags/Contact/"},{"name":"Provider","slug":"Provider","permalink":"https://blog.hsujee.io/tags/Provider/"}]},{"title":"并发控制的乐观和悲观策略","date":"2017-06-05T16:00:00.000Z","path":"2017/06/06/DesignPatterns/2017-06-06-并发控制的乐观和悲观策略/","text":"悲观并发控制一个锁定系统，可以阻止用户以影响其他用户的方式修改数据。如果用户执行的操作导致应用了某个锁，只有这个锁的所有者释放该锁，其他用户才能执行与该锁冲突的操作。这种方法之所以称为悲观并发控制，是因为它主要用于数据争用激烈的环境中，以及发生并发冲突时用锁保护数据的成本低于回滚事务的成本的环境中。 乐观并发控制在乐观并发控制中，用户读取数据时不锁定数据。当一个用户更新数据时，系统将进行检查，查看该用户读取数据后其他用户是否又更改了该数据。如果其他用户更新了数据，将产生一个错误。一般情况下，收到错误信息的用户将回滚事务并重新开始。这种方法之所以称为乐观并发控制，是由于它主要在以下环境中使用：数据争用不大且偶尔回滚事务的成本低于读取数据时锁定数据的成本。具体的区别与实例说明如下： 悲观并发控制： 假设A和B需要在SCC（Source Code Control）上修改同一个文件，那么在A锁定这个文件并修改的过程中，B无法修改这个文件，他只能等待A解锁文件后，他才能修改。由此可见，悲观并发控制是强调控制在前，确保整个过程不会出现文件版本的冲突。这样做会使得系统效率损耗在加锁机制上，尤其是加锁机制需要用到低速的外部存储（比如FileLocking）时，然而这样做就降低了事务的并发性，尤其是事务之间本来就不存在冲突的情况下。例如在A修改数据的时候，B只能等待。 由此可见，悲观并发控制通过使用显式的加锁机制或者时间戳，对每一个事务进行增量同步校验。如果加锁机制的成本较高的话，悲观并发控制就会出现一些弊端。首先就是效率问题，尤其是使用低效率的外部存储系统实现加锁机制时，这样的问题会更加突出。其次，在不会出现冲突的事务处理（例如只读型事务）中，使用加锁机制就显得没有必要了，这样做只能增加系统负载。再次，这种方式降低了系统的并发性。 乐观并发控制： 同样假设A和B需要在SCC上修改同一个文件，他们都将这个文件获取到自己的机器上，A修改完以后，就把文件上传到SCC上了，此时B也修改完了，当他也打算将文件上传时，系统会告知B，已经有人上传了，并出现一个错误。剩下的问题只能由B手动解决，例如B可以在SCC上将文件中更改的内容再次复制一遍。乐观并发控制使得系统效率损耗在事务的后期处理中，比如B必须手动的去修改他已经修改过的东西，然而这种控制方式在极少出现冲突的多事务处理中显得十分高效。 乐观并发控制将事务分为三个阶段：读取阶段、校验阶段以及写入阶段。在读取阶段，事务将数据写入本地缓冲（如上所述，A和B将文件都获取到自己的机器上），此时不会有任何校验操作；在校验阶段，系统会对所有的事务进行同步校验（比如在A或者B打算，但还没有，往SCC上写入更改后的文件时）；在写入阶段，数据将被最终提交。在完成读取阶段以后，系统会对每个事务分派一个时间戳。 悲观并发控制中一个常见的问题就是死锁。例如A在修改文件T1，B在修改文件T2，他们分别锁定了这两个文件，假设T1和T2内容相关，B在修改T2的时候发现他还需要修改T1，可是T1却被A锁定；与此同时，A在修改T1的时候也发现了他还需要修改T2，可是T2又被B锁定了，这样就出现了死锁。当然，在实际操作中，这种情况可以由A和B协商解决，但是在错综复杂的多事务处理环境中，死锁将使得问题变得非常复杂。","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blog.hsujee.io/tags/设计模式/"}]},{"title":"AndroidStudio导入源码","date":"2017-05-22T16:00:00.000Z","path":"2017/05/23/Android/Tool/2017-05-23-AndroidStudio导入源码/","text":"一、修改AS的配置因为在导入源码时需要消耗大量内存，所以先修改IDEA_HOME/bin/studio.vmoptions中-Xms和-Xmx的值。README文档中使用的是748m。 较新版本的AS中自带SDK，然后第一次用的时候新的SDK会下载Build Tool 等，大约需要2.25G空间。不想下载的话可以找到android-studio/bin目录下的idea.properties文件，在最后添加一行disable.android.first.run=true，然后再启动AS就好了,然后进去手动配置SDK位置。（注：每次升级后这些配置都会恢复默认。但SDK不用重新配置） 二、生成导入AS所需配置文件(*.ipr)为了成功将源码导入AS，我们需要先生成AS可是别的项目工程配置文件在源码根目录依次执行 12source build/ensetup.shmake idegen &amp;&amp; development/tools/idegen/idegen.sh 之后会出现类似下面的结果: 这时会在源码的根目录下生成android.ipr，android.iws和android.iml三个文件 注:生成的文件包括： ①android.iws 包含工作区的个人设置，比如打开过的文件，版本控制工具的配置，本地修改历史，运行和debug的配置等。 ②android.ipr 一般保存了工程相关的设置，比如modules和modules libraries的路径，编译器配置，入口点等。 ③android.iml 用来描述modules。它包括modules路径、 依赖关系，顺序设置等。一个项目可以包含多个 *.iml 文件。 之后我们在AS中打开源码根目录下新生成的android.ipr 需要更详细的操作请查看这篇博客","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"AS","slug":"AS","permalink":"https://blog.hsujee.io/tags/AS/"}]},{"title":"Android联系人代码分析","date":"2017-05-11T16:00:00.000Z","path":"2017/05/12/Android/App/2017-05-12-Android联系人代码分析/","text":"项目结构 PeopleActivity为项目启动后的主界面，就从此Activity开始 特殊成员概览： 1234567891011121314151617181920212223242526272829303132333435363738private MultiSelectContactsListFragment mAllFragment; //收藏联系人列表private ContactTileListFragment mFavoritesFragment; //全部联系人列表onCreate()&#123; //申请权限 刷新sim卡 加载联系人列表筛选控制器 添加切换状态监听 初始化界面和fragment，createViewsAndFragments() 初始化全选按钮&#125;onClick()&#123; case R.id.floating_action_button:// 点击悬浮按钮 Intent intent = new Intent(Intent.ACTION_INSERT, Contacts.CONTENT_URI);//新增联系人 case R.id.selection_count_text://点击全选按钮&#125;onAction()&#123; CHANGE_SEARCH_QUERY = 0; //搜索改变后更新模式 START_SEARCH_MODE = 1; //开始搜索模式 START_SELECTION_MODE = 2; //开始选择模式 STOP_SEARCH_AND_SELECTION_MODE = 3; //停止搜索进入选择模式 BEGIN_STOPPING_SEARCH_AND_SELECTION_MODE = 4; //绑定停止搜索和进入选择模式&#125;onOptionsItemSelected()&#123; case android.R.id.home: //点击ActionBar，如果menu显示，则隐藏 case R.id.menu_settings: //设置 case R.id.menu_contacts_filter: //要显示的联系人，联系人筛选器 case R.id.menu_share: //分享 case R.id.menu_join: //关联 case R.id.menu_delete: //删除 case R.id.menu_import_export: //导入/导出 case R.id.menu_clear_frequents: //清理常用联系人 case R.id.menu_help: //帮助 case R.id.menu_accounts: //管理账号 case R.id.menu_search: //搜索 case R.id.menu_blocked_numbers: //已屏蔽的号码 case R.id.export_database: //输出数据 case R.id.menu_groups: //群组 case R.id.menu_conference_call: //电话会议&#125; 新建联系人/修改联系人 12345PeopleActivity-&gt;onClick()-&gt;case R.id.floating_action_button:------&gt; ContactEditorActivity------&gt; ContactEditorFragmentContactEditorBaseFragment编辑联系人界面有两种状态分别如下：Intent.ACTION_EDIT//编辑模式Intent.ACTION_INSERT//新建模式由以上方式进入联系人编辑界面，对联系人的个人信息进行输入操作后，点击optionMenu进行添加 新建联系人 123456789101112131415161718//保存ContactEditorBaseFragment.onOptionsItemSelected()-&gt;case R.id.menu_save://保存按钮点击事件入口ContactEditorBaseFragment. Listener//监听器，处理所有对联系人的操作ContactEditorBaseFragment.save()-&gt;doSaveAction() //保存联系人，调用子类该方法ContactEditorFragment-&gt;doSaveAction();//此方法调用服务对联系人进行保存处理，具体保存实现如下：......protected boolean doSaveAction(int saveMode, Long joinContactId) &#123; final Intent intent = ContactSaveService.createSaveContactIntent(mContext, mState, SAVE_MODE_EXTRA_KEY, saveMode, isEditingUserProfile(), ((Activity) mContext).getClass(), ContactEditorActivity.ACTION_SAVE_COMPLETED, mUpdatedPhotos, JOIN_CONTACT_ID_EXTRA_KEY, joinContactId); return startSaveService(mContext, intent, saveMode);&#125;......startSaveService()&#123; final boolean result = ContactSaveService.startService(context, intent, saveMode);&#125;...... 通过以上流程，对联系人成员protected RawContactDeltaList mState 进行了保存，具体的ContactSaveService中的保存操作后面有整理 修改联系人 保存部分新增联系人中已做解析，下面看看其他操作选项 12345678ContactEditorBaseFragment .onOptionsItemSelected()&#123; case R.id.menu_save: //保存 case R.id.menu_delete: //删除 case R.id.menu_split: //取消关联 case R.id.menu_join: //关联 case R.id.menu_set_ringtone: //设置铃声 case R.id.menu_send_to_voicemail: //发送邮件&#125; 1、删除联系人 123456mListener.onDeleteRequested(mLookupUri);ContactEditorBaseActivity. mFragmentListener-&gt; @Override public void onDeleteRequested(Uri contactUri) &#123; ContactDeletionInteraction.start(ContactEditorBaseActivity.this, contactUri, true);//删除联系人 &#125; 2、取消关联 1234doSplitContactAction() SplitContactConfirmationDialogFragment.show(this, hasPendingChanges());hasPendingChanges()-&gt;hasPendingRawContactChanges() RawContactModifier.hasChanges(mState, accountTypes, excludedMimeTypes);//取消联系人关联 3、关联： 1234567891011showJoinAggregateActivity() //弹出关联选择窗口 startActivityForResult(intent, REQUEST_CODE_JOIN);......onActivityResulte() case REQUEST_CODE_JOIN: //如果返回数据，并且确定关联继续往下走......joinAggregate()-&gt;ContactEditorFragment.joinAggregete(); //选择确定关联，对关联的联系人信息进行保存 final Intent intent = ContactSaveService.createJoinContactsIntent( mContext, mContactIdForJoin, contactId, ContactEditorActivity.class, ContactEditorActivity.ACTION_JOIN_COMPLETED); mContext.startService(intent); 4、设置铃声： 12345678doPickRingtone() //设置联系人铃声 startActivityForResult(intent, REQUEST_CODE_PICK_RINGTONE);//开启铃声选择界面onActivityResult() case REQUEST_CODE_PICK_RINGTONE: onRingtonePicked(pickedUri);onRingtonePicked() //根据参数URI传递的铃声地址，设置该联系人的铃声 Intent intent = ContactSaveService.createSetRingtone(mContext, mLookupUri, mCustomRingtone); mContext.startService(intent); 5、发送邮件： 12345mSendToVoicemailState = !mSendToVoicemailState;item.setChecked(mSendToVoicemailState);final Intent intent = ContactSaveService.createSetSendToVoicemail(mContext, mLookupUri, mSendToVoicemailState);mContext.startService(intent); 查找联系人 查找流程分析 123456789101112PeopleActivity-&gt;onOptionsItemSelected-&gt; case R.id.menu_search:------&gt; onSearchRequested(); mActionBarAdapter.setSearchMode(true); //设置标题栏为搜索模式ActionBarAdapter. SearchTextWatcher-&gt;onTextChanged() mListener.onAction(Action.CHANGE_SEARCH_QUERY);PeopleAction-&gt;onAction(); case ActionBarAdapter.Listener.Action.CHANGE_SEARCH_QUERY:PeopleAction-&gt;setQueryTextToFragment(queryString); 到此处由MultiSelectContactsListFragment的父类实现，如下所示：ContactEntryListFragment-&gt; setQueryString() mAdapter.setQueryString(queryString);ContactEntryListAdapter-&gt; setQueryString() mUpperCaseQueryString = SearchUtil.cleanStartAndEndOfSearchQuery(queryString.toUpperCase()) ; 具体的查询代码在SearchUtil中，查询流程就此告一段落，具体查询算法后面补充 注：在搜索栏输入debug debug! ，界面进入到debug模式，显示按钮，导出数据库文件 1PeopleActivity-&gt;updateDebugOptionsVisibility() 联系人详情页QuickContactActivity 123456789onOptionsItemSelected()&#123; case R.id.menu_star: //加入收藏 final Intent intent = ContactSaveService.createSetStarredIntent(); case R.id.menu_edit: //编辑按钮进入修改联系人界面 case R.id.menu_delete: //删除联系人 case R.id.menu_share: //分享联系人 case R.id.menu_create_contact_shortcut: //创建联系人快捷方式 case R.id.menu_help: //帮助&#125; 删除联系人 删除联系人按钮，将联系人URI出入并打开ContactDeletionInteraction.java,显示提示窗口，点击删除按钮将进行联系人删除操作，具体操作如下： 12ContactDeletionInteraction-&gt;doDeleteContact() ContactSaveService.createDeleteContactIntent(mContext, contactUri) 分享联系人 点击分享联系人按钮，进行如下操作： 12final Intent intent = new Intent(Intent.ACTION_SEND);ImplicitIntentsUtil.startActivityOutsideApp(this, chooseIntent); 通过Intent.ACTION_SEND启动系统提供的分享功能进行分享操作 导入/导出联系人 通过点击事件开启导入/到处界面： ContactImportExportActivity.java 12345678//选择导入/导出源//选择导入/导出目标//打开联系人选择列表界面ContactListMultiChoiceActivity.java， configureListFragment() case ContactsRequestAction.ACTION_PICK_MULTIPLE_CONTACTS //多重选择联系人 | ContactsIntentResolverEx.MODE_MASK_IMPORT_EXPORT_PICKER: // 导入/导出选择器 在这里初始化选择器：MultiDuplicationPickerFragment 在选择器界面，对需要操作的联系人进行选中，点击ExportVCardActivity确定按钮进行导入导出操作 1234567onOptionAction() //处理动作if (mDstStoreType == DST_STORE_TYPE_STORAGE) &#123;//如果存储目标类型是SDCard doExportVCardToSDCard();doExportVCardToSDCard()//中开启ExportVCardActivity界面ExportVCardActivity.java，在该类中使用VCardService进行导入/导出的具体操作&#125; else &#123; mRequestHandler.sendMessage(mRequestHandler.obtainMessage( SendRequestHandler.MSG_REQUEST, mRequests)); 发送msg到handler 1234567handleMessage() //方法中进行导入/导出请求 //调用CopyRequestConnection-&gt;sendCopyRequest方法进行操作请求 mCopyRequestConnection.sendCopyRequest((List&lt;MultiChoiceRequest&gt;) msg.obj)MultiChoiceService.class //批量选择服务 handleCopyRequest() tryExecute(new CopyProcessor(this, listener, requests, sCurrentJobId, sourceAccount, destinationAccount)) 通过CopyProcessor对文件进行最后的拷贝 要显示的联系人 12case R.id.menu_blocked_numbers: //屏蔽号码 createManageBlockedNumbersIntent//打开系统提供的屏蔽号码界面 关联/取消关联联系人 关联联系人 12345case R.id.menu_join: joinSelectedContacts();打开JoinContactsDialogFragment，选择确定关联联系人，执行以下代码final Intent intent = ContactSaveService.createJoinSeveralContactsIntent(getActivity(), contactIdsArray2); 群组 点击群组按钮，开启GroupBrowserActivity 1startActivity(new Intent(PeopleActivity.this, GroupBrowseActivity.class)); 界面中加载GroupBrowseListFragment 新建群组 123456789101112131415161718192021GroupBrowserActivity-&gt;onOptionItemSelected() case R.id.menu_add_group://开启群组编辑界面进行群组创建GroupEditorActivity-GroupEditorFragment//在此编辑界面对群组的信息进行输入，点击去定按钮saveMenuItem-&gt;onClicked() mFragment.onDoneClicked();GroupEditorFragment-&gt;onDoneClicked() if (isGroupMembershipEditable()) &#123; save(SaveMode.CLOSE); //调用保存群组方法，进行保存 &#125; else &#123;doRevertAction();//仅仅返回操作&#125;GroupEditorFragment-&gt;save() if (Intent.ACTION_INSERT.equals(mAction)) //如果是插入模式，进行群组新建操作 saveIntent = ContactSaveService.createNewGroupIntent(activity, new AccountWithDataSet(mAccountName, mAccountType, mDataSet), mGroupNameView.getText().toString(), membersToAddArray, activity.getClass(), GroupEditorActivity.ACTION_SAVE_COMPLETED); Intent.ACTION_EDIT.equals(mAction) //如果是编辑模式，进行更新操作 saveIntent = ContactSaveService.createGroupUpdateIntent(activity, mGroupId, getUpdatedName(), membersToAddArray, membersToRemoveArray, activity.getClass(), GroupEditorActivity.ACTION_SAVE_COMPLETED); 群组详情 123456789101112131415161718192021222324252627GroupBrowseListFragment-&gt;configOnItemClickListener() //Item项目点击事件 viewGroup(); mListener.onViewGroupAction(groupUri); GroupBrowseActivity-&gt;GroupBrowserActionListener onViewGroupAction(); //此方法中执行打开群组详情界面 Intent intent = new Intent(GroupBrowseActivity.this, GroupDetailActivity.class); startActivity(intent);GroupDetailActivity -&gt;onContactSelected() //点击群组中的联系人，打开联系人详情GroupDetailFragment-&gt; onOptionsItemSelected()&#123;case R.id.menu_edit_group: // 修改 GroupDetailActivity -&gt;onEditRequested() //点击修改按钮，进入联系人编辑界面GroupEditorActivitycase R.id.menu_delete_group: //删除 GroupDeletionDialogFragment-&gt;PositiveButtonClick //点击删除按钮后，打开删除窗口，点击确认按钮进行删除 getActivity().startService(SimGroupUtils.createGroupDeletionIntentForIcc()); serviceIntent.setAction(ContactSaveService.ACTION_DELETE_GROUP); //通过上面代码开启SimProcessorService，在sim进程中，调用ContactSaveService.ACTION_DELETE_GROUP ContactSaveService.deleteGroup //进行删除群组操作case R.id.menu_move_group: //移动群组case R.id.menu_message_group: //发送群组信息 SendGroupSmsTask-&gt; execute //异步发送群组短信执行任务 Intent intent = new Intent(Intent.ACTION_SENDTO); startActivity(intent);case R.id.menu_email_group: //发送群组邮件 SendGroupEmailTask-&gt;execute //异步发送群组邮件执行任务 Intent intent = new Intent(Intent.ACTION_SENDTO, dataUri); startActivity(intent);&#125; 管理账号 1234567891011121314151617181920212223Intent intent = new Intent(Settings.ACTION_SYNC_SETTINGS); //调用系统账号管理界面设置startActivity(new Intent(this, ContactsPreferenceActivity.class));ContactsPreferenceActivity -&gt; DisplayOptionsPreferenceFragmentContactSaveService解析负责保存对内容提供者的更改的服务createRawContact() //创建联系人saveContact() //保存联系人createGroup() //创建群组renameGroup() //重命名群组deleteGroup() //删除群组updateGroup() //更新群组setStarred() //设置收藏setSuperPrimary() //设置主要联系人clearPrimary() //清除主要联系人deleteMultipleContacts() //删除多个联系人deleteContact() //删除联系人joinContacts() //关联联系人joinSeveralContacts() //取消联系人关联setSendToVoicemail() //设置发送语音邮箱setRingtone() //设置铃声这些方法是联系人项目中用的的对联系人的增删改查操作，方法里面通过ContentResolver来实现数据库的操作，示例如下：getContentResolver().XXX(); 联系人数据库之ContactsProvider packages/providers/ContactsProvider是Android设备上的联系人数据存储，组织，管理组件 ContactsProvider模块中主要有： 1、ContactsProvider处理联系人数据，操作raw_contacts, contacts, accounts, agg_exception, data, group, mimetypes, name_lookup, phone_lookup, settings, v1_settings数据表 2、CallLogProvider主要处理通话记录，操作calls表 3、SocialProvider主要处理社交整合的数据，操作activitys和status_updates表 ContactsProvider的API路径\\frameworks\\base\\core\\java\\android\\provider\\ 数据库创建 作为数据存储组件，最重要的就是数据，那么ContactsProvider的数据库的表结构是什么？ 在ContactsProvider中数据库的创建和表的创建在com.android.providers.contacts. ContactsDatabaseHelper类中实现 下面具体分析ContactsDatabaseHelper类： ContactsDatabaseHelper继承SQLiteOpenHelper类 类中使用单例设计模式，创建对象，在构造方法中创建数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Contacts DB version ranges: * &lt;pre&gt; * 0-98 Cupcake/Donut * 100-199 Eclair * 200-299 Eclair-MR1 * 300-349 Froyo * 350-399 Gingerbread * 400-499 Honeycomb * 500-549 Honeycomb-MR1 * 550-599 Honeycomb-MR2 * 600-699 Ice Cream Sandwich * 700-799 Jelly Bean * 800-899 Kitkat * 900-999 Lollipop * 1000-1099 M * 1100-1199 N * &lt;/pre&gt; */static final int DATABASE_VERSION = 1111; //当前数据库版本1111private static final String DATABASE_NAME = \"contacts2.db\"; //数据库名称/** *主要的三个表，contacts, raw_contacts, data存储所有的联系人信息 *其他表是辅助表，Contact provider利用它们来管理其操作， *或为设备的联系人或电话应用中的特定功能提供支持。 */public interface Tables &#123; ........ //表示不同联系人的行，基于聚合的原始联系人行 public static final String CONTACTS = \"contacts\"; //包含联系人数据摘要的行，针对特定用户帐户和类型 public static final String RAW_CONTACTS = \"raw_contacts\"; public static final String STREAM_ITEMS = \"stream_items\"; public static final String STREAM_ITEM_PHOTOS = \"stream_item_photos\"; public static final String PHOTO_FILES = \"photo_files\"; public static final String PACKAGES = \"packages\"; public static final String MIMETYPES = \"mimetypes\"; public static final String PHONE_LOOKUP = \"phone_lookup\"; public static final String NAME_LOOKUP = \"name_lookup\"; public static final String AGGREGATION_EXCEPTIONS = \"agg_exceptions\"; public static final String SETTINGS = \"settings\"; //包含原始联系人详细信息（例如电子邮件地址或电话号码）的行 public static final String DATA = \"data\"; public static final String GROUPS = \"groups\"; public static final String PRESENCE = \"presence\"; public static final String AGGREGATED_PRESENCE = \"agg_presence\"; public static final String NICKNAME_LOOKUP = \"nickname_lookup\"; public static final String CALLS = \"calls\"; public static final String STATUS_UPDATES = \"status_updates\"; public static final String PROPERTIES = \"properties\"; public static final String ACCOUNTS = \"accounts\"; public static final String VISIBLE_CONTACTS = \"visible_contacts\"; public static final String DIRECTORIES = \"directories\"; public static final String DEFAULT_DIRECTORY = \"default_directory\"; public static final String SEARCH_INDEX = \"search_index\"; public static final String VOICEMAIL_STATUS = \"voicemail_status\"; ........&#125; onCreate方法中进行所有的表的创建，下面是代码 1234567891011public void onCreate(SQLiteDatabase db) &#123; //创建_sync_state和_sync_state_metadata表，主要用于同步时，状态的记录 mSyncState.createDatabase(db); //首先创建属性表，以便尽快确定创建时间。 PropertyUtils.createPropertiesTable(db); ............ db.execSQL()..........//此类语句都是执行相关表和视图的创建 ............ //创建视图和settings表 LegacyApiSupport.createDatabase(db);&#125; 数据库操作 数据库操作，主要分为两个模块ContactsProvider2和LegacyApiSupport进行处理 用户通过传递参数URL，先匹配ContactsProvider2中定义的URL，如果匹配成功则进行数据操作并返回 如果匹配不成功，则进入LegacyApiSupport中进行匹配，进行数据操作数据库涉及到读操作的行为，主要是数据查询，程序直接通过URL匹配查询，返回数据集 数据库涉及到写操作的行为，主要包括增加、删除、修改，针对多个数据表的操作ContactsProvider采用事务机制，多个数据表的数据的操作全部完成后，统一进行提交。单表操作，则不会使用 事务机制具体定义如下： 1234mDb.beginTransactionWithListener(this)insertInTransaction() / updatnTransaction() / deleteInTransaction()mDb.setTransactionSuccessful()mDb.endTransaction() beginTransactionWithListener中调用onBegin()方法，实现事务处理前期准备工作 endTransaction 中调用onCommit()方法，根据事务的执行状态，进行数据提交 ContactsProvider模块通过在SQLiteContentProvider文件的applyBatch()方法中进行标志变量的设置，来判断是否为多操作 单表操作都是通过URL匹配，完成数据库造作 多表操作主要是通过构建ContentProviderOperation数组，设计多个表的数据变化，最为常见的为联系人的增删改，联系人数据会涉及到下面的表 1raw_contacts，contacts，data，name_lookup，phone_lookup，mimetypes 下面主要分析联系人的增删改操作： 增加联系人 用户在联系人新增界面，填入需要的联系人信息数据，比如名字，电话号码，电子邮件等信息，用户点击保存会调用ContactSaveService.java中的createRawContact()方法来进行联系人插入操作 1234567891011121314private void createRawContact(Intent intent) &#123; .......... //先构造带有RawContacts.CONTENT_URI的数据，然后根据用户输入的数据的mimetype类型， //构造带有Data.CONTENT_URI的数据。 ArrayList&lt;ContentProviderOperation&gt; operations = new ArrayList&lt;ContentProviderOperation&gt;(); operations.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI) .withValue(RawContacts.ACCOUNT_NAME, accountName) .withValue(RawContacts.ACCOUNT_TYPE, accountType) .withValue(RawContacts.DATA_SET, dataSet) .build()); ........... //最后会调用applyBatch()函数进行数据写入。 results = resolver.applyBatch(ContactsContract.AUTHORITY, operations);&#125; 关于AbstractContactsProvider. applyBatch()： 调用applyBatch()函数过程中，会读取ContentProviderOperation数组，而数组的每一条记录都会带有一个URI，通过匹配URI，找到对应的表进行插入操作。操作成功后得到返回结果，并对关联数据mValuesBackReferences中的字段值进行更新。 获取mimetype，并根据mimetype类型数据，获得不同的DataRowHandler，进行data数据的写入。（data数据操作具体见Data表数据增加、修改、删除） 查询联系人 由于数据查询涉及多个表间关系，大量数据的查询都是通过视图来完成的，创建了如下视图，而这几个视图是大家在调用api进行查询时显示的数据： 123456789101112public interface Views &#123; public static final String DATA = \"view_data\"; public static final String RAW_CONTACTS = \"view_raw_contacts\"; public static final String CONTACTS = \"view_contacts\"; public static final String ENTITIES = \"view_entities\"; public static final String RAW_ENTITIES = \"view_raw_entities\"; public static final String GROUPS = \"view_groups\"; public static final String DATA_USAGE_STAT = \"view_data_usage_stat\"; public static final String STREAM_ITEMS = \"view_stream_items\"; public static final String METADATA_SYNC = \"view_metadata_sync\"; public static final String METADATA_SYNC_STATE = \"view_metadata_sync_state\";&#125; Data表数据增加、修改、删除 AbstractContactsProvider联系人数据库操作基类，他的两个子类分别是ContactsProvider2和ProfileProvider 其中ProfileProvider是ContactsProvider2的委托类AbstractContactsProvider类中定义了以下三个抽象方法，分别负责对联系人数据的增加，删除，修改 该类使用了模板模式的设计模式,模板方法如下 该类在对数据库进行事务操作的同时，对子类开放了onRollback，onCommit等事物回调方法 子类可以根据自己的业务特点进行扩展 123protected abstract Uri insertInTransaction(Uri uri, ContentValues values);protected abstract int deleteInTransaction(Uri uri, String selection, String[] selectionArgs);protected abstract int updateInTransaction(Uri uri, ContentValues values, String selection, String[] selectionArgs); ContactsTransaction.java是对事务的管理类，主要对进行的事务进行管理，类似一个事务池 是AbstractContactsProvider.java中事务处理的核心类 DataRowHandler.java是数据处理抽象类，实现了对数据的增删改操作，下面都是它的实现类 123456789101112DataRowHandlerForCommonDataKind.java DataRowHandlerForCustomMimetype.java DataRowHandlerForEmail.java DataRowHandlerForGroupMembership.java DataRowHandlerForIm.java DataRowHandlerForNickname.java DataRowHandlerForNote.java DataRowHandlerForOrganization.java DataRowHandlerForPhoneNumber.java DataRowHandlerForPhoto.java DataRowHandlerForStructuredName.java DataRowHandlerForStructuredPostal.java 在ContactsProvider2.initDataRowHandlers() 方法中对所有的DataRowHandler进行了初始化操作 其调用在ContactsProvider2.getDataRowHandler()方法之通过 mimetype匹配调用 所有数据的mimetype都被存储在表Tables.MIMETYPES中，该只有两个字段_id和mimetype","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"App","slug":"App","permalink":"https://blog.hsujee.io/tags/App/"},{"name":"Contact","slug":"Contact","permalink":"https://blog.hsujee.io/tags/Contact/"}]},{"title":"《八十年代的歌》赵雷","date":"2017-05-08T16:00:00.000Z","path":"2017/05/09/Guitar/2017-05-09-《八十年代的歌》赵雷/","text":"《八十年代的歌》赵雷 小伟版","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"}]},{"title":"Android多国语言文件夹汇总","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/Android/App/2017-04-12-Android多国语言文件夹汇总/","text":"中文（中国）：values-zh-rCN 中文（台湾）：values-zh-rTW 中文（香港）：values-zh-rHK 英语（美国）：values-en-rUS 英语（英国）：values-en-rGB 英文（澳大利亚）：values-en-rAU 英文（加拿大）：values-en-rCA 英文（爱尔兰）：values-en-rIE 英文（印度）：values-en-rIN 英文（新西兰）：values-en-rNZ 英文（新加坡）：values-en-rSG 英文（南非）：values-en-rZA 阿拉伯文（埃及）：values-ar-rEG 阿拉伯文（以色列）：values-ar-rIL 保加利亚文: values-bg-rBG 加泰罗尼亚文：values-ca-rES 捷克文：values-cs-rCZ 丹麦文：values-da-rDK 德文（奥地利）：values-de-rAT 德文（瑞士）：values-de-rCH 德文（德国）：values-de-rDE 德文（列支敦士登）：values-de-rLI 希腊文：values-el-rGR 西班牙文（西班牙）：values-es-rES 西班牙文（美国）：values-es-rUS 芬兰文（芬兰）：values-fi-rFI 希伯来文：values-iw-rIL 克罗里亚文：values-hr-rHR 匈牙利文：values-hu-rHU 印度尼西亚文：values-in-rID 意大利文（瑞士）：values-it-rCH 意大利文（意大利）：values-it-rIT 日文：values-ja-rJP 韩文：values-ko-rKR 立陶宛文：valueslt-rLT 拉脱维亚文：values-lv-rLV 挪威博克马尔文：values-nb-rNO 荷兰文(比利时)：values-nl-BE 荷兰文（荷兰）：values-nl-rNL 波兰文：values-pl-rPL 罗马尼亚文：values-ro-rRO 俄文：values-ru-rRU 斯洛伐克文：values-sk-rSK 斯洛文尼亚文：values-sl-rSI 塞尔维亚文：values-sr-rRS 瑞典文：values-sv-rSE 泰文：values-th-rTH 塔加洛语：values-tl-rPH 土耳其文：values–r-rTR 乌克兰文：values-uk-rUA 越南文：values-vi-rVN 法文（比利时）：values-fr-rBE 法文（加拿大）：values-fr-rCA 法文（瑞士）：values-fr-rCH 法文（法国）：values-fr-rFR 斯瓦西里：values-sw 阿拉伯语：values-ar 波斯语：values-fa 提格雷（埃塞俄比亚）：values-ti-rET 阿姆哈拉（埃塞俄比亚）：values-am-rET 奥罗莫语（埃塞俄比亚）：values-om-rET 乌尔都语（巴基斯坦）：values-ur-rPK 葡萄牙语（葡萄牙）：values-pt-rPT 印地文（印度）：values-hi-rIN 孟加拉语（印度）：values-bn-rIN 拉美西语（美国）：values-es-rUS 尼泊尔语（尼泊尔）:values-ne-rNP 缅甸语:values-my-rMM 俄语：values-ru 越南语(越南)：values-vi-rVN 葡萄牙文（巴西）：values-pt-rBR","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"res/raw和assets区别","date":"2017-04-07T16:00:00.000Z","path":"2017/04/08/Android/App/2017-04-08-resraw和assets区别/","text":"res/raw 和 assets 的相同点: 两者目录下的文件在打包后会原封不动的保存在 apk 包中,不会被编译成二进制。 res/raw 和 assets 的不同点: 1.res/raw 中的文件会被映射到R.java文件中,访问的时候直接使用资源ID即R.id.filename;assets文件夹下的文件不会被映射到R.java中,访问的时候需要AssetManager类。 2.res/raw 不可以有目录结构,而 assets 则可以有目录结构,也就是 assets 目录下可以再建立文件夹 读取文件资源: 1.读取 res/raw 下的文件资源,通过以下方式获取输入流来进行写操作 1InputStream is = getResources().openRawResource(R.id.filename); 2.读取 assets 下的文件资源,通过以下方式获取输入流来进行写操作 1234AssetManager am = null; am = getAssets(); InputStream is = am.open(\"filename\"); (用于内置文件但不知道文件名称,需要筛选出想要的文件然后拷贝到目标目录中,推荐内置在 assets 文件夹中) 1.res/raw 目录: 通过反射的方式得到 R.java 里面 raw 内部类里面所有的资源 ID 的名称,然后通过名称获取资源 ID 的值来读取我们想要的文件。 2.assets 目录: getAssets().list(“”);来获取 assets 目录下所有文件夹和文件的名称,再通过这些名称读取我们想要的文件。 另,在处理 asset 时,android 限制最大的数据是 1M,超出后会报错误。","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"项目结构","slug":"项目结构","permalink":"https://blog.hsujee.io/tags/项目结构/"}]},{"title":"Xshell挂载VM中的Ubuntu解决方案","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/Windows/2017-04-05-Xshell挂载VM中的Ubuntu解决方案/","text":"首先看下报错log Connecting to 10.7.100.182:22... Could not connect to &apos;10.7.100.182&apos; (port 22): Connection failed. 这是因为你的ubuntu中没有openssh-server的原因 解决方法如下： root@ubuntu:~# apt-get install openssh-server （ 我是在root模式下，不是root用户的话要加sudo） 查看server是否启动： ps -ef |grep ssh 如果看到/usr/sbin/sshd -D，说明服务已经启动，否则服务尚未启动，那么需要启动server： /etc/init.d/ssh start 接下来就可以用xshell连接了。如果xshell中看到乱码的情况，那么可以xshell的编码改成UTF-8！ xshell中修改编码为UTF-8的方法：[文件]–&gt;[打开]–&gt;在打开的session中选择连接的那个 ,点击properties -&gt; [Terminal ] ,在右边的translation先选择utf8，然后重新连接服务器即可。","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.hsujee.io/tags/Windows/"}]},{"title":"《成都》赵雷","date":"2017-03-31T16:00:00.000Z","path":"2017/04/01/Guitar/2017-04-01-《成都》赵雷/","text":"《成都》赵雷 大伟版","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"}]},{"title":"Android快捷键启动解析","date":"2017-03-24T16:00:00.000Z","path":"2017/03/25/Android/Framework/2017-06-15-Android快捷键启动解析/","text":"Android快捷方式作为Android设备的杀手锏技能，一直都是非常重要的一个功能，也正是如此，各种流氓App也不断通过快捷方式霸占着这样一个用户入口,下面咱们就来说道说道，关于Android快捷方式的那些事。 同时，各大国产ROM和Luncher的崛起，让这个桌面之争变的更加激烈。毕竟大家都只想用户用自己的App资源，所以，现在各大App不仅仅是要抢占入口，同时还要和各大ROM斗智斗勇。本文将对这个快捷方式进行深度解密，同时给出App适配各种ROM的整合方案。 系统提供的方式 首先大家要知道各种Launcher的区别，原生的Launcher，是两层结构，桌面是快捷方式，而进去后的App列表是App的Launch Icon；而以小米为首的一帮ROM，参考iOS风格，将Launcher改为了一层，即直接显示Launch Icon。 权限设置 123456&lt;!-- 添加快捷方式 --&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\" /&gt;&lt;!-- 移除快捷方式 --&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\" /&gt;&lt;!-- 查询快捷方式 --&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.READ_SETTINGS\" /&gt; 通过Action创建快捷方式 参数相信大家都能看得懂，只是有一点需要注意的，duplicate这个属性，是设置该快捷方式是否允许多次创建的属性，但是，在很多ROM上都不能成功识别，嗯，这就是我们最开始说的快捷方式乱现象。 1234567891011121314151617181920212223// Action 添加Shortcutpublic static final String ACTION_ADD_SHORTCUT = com.android.launcher.action.INSTALL_SHORTCUT;/** * 添加快捷方式 * * @param context context * @param actionIntent 要启动的Intent * @param name name */public static void addShortcut(Context context, Intent actionIntent, String name, boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra(duplicate, allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, actionIntent); context.sendBroadcast(addShortcutIntent);&#125; 通过Action删除快捷方式 123456789101112131415161718// Action 移除Shortcutpublic static final String ACTION_REMOVE_SHORTCUT = com.android.launcher.action.UNINSTALL_SHORTCUT;/** * 移除快捷方式 * * @param context context * @param actionIntent 要启动的Intent * @param name name */public static void removeShortcut(Context context, Intent actionIntent, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra(duplicate, false); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, actionIntent); context.sendBroadcast(intent);&#125; 从原理来理解如何来适配各种Launcher 原生的快捷方式添加方法，虽然是官方提供的，但在天国这样一个怎么说呢的国家里，基本是很难使用、适配的，也就是我们最开始说的那些原因。下面我们先从快捷方式的整个生命周期来了解下产生、添加、删除快捷方式的原理，再来思考如何实现多ROM、Launcher的适配。 1、快捷方式的存储 快捷方式其实都存储在Launcher的数据库中，我们在手机上打开SQLite Editor打开Launcher的数据库。 我们打开Launcher.db的”/kf/ware/vc/“ target=”_blank” 123class=&quot;keylink&quot;&gt;vcml0ZbHto6zV4sDvvs3Kx87Sw8exo7TmtcS/7L3dt73Kvcr9vt2jujwvcD4NCjxwPjxpbWcgYWx0PQ==&quot;2.png&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1176696-074d7b877de7c6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; title=&quot;\\&quot; /&gt; 几个主要的字段大家基本一看就懂：title、intent、iconResource、icon，分别对应快捷方式名称，快捷方式intent，快捷方式图标来源，快捷方式图标二进制数据。 2、快捷方式的创建 了解了快捷方式的存储原理，我们就可以针对这个数据库来做文章，所有的快捷方式都可以通过修改这个数据库来实现，同时还不用太考虑兼容性问题。 对于快捷方式的创建，我们依然可以使用系统提供的方法，所以这里不再多说。 3、快捷方式的判断是否存在 前面我们说了，通过duplicate属性可以区分是否允许创建重复的快捷方式，但是，很多ROM是无法兼容到的，所以，这里我们使用查询Launcher数据库的方式来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 检查快捷方式是否存在 * &lt;font color=\"red\"&gt;注意：&lt;/font&gt; 有些手机无法判断是否已经创建过快捷方式 * 因此，在创建快捷方式时，请添加 * shortcutIntent.putExtra(duplicate, false);// 不允许重复创建 * 最好使用&#123;@link #isShortCutExist(Context, String, Intent)&#125; * 进行判断，因为可能有些应用生成的快捷方式名称是一样的的 */public static boolean isShortCutExist(Context context, String title) &#123; boolean result = false; try &#123; ContentResolver cr = context.getContentResolver(); Uri uri = getUriFromLauncher(context); Cursor c = cr.query(uri, new String[]&#123;title&#125;, title=? , new String[]&#123;title&#125;, null); if (c != null &amp;&amp; c.getCount() &gt; 0) &#123; result = true; &#125; if (c != null &amp;&amp; !c.isClosed()) &#123; c.close(); &#125; &#125; catch (Exception e) &#123; result = false; e.printStackTrace(); &#125; return result;&#125;/** * 不一定所有的手机都有效，因为国内大部分手机的桌面不是系统原生的 * 更多请参考&#123;@link #isShortCutExist(Context, String)&#125; * 桌面有两种，系统桌面(ROM自带)与第三方桌面，一般只考虑系统自带 * 第三方桌面如果没有实现系统响应的方法是无法判断的，比如GO桌面 */public static boolean isShortCutExist(Context context, String title, Intent intent) &#123; boolean result = false; try &#123; ContentResolver cr = context.getContentResolver(); Uri uri = getUriFromLauncher(context); Cursor c = cr.query(uri, new String[]&#123;title, intent&#125;, title=? and intent=?, new String[]&#123;title, intent.toUri(0)&#125;, null); if (c != null &amp;&amp; c.getCount() &gt; 0) &#123; result = true; &#125; if (c != null &amp;&amp; !c.isClosed()) &#123; c.close(); &#125; &#125; catch (Exception ex) &#123; result = false; ex.printStackTrace(); &#125; return result;&#125;private static Uri getUriFromLauncher(Context context) &#123; StringBuilder uriStr = new StringBuilder(); String authority = LauncherUtil.getAuthorityFromPermissionDefault(context); if (authority == null || authority.trim().equals()) &#123; authority = LauncherUtil.getAuthorityFromPermission(context, LauncherUtil.getCurrentLauncherPackageName(context) + .permission.READ_SETTINGS); &#125; uriStr.append(content://); if (TextUtils.isEmpty(authority)) &#123; int sdkInt = android.os.Build.VERSION.SDK_INT; if (sdkInt &lt; 8) &#123; // Android 2.1.x(API 7)以及以下的 uriStr.append(com.android.launcher.settings); &#125; else if (sdkInt &lt; 19) &#123;// Android 4.4以下 uriStr.append(com.android.launcher2.settings); &#125; else &#123;// 4.4以及以上 uriStr.append(com.android.launcher3.settings); &#125; &#125; else &#123; uriStr.append(authority); &#125; uriStr.append(/favorites?notify=true); return Uri.parse(uriStr.toString());&#125; 这里有两个重载的isShortCutExist方法，唯一的区别就是最后一个参数——intent，加这个参数的原因，在注释中已经写了，更加精确。而getUriFromLauncher方法，是给调用的ContentResolver提供Uri。构造的时候，可以看见，Android的版本话碎片问题，是多么的严重…… 这样在添加快捷方式前，通过这个判断下，就可以只添加一个快捷方式了。 4、为任意PackageName的App添加快捷方式 知道了我们是如何判断快捷方式是是否存在的，我们就可以通过这种思路来为任意PackageName的App添加快捷方式，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 为PackageName的App添加快捷方式 * * @param context context * @param pkg 待添加快捷方式的应用包名 * @return 返回true为正常执行完毕 */public static boolean addShortcutByPackageName(Context context, String pkg) &#123; // 快捷方式名 String title = unknown; // MainActivity完整名 String mainAct = null; // 应用图标标识 int iconIdentifier = 0; // 根据包名寻找MainActivity PackageManager pkgMag = context.getPackageManager(); Intent queryIntent = new Intent(Intent.ACTION_MAIN, null); queryIntent.addCategory(Intent.CATEGORY_LAUNCHER);// 重要，添加后可以进入直接已经打开的页面 queryIntent.setFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); queryIntent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY); List&lt;resolveinfo&gt; list = pkgMag.queryIntentActivities(queryIntent, PackageManager.GET_ACTIVITIES); for (int i = 0; i &lt; list.size(); i++) &#123; ResolveInfo info = list.get(i); if (info.activityInfo.packageName.equals(pkg)) &#123; title = info.loadLabel(pkgMag).toString(); mainAct = info.activityInfo.name; iconIdentifier = info.activityInfo.applicationInfo.icon; break; &#125; &#125; if (mainAct == null) &#123; // 没有启动类 return false; &#125; Intent shortcut = new Intent( com.android.launcher.action.INSTALL_SHORTCUT); // 快捷方式的名称 shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, title); // 不允许重复创建 shortcut.putExtra(duplicate, false); ComponentName comp = new ComponentName(pkg, mainAct); shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, queryIntent.setComponent(comp)); // 快捷方式的图标 Context pkgContext = null; if (context.getPackageName().equals(pkg)) &#123; pkgContext = context; &#125; else &#123; // 创建第三方应用的上下文环境，为的是能够根据该应用的图标标识符寻找到图标文件。 try &#123; pkgContext = context.createPackageContext(pkg, Context.CONTEXT_IGNORE_SECURITY | Context.CONTEXT_INCLUDE_CODE); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; if (pkgContext != null) &#123; Intent.ShortcutIconResource iconRes = Intent.ShortcutIconResource .fromContext(pkgContext, iconIdentifier); shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes); &#125; // 发送广播，让接收者创建快捷方式 // 需权限&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\"&gt; context.sendBroadcast(shortcut); return true;&#125; 使用一些Trick来解决多Launcher适配的问题 由于快捷方式的碎片化非常严重，所以，你顾得上这种ROM，顾不上其它ROM。例如，在原生ROM上，你需要使用类似原生的Launcher权限： 12&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\" /&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\" /&gt; 但是，在其它ROM上呢，例如华为，你需要这样的权限： 12&lt;uses-permission android:name=\"com.huawei.launcher3.permission.READ_SETTINGS\" /&gt;&lt;uses-permission android:name=\"com.huawei.launcher3.permission.WRITE_SETTINGS\" /&gt; 为了程序能够通用性够强，理论上我们得为所有不使用原生Launcher权限的Launcher配置权限代码，是的，你妹听错，是所有，只有通过这种奇技淫巧，才能适配更多的Launcher，这里贴一部分给大家爽一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE/\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE/\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_SETTINGS/\" /&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\"&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\"&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher2.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher2.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher3.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher3.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.htc.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.htc.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.qihoo360.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.qihoo360.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.lge.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.lge.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"net.qihoo.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"net.qihoo.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adwfreak.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adwfreak.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher_donut.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher_donut.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher3.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher3.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.fede.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.fede.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.sec.android.app.twlauncher.settings.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.sec.android.app.twlauncher.settings.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.anddoes.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.anddoes.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.tencent.qqlauncher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.tencent.qqlauncher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher2.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher2.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.mylauncher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.mylauncher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.ebproductions.android.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.ebproductions.android.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.oppo.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.oppo.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.miui.mihome2.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.miui.mihome2.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.android.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.android.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"telecom.mdesk.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"telecom.mdesk.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"dianxin.permission.ACCESS_LAUNCHER_DATA\"&gt; 这时候大家肯定要问了，你申请这么多权限，用户在安装App的时候，不是要崩溃了，尼玛，这么多看都看不过来啊，其实，根本不需要担心，因为这些基本都是各自ROM中的第三方ROM权限，在用户安装的时候，他们通常会被解析成原生Launcher的权限，例如：添加、修改桌面快捷方式。并不会将所有的权限都写出来。 使用其他方式来实现类似快捷方式的方法 快捷方式的确是我们为应用导流的一个非常重要的入口，但是，由于碎片化实在太严重，所以，我们可以使用在Launcher App列表中为应用增加一个入口的方式来为App导流，简单的说，就是增进一个App的入口Activity。 123&lt;intent-filter&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt; 非常简单，相信大家都知道这种方式来给App增加一个Activity入口。但是，这种方式，我们如何能够自由的控制这个入口是否显示呢？ 1、奇技PackageManager PackageManager提供了一系列Package的管理方法，当然，也包含了我们非常关心的启用、停用组件这一方法，这个方法在Root情况下，可以修改任一App的任意组件，在普通情况下，对自身App有绝对权限。使用方法也非常简单： 12345678910111213141516171819public static void toggleFlowEntrance(Context context, Class launcherClass) &#123; PackageManager packageManager = context.getPackageManager(); ComponentName componentName = new ComponentName(context, launcherClass); int res = packageManager.getComponentEnabledSetting(componentName); if (res == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || res == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) &#123; // 隐藏应用图标 packageManager.setComponentEnabledSetting( componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP); &#125; else &#123; // 显示应用图标 packageManager.setComponentEnabledSetting( componentName, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT, PackageManager.DONT_KILL_APP); &#125;&#125; 总结 前面我们分析了各种快捷方式、Launcher入口的方式来对App进行导流，当然，这不是我们的目的，我们的目的是能够掌握Android快捷方式的哭花宝典而不用那个啥。 下面是GitHub的开源项目 项目地址： https://github.com/xuyisheng/ShortcutHelper","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"https://blog.hsujee.io/tags/FrameWork/"}]},{"title":"常用命令行操作记录","date":"2017-03-22T16:00:00.000Z","path":"2017/03/23/Android/Tool/2017-03-23-常用命令行操作记录/","text":"更改邮箱 123456789101112131415161718192021222324252627repo forall -c git config user.email xuyanjie@163.com``` + 建立分支&gt; repo 管理所有的Git仓库所有目录：repo start 分支名 --all指定目录：repo start 分支名 abi/当前目录：repo start 分支名 .查看分支：repo branch&gt; git创建分支：git branch 分支名切换分支：git checkout 分支名+ 更新最新代码repo sync -c -j4```java repo forall -c git reset --hard HEAD &amp;&amp; repo forall -c git clean -dfxq &amp;&amp; repo sync 代码编译 预编译处理：source rlk_setenv.sh 项目名 userdebug 整体编译：make -j24 2&gt;&amp;1 | tee build.log 休眠2小时后编译：sleep 2h &amp;&amp; make -j24 2&gt;&amp;1 | tee build.log 1make -j24 2&gt;&amp;1 | tee build.log Git代码仓库操作 从服务器拉取仓库：git pull 从本地推送仓库到服务器：git push origin HEAD:refs/for/分支名 或 更目录repo upload 查看改变的文件内容：git diff 添加新建文件到仓库：git add 文件名 1git add . 提交修改文件到本地仓库：git commit -a 后修改日志文件 查看所有分支：git branch -a 搜索文件 查找文件：find ./ -name “xxx” 查找文包含xxx的文件：grep “xxx” 123find ./ -name \"mtk_dialer_search_item_view.xml\"find ./ -name \"*.xml\" | xargs grep --color \"labelAndNumber\" 查看服务器运行状态：top 重置最近一次提交：git reset HEAD^ 配置编译环境：source build/envsetup.sh 删除目录 删除文件：rm -rf 目录名字 清除当前文件夹下所有新增文件：git clean -dfx . shell操作 查看所有进程：adb shell ps 关闭该进程：adb shell kill pid编号 adb root adb remount adb push 文件 目标路径","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.hsujee.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://blog.hsujee.io/tags/Git/"}]},{"title":"VS2013+QT5开发环境配置win7","date":"2017-03-19T16:00:00.000Z","path":"2017/03/20/Windows/2017-03-20-VS2013+QT5开发环境配置win7/","text":"","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.hsujee.io/tags/Windows/"}]},{"title":"《枫叶城》指弹吉他谱-杨昊坤","date":"2017-03-06T16:00:00.000Z","path":"2017/03/07/Guitar/2017-03-07-《枫叶城》指弹吉他谱-杨昊坤/","text":"枫叶城-杨昊坤","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"},{"name":"指弹","slug":"指弹","permalink":"https://blog.hsujee.io/tags/指弹/"}]},{"title":"Android自定义可拖拽交换位置的GridView","date":"2017-02-18T16:00:00.000Z","path":"2017/02/19/Android/CustemView/2017-02-19-Android自定义可拖拽交换位置的GridView/","text":"如下图所示，下面开始自定义一个可拖放的GridView 今天这篇文章自定义GridView的控件，GridView主要是来显示网格的控件，在Android的开发中使用很普通，相对于TextView，Button这些控件来说要来的复杂些，今天给大家带来长按GridView的item,然后将其拖拽其他item上面，使得GridView的item发生交换，比较典型的就是我们的Launcher，网上有很多关于GridView的拖动的Demo，但是大部分都是相同的，而且存在一些Bug,而且大部分都是点击GridView的item然后进行拖动，或者item之间不进行实时交换，今天给大家更加详细的介绍GridView拖拽，并且将Demo做的更完美，大家更容易接受，也许很多人听到这个感觉实现起来很复杂，就关掉的这篇文章，其实告诉大家，只要知道了思路就感觉一点都不复杂了，不信大家可以接着往下看看，首先还是跟大家说说实现的思路 根据手指按下的X,Y坐标来获取我们在GridView上面点击的item手指按下的时候使用Handler和Runnable来实现一个定时器，假如定时时间为1000毫秒，在1000毫秒内，如果手指抬起了移除定时器，没有抬起并且手指点击在GridView的item所在的区域，则表示我们长按了GridView的item如果我们长按了item则隐藏item,然后使用WindowManager来添加一个item的镜像在屏幕用来代替刚刚隐藏的item当我们手指在屏幕移动的时候，更新item镜像的位置，然后在根据我们移动的X,Y的坐标来获取移动到GridView的哪一个位置到GridView的item过多的时候，可能一屏幕显示不完，我们手指拖动item镜像到屏幕下方，要触发GridView想上滚动，同理，当我们手指拖动item镜像到屏幕上面，触发GridView向下滚动GridView交换数据，刷新界面，移除item的镜像看完上面的这些思路你是不是找到了些感觉了呢，心里痒痒的想动手试试吧，好吧，接下来就带大家根据思路来实现可拖拽的GridView，新建一个项目就叫DragGridView 首先看DragGridView的事件分发方法，不了解Android事件分发的可以先去了解下，Android事件分发对于自定义控件很重要，简单说下，当我们点击DragGridView的Item,先会去执行dispatchTouchEvent()方法将事件分发下去，所以我们要重写dispatchTouchEvent()方法在手指按下的时候根据pointToPosition()方法来获取我们按下的item的position,根据getChildAt()方法来获取该position上面所对应的View, 并且开启长按的定时器，默认时间为1000毫秒，如果在1000毫秒内手指抬起或者手指在屏幕上滑动出了该item，则取消长按定时器，否则就表示可以进行拖拽，手机友好的震动一下，隐藏我们长按的Item，屏幕调用createDragImage()方法来创建我们长按的item的镜像，创建Item的镜像使用的是WindowManager类，该类可以创建一个窗体显示在Activity之上，再此之前大家先要理解这几个距离，理解这几个距离之前要首先知道getRawX(),getRawY()和getX(),getY()的区别，getRawX(),getRawY()是相对于屏幕的原点的距离，而getX(),getY()是相对于控件左上方的点的距离，为了方便大家理解我用Word简单的画了下图，画得不好，大家将就的看下，红色框框为我们的GridView mPoint2ItemTop 手指按下的点到该Item的上边缘的距离，如上图的1号线mPoint2ItemLeft 手指按下的点到该Item的左边缘的距离，如上图的2号线mOffset2Top DragGridView的上边缘到屏幕上边缘的距离，如上图的3号线，这个距离包裹状态栏，标题栏，或者一些在DragGridView上面的布局的高度，这个很重要我们现实Item镜像需要用到mOffset2Left DragGridView的左边缘到屏幕左边缘的距离，如上图的4号线，我这个Demo的这个距离为0，因为我设置DragGridView的宽度为充满屏幕，但是我们要考虑假如DragGridView与屏幕左边缘设置了间隙或者左边有其他的布局的情形mDownScrollBorder 这个距离表示当DragGridView的item过多的时候，手机一屏显示不完全，我们拖动Item镜像到这个高度的时候，DragGridView自动向下滚动，如上图的5号线.mUpScrollBorder 这个和mDownScrollBorder相反，当我们大于这个高度的时候，DragGridView自动向上滚动，如上图的6号线理解了这六个距离，我们就来看看创建Item镜像的方法里面，其他的我不多说，首先设置format为PixelFormat.TRANSLUCENT，表示除了我们显示图片和文字的其他地方为透明，之后就是x，y这两个距离的计算，计算的是item的左上角的坐标，理解了上面这六个距离我们很容易得出x,y的坐标，可是你会发现y的坐标减去了状态栏的高度，这点大家需要注意下，另外我们需要获取item的绘制缓存的Bitmap对象，然后将Bitmap设置到一个ImageView上面，为什么要这么做呢？如果调用addView()方法将item 直接添加到WindowManager里面，会有异常产生，因为item已经有了自己归属的父容器DragGridView，所有我们这里使用一个ImageView来代替item添加到WindowManager里面 上面已经完成了开始拖拽的准备工作，要想拖动镜像我们还需要重写onTouchEvent()方法，获取移动的X,Y的坐标，利用WindowManager的updateViewLayout方法就能对镜像进行拖动，拖动的镜像的时候为了有更好的用户体验，我们还要做item的实时交换效果，我们利用手指移动的X,Y坐标，利用pointToPosition()来获取拖拽到的position,然后将之前的item显示出来，将拖拽到的item进行隐藏，这样子就完成了item在界面上面的交换，但是数据交换我这里没有做，所以我提供了回调接口OnChanageListener，我们只需要自己实现数据的交换逻辑然后刷新DragGridView即可，我们还需要实现DragGridView的自动向上滚动或者向下滚动，使用Handler和mScrollRunnable利用smoothScrollToPositionFromTop来实现DragGridView滚动，具体的实现大家可以看代码手指离开界面，将item的镜像移除，并将拖拽到的item显示出来，这样子就实现了GirdView的拖拽效果啦，接下来我们来使用下我们自定义可拖拽的GridView吧，先看主界面布局，只有我们自定义的一个DragGridView 下面是布局文件中的使用方法： 12345678910111213141516171819&lt;relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;com.example.draggridview.draggridview android:id=\"@+id/dragGridView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:cachecolorhint=\"@android:color/transparent\" android:gravity=\"center\" android:horizontalspacing=\"10dip\" android:listselector=\"@android:color/transparent\" android:numcolumns=\"3\" android:stretchmode=\"columnWidth\" android:verticalspacing=\"10dip\"&gt; &lt;/com.example.draggridview.draggridview&gt; &lt;/relativelayout&gt; 接下来我们看看DragGridView的item的布局，上面一个ImageView下面一个TextView 123456789101112131415161718192021222324&lt;relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:background=\"@android:color/transparent\"&gt; &lt;imageview android:id=\"@+id/item_image\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerhorizontal=\"true\" android:scaletype=\"centerCrop\"&gt; &lt;/imageview&gt; &lt;textview android:id=\"@+id/item_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/item_image\" android:layout_centerhorizontal=\"true\"&gt; &lt;/textview&gt; &lt;/relativelayout&gt; 布局搞定了我们就来看看主页面MainActivity的代码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.draggridview;import android.app.Activity;import android.os.Bundle;import android.widget.SimpleAdapter;import com.example.draggridview.DragGridView.OnChanageListener;import com.irobotcity.smokeverify.R;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;public class MainActivity extends Activity &#123; private List&lt;HashMap&lt;String, Object&gt;&gt;dataSourceList=new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DragGridView mDragGridView = (DragGridView) findViewById(R.id.dragGridView); for (int i = 0; i &lt; 30; i++) &#123; HashMap&lt;String, Object&gt; itemHashMap = new HashMap&lt;String, Object&gt; (); itemHashMap.put(\"item_image\", R.drawable.com_tencent_open_notice_msg_icon_big); itemHashMap.put(\"item_text\", \"拖拽\" + Integer.toString(i)); dataSourceList.add(itemHashMap); &#125; final SimpleAdapter mSimpleAdapter = new SimpleAdapter(this, dataSourceList, R.layout.grid_item, new String[]&#123;item_image, item_text&#125;, new int[]&#123;R.id.item_image, R.id.item_text&#125;); mDragGridView.setAdapter(mSimpleAdapter); mDragGridView.setOnChangeListener(new OnChanageListener() &#123; @Override public void onChange(int from, int to) &#123; HashMap&lt;String, Object&gt; temp = dataSourceList.get(from); //直接交互item// dataSourceList.set(from, dataSourceList.get(to));// dataSourceList.set(to, temp);// dataSourceList.set(to, temp); //这里的处理需要注意下 if (from &lt; to) &#123; for (int i = from; i &lt; to; i++)&#123; for (int j = from; j &gt; to; i--) &#123; Collections.swap(dataSourceList, i, j - 1); &#125; &#125; dataSourceList.set(to, temp); mSimpleAdapter.notifyDataSetChanged(); &#125; &#125; ); &#125; &#125;&#125; 下面是自定义的GridView代码,新建一个类DragGridView继承GridView,先来看看DragGridView的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392package com.example.draggridview;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Context;import android.graphics.Bitmap;import android.graphics.PixelFormat;import android.graphics.Rect;import android.os.Handler;import android.os.Vibrator;import android.util.AttributeSet;import android.view.Gravity;import android.view.MotionEvent;import android.view.View;import android.view.WindowManager;import android.widget.AdapterView;import android.widget.GridView;import android.widget.ImageView;@SuppressLint(NewApi)public class DragGridView extends GridView &#123; /** * DragGridView的item长按响应的时间， 默认是1000毫秒，也可以自行设置 */ private long dragResponseMS = 1000; /** * 是否可以拖拽，默认不可以 */ private boolean isDrag = false; private int mDownX; private int mDownY; private int moveX; private int moveY; /** * 正在拖拽的position */ private int mDragPosition; /** * 刚开始拖拽的item对应的View */ private View mStartDragItemView = null; /** * 用于拖拽的镜像，这里直接用一个ImageView */ private ImageView mDragImageView; /** * 震动器 */ private Vibrator mVibrator; private WindowManager mWindowManager; /** * item镜像的布局参数 */ private WindowManager.LayoutParams mWindowLayoutParams; /** * 我们拖拽的item对应的Bitmap */ private Bitmap mDragBitmap; /** * 按下的点到所在item的上边缘的距离 */ private int mPoint2ItemTop; /** * 按下的点到所在item的左边缘的距离 */ private int mPoint2ItemLeft; /** * DragGridView距离屏幕顶部的偏移量 */ private int mOffset2Top; /** * DragGridView距离屏幕左边的偏移量 */ private int mOffset2Left; /** * 状态栏的高度 */ private int mStatusHeight; /** * DragGridView自动向下滚动的边界值 */ private int mDownScrollBorder; /** * DragGridView自动向上滚动的边界值 */ private int mUpScrollBorder; /** * DragGridView自动滚动的速度 */ private static final int speed = 80; /** * item发生变化回调的接口 */ private OnChanageListener onChanageListener; public DragGridView(Context context) &#123; this(context, null); &#125; public DragGridView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DragGridView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE); mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); mStatusHeight = getStatusHeight(context); //获取状态栏的高度 &#125; private Handler mHandler = new Handler(); //用来处理是否为长按的Runnable private Runnable mLongClickRunnable = new Runnable() &#123; @Override public void run() &#123; isDrag = true; //设置可以拖拽 mVibrator.vibrate(50); //震动一下 mStartDragItemView.setVisibility(View.INVISIBLE);//隐藏该item //根据我们按下的点显示item镜像 createDragImage(mDragBitmap, mDownX, mDownY); &#125; &#125;; /** * 设置回调接口 * * @param onChanageListener */ public void setOnChangeListener(OnChanageListener onChanageListener) &#123; this.onChanageListener = onChanageListener; &#125; /** * 设置响应拖拽的毫秒数，默认是1000毫秒 * * @param dragResponseMS */ public void setDragResponseMS(long dragResponseMS) &#123; this.dragResponseMS = dragResponseMS; &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: //使用Handler延迟dragResponseMS执行mLongClickRunnable mHandler.postDelayed(mLongClickRunnable, dragResponseMS); mDownX = (int) ev.getX(); mDownY = (int) ev.getY(); //根据按下的X,Y坐标获取所点击item的position mDragPosition = pointToPosition(mDownX, mDownY); if (mDragPosition == AdapterView.INVALID_POSITION) &#123; return super.dispatchTouchEvent(ev); &#125; //根据position获取该item所对应的View mStartDragItemView = getChildAt(mDragPosition - getFirstVisiblePosition()); //下面这几个距离大家可以参考我的博客上面的图来理解下 mPoint2ItemTop = mDownY - mStartDragItemView.getTop(); mPoint2ItemLeft = mDownX - mStartDragItemView.getLeft(); mOffset2Top = (int) (ev.getRawY() - mDownY); mOffset2Left = (int) (ev.getRawX() - mDownX); //获取DragGridView自动向上滚动的偏移量，小于这个值，DragGridView向下滚动 mDownScrollBorder = getHeight() / 4; //获取DragGridView自动向下滚动的偏移量，大于这个值，DragGridView向上滚动 mUpScrollBorder = getHeight() * 3 / 4; //开启mDragItemView绘图缓存 mStartDragItemView.setDrawingCacheEnabled(true); //获取mDragItemView在缓存中的Bitmap对象 mDragBitmap = Bitmap.createBitmap(mStartDragItemView.getDrawingCache()); //这一步很关键，释放绘图缓存，避免出现重复的镜像 mStartDragItemView.destroyDrawingCache(); break; case MotionEvent.ACTION_MOVE: int moveX = (int) ev.getX(); int moveY = (int) ev.getY(); //如果我们在按下的item上面移动，只要不超过item的边界我们就不移除mRunnable if (!isTouchInItem(mStartDragItemView, moveX, moveY)) &#123; mHandler.removeCallbacks(mLongClickRunnable); &#125; break; case MotionEvent.ACTION_UP: mHandler.removeCallbacks(mLongClickRunnable); mHandler.removeCallbacks(mScrollRunnable); break; &#125; return super.dispatchTouchEvent(ev); &#125; /** * 是否点击在GridView的item上面 * * @param dragView * @param x * @param y * @return */ private boolean isTouchInItem(View dragView, int x, int y) &#123; int leftOffset = dragView.getLeft(); int topOffset = dragView.getTop(); if (x &lt; leftOffset || x &gt; leftOffset + dragView.getWidth()) &#123; return false; &#125; if (y &lt; topOffset || y &gt; topOffset + dragView.getHeight()) &#123; return false; &#125; return true; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isDrag &amp;&amp; mDragImageView != null) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_MOVE: moveX = (int) ev.getX(); moveY = (int) ev.getY(); //拖动item onDragItem(moveX, moveY); break; case MotionEvent.ACTION_UP: onStopDrag(); isDrag = false; break; &#125; return true; &#125; return super.onTouchEvent(ev); &#125; /** * 创建拖动的镜像 * * @param bitmap * @param downX 按下的点相对父控件的X坐标 * @param downY 按下的点相对父控件的X坐标 */ private void createDragImage(Bitmap bitmap, int downX, int downY) &#123; mWindowLayoutParams = new WindowManager.LayoutParams(); mWindowLayoutParams.format = PixelFormat.TRANSLUCENT; //图片之外的其他地方透明 mWindowLayoutParams.gravity = Gravity.TOP | Gravity.LEFT; mWindowLayoutParams.x = downX - mPoint2ItemLeft + mOffset2Left; mWindowLayoutParams.y = downY - mPoint2ItemTop + mOffset2Top - mStatusHeight; mWindowLayoutParams.alpha = 0.55f; //透明度 mWindowLayoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT; mWindowLayoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT; mWindowLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; mDragImageView = new ImageView(getContext()); mDragImageView.setImageBitmap(bitmap); mWindowManager.addView(mDragImageView, mWindowLayoutParams); &#125; /** * 从界面上面移动拖动镜像 */ private void removeDragImage() &#123; if (mDragImageView != null) &#123; mWindowManager.removeView(mDragImageView); mDragImageView = null; &#125; &#125; /** * 拖动item，在里面实现了item镜像的位置更新，item的相互交换以及GridView的自行滚动 * * @param moveX * @param moveY */ private void onDragItem(int moveX, int moveY) &#123; mWindowLayoutParams.x = moveX - mPoint2ItemLeft + mOffset2Left; mWindowLayoutParams.y = moveY - mPoint2ItemTop + mOffset2Top - mStatusHeight; mWindowManager.updateViewLayout(mDragImageView, mWindowLayoutParams); //更新镜像的位置 onSwapItem(moveX, moveY); //GridView自动滚动 mHandler.post(mScrollRunnable); &#125; /** * 当moveY的值大于向上滚动的边界值，触发GridView自动向上滚动 * &lt;p&gt; * 当moveY的值小于向下滚动的边界值，触犯GridView自动向下滚动 * &lt;p&gt; * 否则不进行滚动 */ private Runnable mScrollRunnable = new Runnable() &#123; @Override public void run() &#123; int scrollY; if (moveY &gt; mUpScrollBorder) &#123; scrollY = -speed; mHandler.postDelayed(mScrollRunnable, 25); &#125; else if (moveY &lt; mDownScrollBorder) &#123; scrollY = speed; mHandler.postDelayed(mScrollRunnable, 25); &#125; else &#123; scrollY = 0; mHandler.removeCallbacks(mScrollRunnable); &#125; //当我们的手指到达GridView向上或者向下滚动的偏移量的时候，可能我们手指没有移动，但是DragGridView在自动的滚动 //所以我们在这里调用下onSwapItem()方法来交换item onSwapItem(moveX, moveY); View view = getChildAt(mDragPosition - getFirstVisiblePosition()); //实现GridView的自动滚动 smoothScrollToPositionFromTop(mDragPosition, view.getTop() + scrollY); &#125; &#125;; /** * 交换item,并且控制item之间的显示与隐藏效果 * * @param moveX * @param moveY */ private void onSwapItem(int moveX, int moveY) &#123; //获取我们手指移动到的那个item的position int tempPosition = pointToPosition(moveX, moveY); //假如tempPosition 改变了并且tempPosition不等于-1,则进行交换 if (tempPosition != mDragPosition &amp;&amp; tempPosition != AdapterView.INVALID_POSITION) &#123; getChildAt(tempPosition - getFirstVisiblePosition()).setVisibility(View.INVISIBLE);//拖动到了新的item,新的item隐藏掉 getChildAt(mDragPosition - getFirstVisiblePosition()).setVisibility(View.VISIBLE);//之前的item显示出来 if (onChanageListener != null) &#123; onChanageListener.onChange(mDragPosition, tempPosition); &#125; mDragPosition = tempPosition; &#125; &#125; /** * 停止拖拽我们将之前隐藏的item显示出来，并将镜像移除 */ private void onStopDrag() &#123; getChildAt(mDragPosition - getFirstVisiblePosition()).setVisibility(View.VISIBLE); removeDragImage(); &#125; /** * 获取状态栏的高度 * * @param context * @return */ private static int getStatusHeight(Context context) &#123; int statusHeight = 0; Rect localRect = new Rect(); ((Activity) context).getWindow().getDecorView().getWindowVisibleDisplayFrame(localRect); statusHeight = localRect.top; if (0 == statusHeight) &#123; Class localClass; try &#123; localClass = Class.forName(com.android.internal.R$dimen); Object localObject = localClass.newInstance(); int i5 = Integer.parseInt(localClass.getField(status_bar_height).get(localObject).toString()); statusHeight = context.getResources().getDimensionPixelSize(i5); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return statusHeight; &#125; /** * @author */ public interface OnChanageListener &#123; /** * 当item交换位置的时候回调的方法，我们只需要在该方法中实现数据的交换即可 * * @param form 开始的position * @param to 拖拽到的position */ public void onChange(int form, int to); &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android自定义可拖拽ListView","date":"2017-02-17T16:00:00.000Z","path":"2017/02/18/Android/CustemView/2017-02-18-Android自定义可拖拽ListView/","text":"如下图所示，下面开始自定义一个可拖拽的ListView 下面先罗列出此自定义view中所用到的主要方法，在这些基础上我们进行如题所说的控件，会变得简单起来 映射一个点到列表的位置。就是说：参数是手指按在屏幕的坐标，返回值是这个坐标所存在的item的position值。 123456789/** * Maps a point to a position in the list. * * @param x X in local coordinate * @param y Y in local coordinate * @return The position of the item which contains the specified point, or * &#123;@link #INVALID_POSITION&#125; if the point does not intersect an item. */ public int pointToPosition(int x, int y) 此方法是根据获得的position值来获取对应position的item的View对象。 12345678/** * Returns the view at the specified position in the group. * * @param index the position at which to get the view from * @return the view at the specified position or null if the position * does not exist within the group */ public View getChildAt(int index) 使用以上方法需要注意，在我们日常的ListView开发中，经常需要对View对象进行复用优化。那么着就引起了接下来的问题，对象被复用后，在传入position这个位置值时，那么我们获取的对象就有可能是之前复用的。换句话说，我们的ListView优化后，屏幕上显示多少个item，也就有多少个View对象，如果有10个View对象的话，当我点击第18个item的时候，通过此方法，返回的对象实际上就是第八个item的实例，那么如何解决这个问题，Google提供了下面这个方法: 1234567/** * Returns the position within the adapter's data set for the first item * displayed on screen. * * @return The position within the adapter's data set */ public int getFirstVisiblePosition() 这里返回的值，是当前屏幕上显示的所有item中得第一个item的position值。所以我们的用法如下，这样我们得到的对象就是当前点击的item正在使用的View对象（如果复用，就是复用后的）。 1getChildAt(position - getFirstVisiblePosition()) 当我们拖动item的时候，为了知道此时是正在拖动的状态和拖动的item是哪个，就需要让这个item的整体布局跟着手指来移动。那么我们获取到item的布局，然后让他跟着手指移动？很抱歉，布局已经绘制了，状态是locked。重新new一个布局来跟着手指拖动？先不说这样很麻烦，对于应用中得各种各样的item布局，难道还要绘制各种各样的View来对应？google同样提供了如下方法： 12345678910111213141516171819202122232425262728/** * &lt;p&gt;Enables or disables the drawing cache. When the drawing cache is enabled, the next call * to &#123;@link #getDrawingCache()&#125; or &#123;@link #buildDrawingCache()&#125; will draw the view in a * bitmap. Calling &#123;@link #draw(android.graphics.Canvas)&#125; will not draw from the cache when * the cache is enabled. To benefit from the cache, you must request the drawing cache by * calling &#123;@link #getDrawingCache()&#125; and draw it on screen if the returned bitmap is not * null.&lt;/p&gt; * * &lt;p&gt;Enabling the drawing cache is similar to * &#123;@link #setLayerType(int, android.graphics.Paint) setting a layer&#125; when hardware * acceleration is turned off. When hardware acceleration is turned on, enabling the * drawing cache has no effect on rendering because the system uses a different mechanism * for acceleration which ignores the flag. If you want to use a Bitmap for the view, even * when hardware acceleration is enabled, see &#123;@link #setLayerType(int, android.graphics.Paint)&#125; * for information on how to enable software and hardware layers.&lt;/p&gt; * * &lt;p&gt;This API can be used to manually generate * a bitmap copy of this view, by setting the flag to &lt;code&gt;true&lt;/code&gt; and calling * &#123;@link #getDrawingCache()&#125;.&lt;/p&gt; * * @param enabled true to enable the drawing cache, false otherwise * * @see #isDrawingCacheEnabled() * @see #getDrawingCache() * @see #buildDrawingCache() * @see #setLayerType(int, android.graphics.Paint) */ public void setDrawingCacheEnabled(boolean enabled) 将View的绘制进行缓存成Bitmap，那这回简单了，拖动哪个item，将它变成皂片就可以了。 12345678/** * &lt;p&gt;Calling this method is equivalent to calling &lt;code&gt;getDrawingCache(false)&lt;/code&gt;.&lt;/p&gt; * * @return A non-scaled bitmap representing this view or null if cache is disabled. * * @see #getDrawingCache(boolean) */ public Bitmap getDrawingCache() 了解了以上所有方法，那么我们可以开始我们的正式开发了，首先我们理清思路：在按下一定时间后，显示出对应item的皂片，咱后根据手指拖动，实时跟新皂片的位置，并进行item的更新，以达到替换效果。然后在停止拖动的时候释放资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440package com.example.view; import android.R.integer; import android.app.Activity; import android.content.Context; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.PixelFormat; import android.graphics.Rect; import android.os.Handler; import android.os.Vibrator; import android.util.AttributeSet; import android.util.Log; import android.view.Gravity; import android.view.MotionEvent; import android.view.View; import android.view.WindowManager; import android.widget.AdapterView; import android.widget.ImageView; import android.widget.ListAdapter; import android.widget.ListView; public class CanDragListView extends ListView &#123; private ListAdapter mAdapter; private WindowManager mWindowManager; /** * item镜像的布局参数 */ private WindowManager.LayoutParams mWindowLayoutParams; private WindowManager.LayoutParams mNewWindowLayoutParams; /** * 振动器 */ private Vibrator mVibrator; /** * 选中的item的position */ private int mSelectedPosition; /** * 选中的item的View对象 */ private View mItemView; /** * 用于拖拽的镜像，这里直接用一个ImageView装载Bitmap */ private ImageView mDragIV; private ImageView mNewDragIv; /** * 选中的item的镜像Bitmap */ private Bitmap mBitmap; /** * 按下的点到所在item的上边缘的距离 */ private int mPoint2ItemTop; /** * 按下的点到所在item的左边缘的距离 */ private int mPoint2ItemLeft; /** * CanDragListView距离屏幕顶部的偏移量 */ private int mOffset2Top; /** * CanDragListView自动向下滚动的边界值 */ private int mDownScrollBorder; /** * CanDragListView自动向上滚动的边界值 */ private int mUpScrollBorder; /** * CanDragListView自动滚动的速度 */ private static final int speed = 20; /** * CanDragListView距离屏幕左边的偏移量 */ private int mOffset2Left; /** * 状态栏的高度 */ private int mStatusHeight; /** * 按下的系统时间 */ private long mActionDownTime = 0; /** * 移动的系统时间 */ private long mActionMoveTime = 0; /** * 默认长按事件时间是1000毫秒 */ private long mLongClickTime = 1000; /** * 是否可拖拽，默认为false */ private boolean isDrag = false; /** * 按下是的x坐标 */ private int mDownX; /** * 按下是的y坐标 */ private int mDownY; /** * item发生变化回调的接口 */ private OnChanageListener onChanageListener; /** * 设置回调接口 * * @param onChanageListener */ public void setOnChangeListener(OnChanageListener onChanageListener) &#123; this.onChanageListener = onChanageListener; &#125; public CanDragListView(Context context) &#123; this(context, null); &#125; public CanDragListView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CanDragListView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mAdapter = getAdapter(); mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE); mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); mStatusHeight = getStatusHeight(context); // 获取状态栏的高度 &#125; private Handler mHandler = new Handler(); // 用来处理长按的Runnable private Runnable mLongClickRunnable = new Runnable() &#123; @Override public void run() &#123; isDrag = true; // 设置可以拖拽 mVibrator.vibrate(100); // 震动100毫秒 if (mItemView != null) &#123; mItemView.setVisibility(View.INVISIBLE);// 隐藏该item &#125; Log.i(\"CanDragListView\", \"**mLongClickRunnable**\"); // 根据我们按下的点显示item镜像 createDragImage(mBitmap, mDownX, mDownY); &#125; &#125;; /** * 当mDownY的值大于向上滚动的边界值，触发自动向上滚动 当mDownY的值小于向下滚动的边界值，触犯自动向下滚动 否则不进行滚动 */ private Runnable mScrollRunnable = new Runnable() &#123; @Override public void run() &#123; int scrollY; if (mDownY &gt; mUpScrollBorder) &#123; scrollY = speed; mHandler.postDelayed(mScrollRunnable, 25); &#125; else if (mDownY &lt; mDownScrollBorder) &#123; scrollY = -speed; mHandler.postDelayed(mScrollRunnable, 25); &#125; else &#123; scrollY = 0; mHandler.removeCallbacks(mScrollRunnable); &#125; // 所以我们在这里调用下onSwapItem()方法来交换item onSwapItem(mDownY, mDownY); smoothScrollBy(scrollY, 10); &#125; &#125;; @Override public boolean onTouchEvent(MotionEvent event) &#123; // Log.i(\"CanDragListView\", mSelectedPosition+\"****\"+mItemView); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mActionDownTime = event.getDownTime(); mDownX = (int) event.getX(); mDownY = (int) event.getY(); // 根据按下的坐标获取item对应的position mSelectedPosition = pointToPosition(mDownX, mDownY); // 如果是无效的position，即值为-1 if (mSelectedPosition == AdapterView.INVALID_POSITION) &#123; return super.onTouchEvent(event); &#125; // 根据position获取对应的item mItemView = getChildAt(mSelectedPosition - getFirstVisiblePosition()); // 使用Handler延迟mLongClickTime执行mLongClickRunnable mHandler.postDelayed(mLongClickRunnable, mLongClickTime); if (mItemView != null) &#123; // 下面这几个距离大家可以参考我的博客上面的图来理解下 mPoint2ItemTop = mDownY - mItemView.getTop(); mPoint2ItemLeft = mDownX - mItemView.getLeft(); mOffset2Top = (int) (event.getRawY() - mDownY); mOffset2Left = (int) (event.getRawX() - mDownX); // 获取CanDragListView自动向上滚动的偏移量，小于这个值，CanDragListView向下滚动 mDownScrollBorder = getHeight() / 4; // 获取CanDragListView自动向下滚动的偏移量，大于这个值，CanDragListView向上滚动 mUpScrollBorder = getHeight() * 3 / 4; // 将该item进行绘图缓存 mItemView.setDrawingCacheEnabled(true); // 从缓存中获取bitmap mBitmap = Bitmap.createBitmap(mItemView.getDrawingCache()); // 释放绘图缓存，避免出现重复的缓存对象 mItemView.destroyDrawingCache(); &#125; // Log.i(\"CanDragListView\", \"****\"+isDrag); break; case MotionEvent.ACTION_MOVE: // TODO if (isDrag) &#123; int moveX = (int) event.getX(); int moveY = (int) event.getY(); if (!isOnTouchInItem(mItemView, moveX, moveY)) &#123; mHandler.removeCallbacks(mLongClickRunnable); &#125; mDownX = moveX; mDownY = moveY; onDragItem(moveX, moveY); &#125; break; case MotionEvent.ACTION_UP: onStopDrag(); mHandler.removeCallbacks(mLongClickRunnable); mHandler.removeCallbacks(mScrollRunnable); isDrag = false; break; default: break; &#125; return super.onTouchEvent(event); &#125; /** * 判断手指按下的坐标是否在item范围内 * * @param view * @param downX * @param downY * @return */ private boolean isOnTouchInItem(View view, int downX, int downY) &#123; if (view == null) &#123; return false; &#125; int leftX = view.getLeft(); int topY = view.getTop(); if (downX &lt; leftX || downX &gt; leftX + view.getWidth()) &#123; return false; &#125; if (downY &lt; topY || downY &gt; topY + view.getHeight()) &#123; return false; &#125; return true; &#125; /** * 创建拖动的镜像 * * @param bitmap * @param downX * 按下的点相对父控件的X坐标 * @param downY * 按下的点相对父控件的X坐标 */ private void createDragImage(Bitmap bitmap, int downX, int downY) &#123; mWindowLayoutParams = new WindowManager.LayoutParams(); mWindowLayoutParams.format = PixelFormat.TRANSLUCENT; // 图片之外的其他地方透明 mWindowLayoutParams.gravity = Gravity.TOP | Gravity.LEFT; mWindowLayoutParams.x = downX - mPoint2ItemLeft + mOffset2Left; mWindowLayoutParams.y = downY - mPoint2ItemTop + mOffset2Top - mStatusHeight; mWindowLayoutParams.alpha = 0.55f; // 透明度 mWindowLayoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT; mWindowLayoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT; mWindowLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; mNewWindowLayoutParams = new WindowManager.LayoutParams(); mNewWindowLayoutParams.format = PixelFormat.TRANSLUCENT; // 图片之外的其他地方透明 mNewWindowLayoutParams.gravity = Gravity.TOP | Gravity.LEFT; mNewWindowLayoutParams.x = downX - mPoint2ItemLeft + mOffset2Left; mNewWindowLayoutParams.y = downY - mPoint2ItemTop + mOffset2Top - mStatusHeight; // mNewWindowLayoutParams.alpha = 0.55f; // 透明度 mNewWindowLayoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT; mNewWindowLayoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT; mNewWindowLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; mDragIV = new ImageView(getContext()); mNewDragIv = new ImageView(getContext()); mDragIV.setImageBitmap(bitmap); mWindowManager.addView(mDragIV, mWindowLayoutParams); mWindowManager.addView(mNewDragIv, mNewWindowLayoutParams); &#125; /** * 移除镜像 */ private void removeDragImage() &#123; if (mDragIV != null) &#123; mWindowManager.removeView(mDragIV); mDragIV = null; &#125; if (mNewDragIv != null) &#123; mWindowManager.removeView(mNewDragIv); mNewDragIv = null; &#125; &#125; /** * 拖动item，在里面实现了item镜像的位置更新，item的相互交换以及ListView的自行滚动 * * @param x * @param y */ private void onDragItem(int moveX, int moveY) &#123; if (mWindowLayoutParams != null &amp;&amp; mDragIV != null) &#123; mWindowLayoutParams.x = moveX - mPoint2ItemLeft + mOffset2Left; mWindowLayoutParams.y = moveY - mPoint2ItemTop + mOffset2Top - mStatusHeight; mWindowManager.updateViewLayout(mDragIV, mWindowLayoutParams); // 更新镜像的位置 &#125; onSwapItem(moveX, moveY); // ListView自动滚动 mHandler.post(mScrollRunnable); &#125; /** * 交换item,并且控制item之间的显示与隐藏效果 * * @param moveX * @param moveY */ private void onSwapItem(int moveX, int moveY) &#123; // 获取我们手指移动到的那个item的position int position = pointToPosition(moveX, moveY); // 假如tempPosition 改变了并且tempPosition不等于-1,则进行交换 if (position != mSelectedPosition &amp;&amp; position != AdapterView.INVALID_POSITION) &#123; // mAdapter.getItem(mSelectedPosition); View newItem = getChildAt(position - getFirstVisiblePosition()); View oldItem = getChildAt(mSelectedPosition - getFirstVisiblePosition()); mNewWindowLayoutParams.x = moveX - (moveX - oldItem.getLeft()) + mOffset2Left; mNewWindowLayoutParams.y = moveY - (moveY - oldItem.getTop()) + mOffset2Top - mStatusHeight; newItem.setDrawingCacheEnabled(true); Bitmap bitmap = Bitmap.createBitmap(newItem.getDrawingCache()); newItem.destroyDrawingCache(); mNewDragIv.setImageBitmap(bitmap); if (newItem != null &amp;&amp; oldItem != null) &#123; newItem.setVisibility(INVISIBLE);// 隐藏拖动到的位置的item oldItem.setVisibility(VISIBLE);//显示之前的 mWindowManager.updateViewLayout(mNewDragIv, mNewWindowLayoutParams); // 更新镜像的位置 if (onChanageListener != null) &#123; Log.i(\"CanDragListView\", \"**onSwapItem**\"); onChanageListener.onChange(mSelectedPosition, position); &#125; &#125; mSelectedPosition = position; &#125; &#125; /** * 停止拖拽我们将之前隐藏的item显示出来，并将镜像移除 */ private void onStopDrag() &#123; View view = getChildAt(mSelectedPosition - getFirstVisiblePosition()); if (view != null) &#123; view.setVisibility(View.VISIBLE); &#125; // ((DragAdapter)this.getAdapter()).setItemHide(-1); removeDragImage(); &#125; /** * 获取状态栏的高度 * * @param context * @return */ private static int getStatusHeight(Context context) &#123; int statusHeight = 0; Rect localRect = new Rect(); ((Activity) context).getWindow().getDecorView().getWindowVisibleDisplayFrame(localRect); statusHeight = localRect.top; if (0 == statusHeight) &#123; Class&lt;?&gt; localClass; try &#123; localClass = Class.forName(\"com.android.internal.R$dimen\"); Object localObject = localClass.newInstance(); int i5 = Integer.parseInt(localClass.getField(\"status_bar_height\").get(localObject).toString()); statusHeight = context.getResources().getDimensionPixelSize(i5); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return statusHeight; &#125; /** * 监听数据拖拽的接口，用来更新数据显示 */ public interface OnChanageListener &#123; /** * 当item交换位置的时候回调的方法，在此处实现数据的交换 * * @param start * 开始的position * @param to * 拖拽到的position */ public void onChange(int start, int to); &#125; &#125; 在代码里定义了改变的回调接口，目的是对item进行交换并且更新。开始我是想将item的更新都固定在自定义的ListView中，这样拿来就能直接用。 对于item的更新，一定要在Activity中实现OnChanageListener后，在方法里对数据集合进行元素位置交换。这里用的方法是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * Swaps the elements of list &#123;@code list&#125; at indices &#123;@code index1&#125; and * &#123;@code index2&#125;. * * @param list * the list to manipulate. * @param index1 * position of the first element to swap with the element in * index2. * @param index2 * position of the other element. * * @throws IndexOutOfBoundsException * if index1 or index2 is out of range of this list. * @since 1.4 */ @SuppressWarnings(\"unchecked\") public static void swap(List&lt;?&gt; list, int index1, int index2) 参数是要交换数据的集合，和要交换的两个元素的位置。用法是： mListView.setOnChangeListener(new OnChanageListener() &#123; @Override public void onChange(int start, int to) &#123; //数据交换 if(start &lt; to)&#123; for(int i=start; i&lt;to; i++)&#123; Collections.swap(mList, i, i+1); &#125; &#125;else if(start &gt; to)&#123; for(int i=start; i&gt;to; i--)&#123; Collections.swap(mList, i, i-1); &#125; &#125; mAdapter.notifyDataSetChanged(); &#125; &#125;); ``` 到此，可拖拽的ListView完成。xml布局文件示例如下：```xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;include android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" layout=\"@layout/include_title\" /&gt; &lt;com.qiyuan.activity.view.CanDragListView android:id=\"@+id/main_activity_lv\" android:dividerHeight=\"0.2dp\" android:divider=\"@color/blueviolet\" android:footerDividersEnabled=\"false\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" /&gt; &lt;/LinearLayout&gt;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"解决Android65535问题","date":"2017-02-16T16:00:00.000Z","path":"2017/02/17/Android/exeption/2017-02-17-解决Android65535问题/","text":"在 Android 开发中，有一个之前很少听说，最近偶尔江湖传闻听到过的问题，就是 65k 问题。什么是65k问题呢？其实很简单，就是 Android 有个限制，你的每个 App 中函数最多只能有 65536 个。 这个限制其实是这样的，因为在编译成 Dalvik 字节码，也就是把你的 Class 们生成打包到一个 classes.dex 中去的时候呢，编译器会给你的 App 中所有的函数方法指定一个 ID， 然后每一个 classes.dex 中 ID 的范围是 [0, 0xffff] 。 所以，你懂的，就有了那么一个 65k 的问题。 当然大部分应用程序里路上是不会遇到这个问题的，毕竟 65k 个函数也很多了，但是考虑到现在各种引入 SDK，而且尤其是大公司的程序往往会有很多匪夷所思的功能，最后代码越来越臃肿，指不定哪天就遇到了。不过还好，这个问题也不难解决，G社官方已经给出了解决方案: multidex support library 简单翻译下，原理就是编译的时候不再是单纯编译到一个 Dex 文件中去，而是切分成多个 Dex 文件。这样每个文件都允许 65536 个函数，肯定是够用了的。下面说下具体的操作。 首先就是导入这个库，这个 Eclipse 和 Android Studio 不太一样，但是具体就不说了，因为太常见了。不过如果用的是新版本的 Android Studio 似乎已经无需导入这个库，貌似 IDE 直接支持了。只需要把配置文件中的 multiDexEnabled 设置成 true 就可以了，大概就是下面这个样子： 1234567android &#123; ... shitAppConfig &#123; ... multiDexEnabled true &#125;&#125; 然后就是让你的 Application 类继承自 MultiDexApplication 这个类 ，例如: 123public class ShitApplication extends MultiDexApplication &#123; ...&#125; 假如不方便修改继承（比如已经继承了其他的封装了的 Application）那么久稍微复杂一点，重载一下attachBaseContext，代码如下： 12345@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(context); Multidex.install(this);&#125; 还有一种情况就是没有继承过 Application 类怎么办？这种最方便，打开你的 AndroidMainfest 文件，在 application tag 中加入这个： 1android:name=\"android.support.multidex.MultiDexApplication\" 到此，问题算是解决了。但是这并不完美，在 Android 5.0之前，你还需要保证你的 Activity , Service等等基本上 Dalvik需要直接找你的东西都放在第一个 dex 中，否则你的 App 就会挂掉。这部分内容说起来比较复杂，我建议直接去看 Google 官方的说明，Building Apps with Over 65K Methods 。 当然，如果你的程序只支持 Android 5.0 以后的机器，那就不用担心了，因为 ART 会把多个 dex 合并成一个 oat 文件，就不存在找不到的问题了。 当然，真遇到这个问题的时候，还是建议看看架构上面有没有可以改良的地方。实在不行把一个 App 拆两个也行啊，别总想搞个大新闻，你说是吧。","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android人脸检测汇总Camera-FaceDetectionListener","date":"2017-02-14T16:00:00.000Z","path":"2017/02/15/Android/App/2017-02-15-Android人脸检测汇总Camera-FaceDetectionListener/","text":"基于android.hardware.Camera.FaceDetectionListener的相机人脸检测相信大家可能遇到过相机中人脸检测的案例，那么在自定义的相机中如何使用人脸检测呢？ 简略代码如下： 12345678910111213141516171819202122232425262728293031323334import android.hardware.Camera;import android.hardware.Camera.Face;import android.hardware.Camera.FaceDetectionListener;Camera mCamera;FaceDetectionListener detectionListener = new FaceDetectionListener()&#123; @Override public void onFaceDetection(Face[] faces, Camera camera) &#123; // TODO Auto-generated method stub Log.i(TAG, \"onFaceDetection...\"); if(faces != null)&#123; Message m = mHander.obtainMessage(); m.what = EventUtil.UPDATE_FACE_RECT; m.obj = faces; m.sendToTarget(); &#125; &#125;&#125;; ...........public void openCamera()&#123; mCamera = Camera.open(cameraId); ........... mCamera.setFaceDetectionListener(detectionListener); //设置检测监听 mCamera.startFaceDetection(); //开启检测 ...........&#125;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android自定义View扫描界面","date":"2017-02-14T16:00:00.000Z","path":"2017/02/15/Android/CustemView/2017-02-16-Android自定义View扫描界面/","text":"项目需要做一个动态扫描界面，以此为记 下面是效果图 下面胃自定义代码，可放入xml布局文件中直接使用，可根据需求灵活画图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public final class ScanView extends View &#123; /** * 刷新界面的时间 */ private static final long ANIMATION_DELAY = 15L; private static final int OPAQUE = 0xFF; /** * 中间那条线每次刷新移动的距离 */ private static final int SPEEN_DISTANCE = 5; /** * 手机的屏幕密度 */ private static float density; /** * 画笔对象的引用 */ private Paint paint; /** * 中间滑动线的最顶端位置 */ private int slideTop = 0; /** * 将扫描的二维码拍下来，这里没有这个功能，暂时不考虑 */ private Bitmap resultBitmap; private final int maskColor; private int mWidth; private int mHeight; boolean isFirst; private Rect frame; public ScanView(Context context, AttributeSet attrs) &#123; super(context, attrs); density = context.getResources().getDisplayMetrics().density; paint = new Paint(); Resources resources = getResources(); maskColor = resources.getColor(R.color.viewfinder_mask); &#125; @Override public void onDraw(Canvas canvas) &#123; //获取屏幕的宽和高 mWidth = canvas.getWidth(); mHeight = canvas.getHeight(); int centerX = mWidth / 2; int centerY = mHeight / 2; frame = new Rect(centerX - centerX / 5 * 4, centerY - 150, centerX + centerX / 5 * 4, centerY + 150); paint.setColor(maskColor); //画出扫描框外面的阴影部分，共四个部分，扫描框的上面到屏幕上面，扫描框的下面到屏幕下面 //扫描框的左边面到屏幕左边，扫描框的右边到屏幕右边 canvas.drawRect(0, 0, mWidth, frame.top, paint); canvas.drawRect(0, frame.top, frame.left, frame.bottom + 1, paint); canvas.drawRect(frame.right + 1, frame.top, mWidth, frame.bottom + 1, paint); canvas.drawRect(0, frame.bottom + 1, mWidth, mHeight, paint); paint.setColor(getResources().getColor(R.color.smoke_oranger)); paint.setStrokeWidth(4); canvas.drawLine(frame.left, frame.top - 2, frame.left, frame.bottom, paint); canvas.drawLine(frame.left, frame.top, frame.right + 2, frame.top, paint); canvas.drawLine(frame.right, frame.top, frame.right, frame.bottom + 2, paint); canvas.drawLine(frame.left - 2, frame.bottom, frame.right, frame.bottom, paint); Rect rect1 = new Rect(frame.left, frame.top-250, frame.right, frame.bottom-250); Rect rect2 = new Rect(frame.left, frame.top-250+60, frame.right, frame.bottom-250+60); Paint textPaint = new Paint(); textPaint.setColor(Color.WHITE); textPaint.setTextSize(50); textPaint.setStyle(Paint.Style.FILL); //该方法即为设置基线上那个点究竟是left,center,还是right 这里我设置为center textPaint.setTextAlign(Paint.Align.CENTER); Paint.FontMetrics fontMetrics = textPaint.getFontMetrics(); float top = fontMetrics.top;//为基线到字体上边框的距离,即上图中的top float bottom = fontMetrics.bottom;//为基线到字体下边框的距离,即上图中的bottom int baseLineY1 = (int) (rect1.centerY() - top/2 - bottom/2);//基线中间点的y轴计算公式 int baseLineY2 = (int) (rect2.centerY() - top/2 - bottom/2);//基线中间点的y轴计算公式 canvas.drawText(\"请将打码放到识别区域内\",rect1.centerX(),baseLineY1,textPaint); canvas.drawText(\"拍摄一张清晰的照片\",rect1.centerX(),baseLineY2,textPaint); //绘制中间的线,每次刷新界面，中间的线往下移动SPEEN_DISTANCE if (slideTop == 0)&#123; slideTop = frame.top; &#125; slideTop += SPEEN_DISTANCE; if(slideTop &gt;= frame.bottom)&#123; slideTop = frame.top; &#125; Rect lineRect = new Rect(); lineRect.left = frame.left; lineRect.right = frame.right; lineRect.top = slideTop; lineRect.bottom = slideTop + 18; canvas.drawBitmap(((BitmapDrawable)(getResources().getDrawable(R.drawable.qrcode_scan_line))).getBitmap(), null, lineRect, paint); //只刷新扫描框的内容，其他地方不刷新 postInvalidateDelayed(ANIMATION_DELAY, frame.left, frame.top, frame.right, frame.bottom); &#125; public Rect getFrame() &#123; return frame; &#125; public int getmHeight() &#123; return mHeight; &#125; public int getmWidth() &#123; return mWidth; &#125;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android人脸检测汇总Media-FaceDetection","date":"2017-02-14T16:00:00.000Z","path":"2017/02/15/Android/App/2017-02-15-Android人脸检测汇总-Media-FaceDetector/","text":"基于android.media.FaceDetector的静态人脸检测使用android.media.FaceDetector可以对图片中的人脸进行检测，此API的不足之处由一下使用代码可见，只能识别人脸眼睛中点Point和眼睛之间的距离，再无其他识别，请大家根据实际需求选择和使用，曾经在相机中抓取数据流，转换成bitmap试过，由于内存有限发现卡顿现象严重 import android.media.FaceDetector; //人脸识别的关键类 import android.media.FaceDetector.Face; int numberOfFace = 5; BitmapFactory.Options option = new BitmapFactory.Options(); option.inPreferredConfig = Bitmap.Config.RGB_565; //构造位图生成的参数，必须为565。类名+enum Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ddd, BitmapFactoryOptionsbfo); FaceDetector.Face[] faces = new FaceDetector.Face[numberOfFace]; //分配人脸数组空间 FaceDetector detector= new FaceDetector(bitmap.getWidth(), bitmap.getHeight(), numberOfFace); int numberOfFaceDetected = detector.findFaces(myBitmap, myFace); //FaceDetector 构造实例并解析人脸,返回实际检测人脸个数 for(int i=0; i &lt; numberOfFaceDetected; i++){ Face face = faces[i]; PointF point = new PointF(); face.getMidPoint(point); //获取眼睛中点 int eyesDistance = face.eyesDistance(); //得到人脸中心点和眼间距离参数，并对每个人脸进行画框 canvas.drawRect( //矩形框的位置参数 (int)(myMidPoint.x - myEyesDistance), (int)(myMidPoint.y - myEyesDistance), (int)(myMidPoint.x + myEyesDistance), (int)(myMidPoint.y + myEyesDistance), myPaint); }","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android人脸检测汇总PlaySvervice","date":"2017-02-14T16:00:00.000Z","path":"2017/02/15/Android/App/2017-02-15-Android人脸检测汇总PlaySvervice/","text":"Play Svervice视觉库的一个主要组件，Face Detection人脸检这一功能经常用到，我们可以使用android系统提供的API进行人脸检测，也可以使用OpenCv等三方库进行人脸检测 Google Play服务8.1中引入了视觉库，作为一个开发者，Face Detection让你可以更容易的通过分析视频或图像来定位人脸(face)。 如果想了解更多请查看 官方文档 使用方法： build.gradle文件中添加依赖库,8.1以上版本可以根据自己需求添加 123456dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') ... ... compile 'com.google.android.gms:play-services:9.8.0'&#125; AndroidManifest.xml的Application 中添加如下代码 1&lt;meta-data android:name=\"com.google.android.gms.vision.DEPENDENCIES\" android:value=\"face\"/&gt; 接下来我们获取位图对象，这是实例具体可以根据自己的方式获取Bitmap对象 12InputStream stream = getResources().openRawResource( R.raw.face );Bitmap bitmap = BitmapFactory.decodeStream(stream); 下面正式进入人脸检测阶段： 123456789101112131415161718192021222324252627282930313233import com.google.android.gms.vision.face.Face;//导入人脸对象import com.google.android.gms.vision.face.FaceDetector;//导入人脸检测器... ... .../** 创建人脸检测器 */FaceDetector detector = new FaceDetector.Builder( getContext() ) .setTrackingEnabled(false) .setLandmarkType(FaceDetector.ALL_LANDMARKS) .setMode(FaceDetector.FAST_MODE) .build();... ... .../** 进行人脸检测 */if (!detector.isOperational()) &#123;//判断人脸检测器是否可用 //Handle contingency&#125; else &#123; Frame frame = new Frame.Builder().setBitmap(bitmap).build();//需要将Bitmap文件转换成Frame对象 Face[] mFaces = detector.detect(frame); detector.release();//使用后及时释放资源 for( int i = 0; i &lt; mFaces.size(); i++ ) &#123; Face face = mFaces.valueAt(i); //绘制人脸框， scale为图片实际大小与显示大小的比例 left = (float) ( face.getPosition().x * scale ); top = (float) ( face.getPosition().y * scale ); right = (float) scale * ( face.getPosition().x + face.getWidth() ); bottom = (float) scale * ( face.getPosition().y + face.getHeight() ); canvas.drawRect( left, top, right, bottom, paint ); &#125;&#125; 通过上面代码我们获取到了人脸信息，并将之绘制到图片上去，别急还有其他功能，通过人脸对象我们还可以获取到人脸关键点的信息， 共十二个关键点信息：左右眼 左右耳 左右耳廓尖 鼻子基部 左右脸颊 嘴的左右角 嘴基部 注：关键点信息的多少取决于人脸角度 主要代码如下： 12345678910111213141516171819202122232425262728//通过Face对象获取人脸关键点集合List&lt;Landmark&gt; landmark = face.getLandmarks()... ... ...//通过循环画出所有人脸关键点信息for ( Landmark landmark : face.getLandmarks() ) &#123; int cx = (int) ( landmark.getPosition().x * scale ); int cy = (int) ( landmark.getPosition().y * scale ); canvas.drawCircle( cx, cy, 10, paint );&#125;//Landmark对象public static final int BOTTOM_MOUTH = 0;public static final int LEFT_CHEEK = 1;public static final int LEFT_EAR_TIP = 2;public static final int LEFT_EAR = 3;public static final int LEFT_EYE = 4;public static final int LEFT_MOUTH = 5;public static final int NOSE_BASE = 6;public static final int RIGHT_CHEEK = 7;public static final int RIGHT_EAR_TIP = 8;public static final int RIGHT_EAR = 9;public static final int RIGHT_EYE = 10;public static final int RIGHT_MOUTH = 11;private final PointF aOa;private final int nV; 上面我们知悉了人脸检测，人脸关键点的获取，接下来我们学习额外人脸数据的获取，通过这些数据我们可以判断人练动作，是不是很有意思！！！ getIsSmilingProbability(),getIsLeftEyeOpenProbability()和getIsRightEyeOpenProbability()方法会返回一个0.0到1.0的浮点数，你可以用其确定眼睛是否睁开或者检测到的这个人是否在笑。返回值越接近1.0，这个人就越有可能在小或者他的左右眼越有可能是睁开的。 你也可以通过检查图像的欧拉值找出一张图像中人脸在Y轴和Z轴上的角度。Z欧拉值的一直都能收到。但是，要想接受到X值你必须使用精确模式。在下面的代码片段中你会看到如何获取这些值。 12345678for( int i = 0; i &lt; mFaces.size(); i++ ) &#123; Face face = mFaces.valueAt(i); float smilingProbability = face.getIsSmilingProbability();//微笑 float leftEyeOpenProbability = face.getIsLeftEyeOpenProbability();//左眼状态 float rightEyeOpenProbability = face.getIsRightEyeOpenProbability();//右眼状态 float eulerY = face.getEulerY(); float eulerZ = face.getEulerZ();&#125; 欧拉Y角度参考 123456欧拉 Y 角度 可见的关键点&lt; -36° 左眼，嘴的左半边，左耳，鼻子基部，左脸颊-36° to -12° 嘴的左半边，鼻子基部，嘴的底部，右眼，左眼，左脸颊，左耳尖-12° to 12° 右眼，左眼，鼻子基部，左脸颊，右脸颊，嘴的左半边，嘴的右半边，嘴的底部12° to 36° 嘴的右半边，鼻子基部，嘴的底部，左眼，右眼，右脸颊，右耳尖&gt; 36° 右眼，嘴的右半边，右耳，鼻子基部，右脸颊","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android自定义相机简介","date":"2017-01-24T16:00:00.000Z","path":"2017/01/25/Android/CustemView/2017-01-25-Android自定义相机简介/","text":"使用最简单直接的方式，自定义Android相机，并有拍照，对焦功能，可以以此为基础对相机进一步开发。 下面直接上代码： 主文件 CameraActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230public class CameraActivity extends Activity &#123; private Camera camera; private Camera.Parameters parameters = null; Bundle bundle = null; // 声明一个Bundle对象，用来存储数据 private String mUserId; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 显示界面 setContentView(R.layout.activity_camera); mUserId = getIntent().getStringExtra(\"userId\"); SurfaceView surfaceView = (SurfaceView) findViewById(R.id.camera_surfaceView); surfaceView.getHolder() .setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); surfaceView.getHolder().setFixedSize(176, 144); //设置Surface分辨率 surfaceView.getHolder().setKeepScreenOn(true);// 屏幕常亮 surfaceView.getHolder().addCallback(new SurfaceCallback());//为SurfaceView的句柄添加一个回调函数 &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK) &#123; int result = data.getIntExtra(\"result\", 0); if (result == 0) &#123;//确定 setResult(RESULT_OK, data); finish(); &#125; &#125; &#125; /** * 按钮被点击触发的事件 * * @param v */ public void btnOnclick(View v) &#123; if (camera != null) &#123; switch (v.getId()) &#123; case R.id.camera_takepicture: // 拍照 camera.takePicture(null, null, new MyPictureCallback()); break; &#125; &#125; &#125; /** 拍照回调 */ private final class MyPictureCallback implements Camera.PictureCallback &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; if (data != null) &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 4; //这里表示原来图片的1/4 Bitmap bitmap2 = BitmapFactory.decodeByteArray(data, 0, data.length, options); try &#123; String image = saveFile(bitmap2);//保存图片 Toast.makeText(getApplicationContext(), \"保存成功\", Toast.LENGTH_SHORT).show(); camera.startPreview(); // 拍完照后，重新开始预览 if (image != null) &#123; Intent intent = new Intent(CameraActivity.this, PictureSureActivity.class); intent.putExtra(\"userId\", mUserId); intent.putExtra(\"image\", image); CameraActivity.this.startActivityForResult(intent, 123); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; bitmap2.recycle(); &#125; &#125;/*********************************直接保存二进制图片数据************************************/// try &#123;// bundle = new Bundle();// bundle.putByteArray(\"bytes\", data); //将图片字节数据保存在bundle当中，实现数据交换// String image = saveToSDCard(data);// 保存图片到sd卡中// Toast.makeText(getApplicationContext(), \"保存成功\",// Toast.LENGTH_SHORT).show();// camera.startPreview(); // 拍完照后，重新开始预览// &#125; catch (Exception e) &#123;// e.printStackTrace();// &#125; &#125; /** * 将拍下来的照片存放在SD卡中 * bitmap格式图片保存 * @param bm * @return * @throws IOException */ public String saveFile(Bitmap bm) throws IOException &#123; Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMddHHmmss\"); // 格式化时间 String filename = format.format(date) + \".jpg\"; File fileFolder = new File(Environment.getExternalStorageDirectory() + \"/com.simple.images/\"); if (!fileFolder.exists()) &#123; // 如果目录不存在，则创建一个名为\"finger\"的目录 fileFolder.mkdir(); &#125; File jpgFile = new File(fileFolder, filename); String imageUrl = jpgFile.getPath(); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(jpgFile)); bm.compress(Bitmap.CompressFormat.JPEG, 100, bos); bos.flush(); bos.close(); return imageUrl; &#125; /** * 将拍下来的照片存放在SD卡中 * * @param data 二进制图片数据 * @throws IOException */ public static String saveToSDCard(byte[] data) throws IOException &#123; Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMddHHmmss\"); // 格式化时间 String filename = format.format(date) + \".jpg\"; File fileFolder = new File(Environment.getExternalStorageDirectory() + \"/com.simple.images/\"); if (!fileFolder.exists()) &#123; // 如果目录不存在，则创建一个名为\"finger\"的目录 fileFolder.mkdir(); &#125; File jpgFile = new File(fileFolder, filename); String imageUrl = jpgFile.getPath(); FileOutputStream outputStream = new FileOutputStream(jpgFile); // 文件输出流 outputStream.write(data); // 写入sd卡中 outputStream.close(); // 关闭输出流 return imageUrl; &#125; private final class SurfaceCallback implements SurfaceHolder.Callback &#123; // 拍照状态变化时调用该方法 @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; parameters = camera.getParameters(); // 获取各项参数 parameters.setPictureFormat(PixelFormat.JPEG); // 设置图片格式 parameters.setPreviewSize(width, height); // 设置预览大小 parameters.setPreviewFrameRate(5); //设置每秒显示4帧 parameters.setPictureSize(width, height); // 设置保存的图片尺寸 parameters.setJpegQuality(100); // 设置照片质量 parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO); &#125; // 开始拍照时调用该方法 @Override public void surfaceCreated(SurfaceHolder holder) &#123; try &#123; camera = Camera.open(); // 打开摄像头 camera.setPreviewDisplay(holder); // 设置用于显示拍照影像的SurfaceHolder对象 camera.setDisplayOrientation(getPreviewDegree(CameraActivity.this)); camera.startPreview(); // 开始预览 camera.setAutoFocusMoveCallback(new Camera.AutoFocusMoveCallback() &#123; @Override public void onAutoFocusMoving(boolean b, Camera camera) &#123; &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 停止拍照时调用该方法 @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; if (camera != null) &#123; camera.release(); // 释放照相机 camera = null; &#125; &#125; &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; switch (keyCode) &#123; case KeyEvent.KEYCODE_CAMERA: // 按下拍照按钮 if (camera != null &amp;&amp; event.getRepeatCount() == 0) &#123; // 拍照 //注：调用takePicture()方法进行拍照是传入了一个PictureCallback对象——当程序获取了拍照所得的图片数据之后 //，PictureCallback对象将会被回调，该对象可以负责对相片进行保存或传入网络 camera.takePicture(null, null, new MyPictureCallback()); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; // 提供一个静态方法，用于根据手机方向获得相机预览画面旋转的角度 public static int getPreviewDegree(Activity activity) &#123; // 获得手机的方向 int rotation = activity.getWindowManager().getDefaultDisplay() .getRotation(); int degree = 0; // 根据手机的方向计算相机预览画面应该选择的角度 switch (rotation) &#123; case Surface.ROTATION_0: degree = 90; break; case Surface.ROTATION_90: degree = 0; break; case Surface.ROTATION_180: degree = 270; break; case Surface.ROTATION_270: degree = 180; break; &#125; return degree; &#125; public void goBack(View v) &#123; finish(); &#125;&#125; 布局文件 activity_camera.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!-- 显示预览图形 --&gt; &lt;SurfaceView android:id=\"@+id/camera_surfaceView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/smoke_oranger\"&gt; &lt;com.irobotcity.smokeverify.widget.TitleBar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_centerVertical=\"true\" app:addEvelation=\"false\"&gt; &lt;/com.irobotcity.smokeverify.widget.TitleBar&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"10dp\" android:text=\"取消\" android:textColor=\"@color/whitesmoke\" android:onClick=\"goBack\" android:textSize=\"16dp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_centerVertical=\"true\" android:layout_gravity=\"center\" android:paddingBottom=\"15dp\" android:paddingTop=\"15dp\" android:text=\"拍照\" android:textColor=\"@color/white\" android:textSize=\"20sp\" /&gt; &lt;/RelativeLayout&gt; &lt;!-- 相对布局，放置两个按钮 --&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"10dp\"&gt; &lt;!-- 拍照按钮 --&gt; &lt;Button android:id=\"@+id/camera_takepicture\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:background=\"@drawable/main_take\" android:onClick=\"btnOnclick\" /&gt; &lt;/RelativeLayout&gt;&lt;/FrameLayout&gt;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android图片手势缩放功能的实现","date":"2017-01-23T16:00:00.000Z","path":"2017/01/24/Android/CustemView/2017-01-23-Android图片手势缩放功能的实现/","text":"android开发中常常需要对图片放大查看，要实现这一功能，在有限大小的手机屏幕上，手势缩放图片必不可少。 下面为大家提供简单的实现ImageView手势缩放功能 方法1： 自定义一个ImageView 使用用法： Activity文件中直接使用： 1234567891011public class MainActivity extends Activity &#123; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ZoomImageView img = (ZoomImageView) findViewById(R.id.snoop); img.setImageResource(R.drawable.snoopy); img.setMaxZoom(4f); &#125;&#125; 下面是自定义代码：ZoomImageView.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224import android.content.Context;import android.graphics.Matrix;import android.graphics.PointF;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.ScaleGestureDetector;import android.view.View;import android.widget.ImageView;public class ZoomImageView extends ImageView &#123; Matrix matrix; // We can be in one of these 3 states static final int NONE = 0; static final int DRAG = 1; static final int ZOOM = 2; int mode = NONE; // Remember some things for zooming PointF last = new PointF(); PointF start = new PointF(); float minScale = 1f; float maxScale = 3f; float[] m; int viewWidth, viewHeight; static final int CLICK = 3; float saveScale = 1f; protected float origWidth, origHeight; int oldMeasuredWidth, oldMeasuredHeight; ScaleGestureDetector mScaleDetector; Context context; public TouchImageView(Context context) &#123; super(context); sharedConstructing(context); &#125; public TouchImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); sharedConstructing(context); &#125; private void sharedConstructing(Context context) &#123; super.setClickable(true); this.context = context; mScaleDetector = new ScaleGestureDetector(context, new ScaleListener()); matrix = new Matrix(); m = new float[9]; setImageMatrix(matrix); setScaleType(ScaleType.MATRIX); setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; mScaleDetector.onTouchEvent(event); PointF curr = new PointF(event.getX(), event.getY()); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: last.set(curr); start.set(last); mode = DRAG; break; case MotionEvent.ACTION_MOVE: if (mode == DRAG) &#123; float deltaX = curr.x - last.x; float deltaY = curr.y - last.y; float fixTransX = getFixDragTrans(deltaX, viewWidth, origWidth * saveScale); float fixTransY = getFixDragTrans(deltaY, viewHeight, origHeight * saveScale); matrix.postTranslate(fixTransX, fixTransY); fixTrans(); last.set(curr.x, curr.y); &#125; break; case MotionEvent.ACTION_UP: mode = NONE; int xDiff = (int) Math.abs(curr.x - start.x); int yDiff = (int) Math.abs(curr.y - start.y); if (xDiff &lt; CLICK &amp;&amp; yDiff &lt; CLICK) performClick(); break; case MotionEvent.ACTION_POINTER_UP: mode = NONE; break; &#125; setImageMatrix(matrix); invalidate(); return true; // indicate event was handled &#125; &#125;); &#125; public void setMaxZoom(float x) &#123; maxScale = x; &#125; private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener &#123; @Override public boolean onScaleBegin(ScaleGestureDetector detector) &#123; mode = ZOOM; return true; &#125; @Override public boolean onScale(ScaleGestureDetector detector) &#123; float mScaleFactor = detector.getScaleFactor(); float origScale = saveScale; saveScale *= mScaleFactor; if (saveScale &gt; maxScale) &#123; saveScale = maxScale; mScaleFactor = maxScale / origScale; &#125; else if (saveScale &lt; minScale) &#123; saveScale = minScale; mScaleFactor = minScale / origScale; &#125; if (origWidth * saveScale &lt;= viewWidth || origHeight * saveScale &lt;= viewHeight) matrix.postScale(mScaleFactor, mScaleFactor, viewWidth / 2, viewHeight / 2); else matrix.postScale(mScaleFactor, mScaleFactor, detector.getFocusX(), detector.getFocusY()); fixTrans(); return true; &#125; &#125; void fixTrans() &#123; matrix.getValues(m); float transX = m[Matrix.MTRANS_X]; float transY = m[Matrix.MTRANS_Y]; float fixTransX = getFixTrans(transX, viewWidth, origWidth * saveScale); float fixTransY = getFixTrans(transY, viewHeight, origHeight * saveScale); if (fixTransX != 0 || fixTransY != 0) matrix.postTranslate(fixTransX, fixTransY); &#125; float getFixTrans(float trans, float viewSize, float contentSize) &#123; float minTrans, maxTrans; if (contentSize &lt;= viewSize) &#123; minTrans = 0; maxTrans = viewSize - contentSize; &#125; else &#123; minTrans = viewSize - contentSize; maxTrans = 0; &#125; if (trans &lt; minTrans) return -trans + minTrans; if (trans &gt; maxTrans) return -trans + maxTrans; return 0; &#125; float getFixDragTrans(float delta, float viewSize, float contentSize) &#123; if (contentSize &lt;= viewSize) &#123; return 0; &#125; return delta; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); viewWidth = MeasureSpec.getSize(widthMeasureSpec); viewHeight = MeasureSpec.getSize(heightMeasureSpec); // // Rescales image on rotation // if (oldMeasuredHeight == viewWidth &amp;&amp; oldMeasuredHeight == viewHeight || viewWidth == 0 || viewHeight == 0) return; oldMeasuredHeight = viewHeight; oldMeasuredWidth = viewWidth; if (saveScale == 1) &#123; //Fit to screen. float scale; Drawable drawable = getDrawable(); if (drawable == null || drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) return; int bmWidth = drawable.getIntrinsicWidth(); int bmHeight = drawable.getIntrinsicHeight(); Log.d(\"bmSize\", \"bmWidth: \" + bmWidth + \" bmHeight : \" + bmHeight); float scaleX = (float) viewWidth / (float) bmWidth; float scaleY = (float) viewHeight / (float) bmHeight; scale = Math.min(scaleX, scaleY); matrix.setScale(scale, scale); // Center the image float redundantYSpace = (float) viewHeight - (scale * (float) bmHeight); float redundantXSpace = (float) viewWidth - (scale * (float) bmWidth); redundantYSpace /= (float) 2; redundantXSpace /= (float) 2; matrix.postTranslate(redundantXSpace, redundantYSpace); origWidth = viewWidth - 2 * redundantXSpace; origHeight = viewHeight - 2 * redundantYSpace; setImageMatrix(matrix); &#125; fixTrans(); &#125;&#125; 方法2： 另一篇自定义一个ImageView 可根据个人使用情况修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Matrix;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import android.widget.ImageView; /** * 自定义的ImageView控制，可对图片进行多点触控缩放和拖动 */public class ZoomImageView extends ImageView &#123; /** * 初始化状态常量 */ public static final int STATUS_INIT = 1; /** * 图片放大状态常量 */ public static final int STATUS_ZOOM_OUT = 2; /** * 图片缩小状态常量 */ public static final int STATUS_ZOOM_IN = 3; /** * 图片拖动状态常量 */ public static final int STATUS_MOVE = 4; /** * 用于对图片进行移动和缩放变换的矩阵 */ private Matrix matrix = new Matrix(); /** * 待展示的Bitmap对象 */ private Bitmap sourceBitmap; /** * 记录当前操作的状态，可选值为STATUS_INIT、STATUS_ZOOM_OUT、STATUS_ZOOM_IN和STATUS_MOVE */ private int currentStatus; /** * ZoomImageView控件的宽度 */ private int width; /** * ZoomImageView控件的高度 */ private int height; /** * 记录两指同时放在屏幕上时，中心点的横坐标值 */ private float centerPointX; /** * 记录两指同时放在屏幕上时，中心点的纵坐标值 */ private float centerPointY; /** * 记录当前图片的宽度，图片被缩放时，这个值会一起变动 */ private float currentBitmapWidth; /** * 记录当前图片的高度，图片被缩放时，这个值会一起变动 */ private float currentBitmapHeight; /** * 记录上次手指移动时的横坐标 */ private float lastXMove = -1; /** * 记录上次手指移动时的纵坐标 */ private float lastYMove = -1; /** * 记录手指在横坐标方向上的移动距离 */ private float movedDistanceX; /** * 记录手指在纵坐标方向上的移动距离 */ private float movedDistanceY; /** * 记录图片在矩阵上的横向偏移值 */ private float totalTranslateX; /** * 记录图片在矩阵上的纵向偏移值 */ private float totalTranslateY; /** * 记录图片在矩阵上的总缩放比例 */ private float totalRatio; /** * 记录手指移动的距离所造成的缩放比例 */ private float scaledRatio; /** * 记录图片初始化时的缩放比例 */ private float initRatio; /** * 记录上次两指之间的距离 */ private double lastFingerDis; /** * ZoomImageView构造函数，将当前操作状态设为STATUS_INIT。 * * @param context * @param attrs */ public ZoomImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); currentStatus = STATUS_INIT; &#125; /** * 将待展示的图片设置进来。 * * @param bitmap * 待展示的Bitmap对象 */ public void setImageBitmap(Bitmap bitmap) &#123; sourceBitmap = bitmap; invalidate(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); if (changed) &#123; // 分别获取到ZoomImageView的宽度和高度 width = getWidth(); height = getHeight(); &#125; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (initRatio == totalRatio) &#123; getParent().requestDisallowInterceptTouchEvent(false); &#125; else &#123; getParent().requestDisallowInterceptTouchEvent(true); &#125; switch (event.getActionMasked()) &#123; case MotionEvent.ACTION_POINTER_DOWN: if (event.getPointerCount() == 2) &#123; // 当有两个手指按在屏幕上时，计算两指之间的距离 lastFingerDis = distanceBetweenFingers(event); &#125; break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_MOVE: if (event.getPointerCount() == 1) &#123; // 只有单指按在屏幕上移动时，为拖动状态 float xMove = event.getX(); float yMove = event.getY(); if (lastXMove == -1 &amp;&amp; lastYMove == -1) &#123; lastXMove = xMove; lastYMove = yMove; &#125; currentStatus = STATUS_MOVE; movedDistanceX = xMove - lastXMove; movedDistanceY = yMove - lastYMove; // 进行边界检查，不允许将图片拖出边界 if (totalTranslateX + movedDistanceX &gt; 0) &#123; movedDistanceX = 0; &#125; else if (width - (totalTranslateX + movedDistanceX) &gt; currentBitmapWidth) &#123; movedDistanceX = 0; &#125; if (totalTranslateY + movedDistanceY &gt; 0) &#123; movedDistanceY = 0; &#125; else if (height - (totalTranslateY + movedDistanceY) &gt; currentBitmapHeight) &#123; movedDistanceY = 0; &#125; // 调用onDraw()方法绘制图片 invalidate(); lastXMove = xMove; lastYMove = yMove; &#125; else if (event.getPointerCount() == 2) &#123; // 有两个手指按在屏幕上移动时，为缩放状态 centerPointBetweenFingers(event); double fingerDis = distanceBetweenFingers(event); if (fingerDis &gt; lastFingerDis) &#123; currentStatus = STATUS_ZOOM_OUT; &#125; else &#123; currentStatus = STATUS_ZOOM_IN; &#125; // 进行缩放倍数检查，最大只允许将图片放大4倍，最小可以缩小到初始化比例 if ((currentStatus == STATUS_ZOOM_OUT &amp;&amp; totalRatio &lt; 4 * initRatio) || (currentStatus == STATUS_ZOOM_IN &amp;&amp; totalRatio &gt; initRatio)) &#123; scaledRatio = (float) (fingerDis / lastFingerDis); totalRatio = totalRatio * scaledRatio; if (totalRatio &gt; 4 * initRatio) &#123; totalRatio = 4 * initRatio; &#125; else if (totalRatio &lt; initRatio) &#123; totalRatio = initRatio; &#125; // 调用onDraw()方法绘制图片 invalidate(); lastFingerDis = fingerDis; &#125; &#125; break; case MotionEvent.ACTION_POINTER_UP: if (event.getPointerCount() == 2) &#123; // 手指离开屏幕时将临时值还原 lastXMove = -1; lastYMove = -1; &#125; break; case MotionEvent.ACTION_UP: // 手指离开屏幕时将临时值还原 lastXMove = -1; lastYMove = -1; break; default: break; &#125; return true; &#125; /** * 根据currentStatus的值来决定对图片进行什么样的绘制操作。 */ @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); switch (currentStatus) &#123; case STATUS_ZOOM_OUT: case STATUS_ZOOM_IN: zoom(canvas); break; case STATUS_MOVE: move(canvas); break; case STATUS_INIT: initBitmap(canvas); default: if (sourceBitmap != null) &#123; canvas.drawBitmap(sourceBitmap, matrix, null); &#125; break; &#125; &#125; /** * 对图片进行缩放处理。 * * @param canvas */ private void zoom(Canvas canvas) &#123; matrix.reset(); // 将图片按总缩放比例进行缩放 matrix.postScale(totalRatio, totalRatio); float scaledWidth = sourceBitmap.getWidth() * totalRatio; float scaledHeight = sourceBitmap.getHeight() * totalRatio; float translateX = 0f; float translateY = 0f; // 如果当前图片宽度小于屏幕宽度，则按屏幕中心的横坐标进行水平缩放。否则按两指的中心点的横坐标进行水平缩放 if (currentBitmapWidth &lt; width) &#123; translateX = (width - scaledWidth) / 2f; &#125; else &#123; translateX = totalTranslateX * scaledRatio + centerPointX * (1 - scaledRatio); // 进行边界检查，保证图片缩放后在水平方向上不会偏移出屏幕 if (translateX &gt; 0) &#123; translateX = 0; &#125; else if (width - translateX &gt; scaledWidth) &#123; translateX = width - scaledWidth; &#125; &#125; // 如果当前图片高度小于屏幕高度，则按屏幕中心的纵坐标进行垂直缩放。否则按两指的中心点的纵坐标进行垂直缩放 if (currentBitmapHeight &lt; height) &#123; translateY = (height - scaledHeight) / 2f; &#125; else &#123; translateY = totalTranslateY * scaledRatio + centerPointY * (1 - scaledRatio); // 进行边界检查，保证图片缩放后在垂直方向上不会偏移出屏幕 if (translateY &gt; 0) &#123; translateY = 0; &#125; else if (height - translateY &gt; scaledHeight) &#123; translateY = height - scaledHeight; &#125; &#125; // 缩放后对图片进行偏移，以保证缩放后中心点位置不变 matrix.postTranslate(translateX, translateY); totalTranslateX = translateX; totalTranslateY = translateY; currentBitmapWidth = scaledWidth; currentBitmapHeight = scaledHeight; canvas.drawBitmap(sourceBitmap, matrix, null); &#125; /** * 对图片进行平移处理 * * @param canvas */ private void move(Canvas canvas) &#123; matrix.reset(); // 根据手指移动的距离计算出总偏移值 float translateX = totalTranslateX + movedDistanceX; float translateY = totalTranslateY + movedDistanceY; // 先按照已有的缩放比例对图片进行缩放 matrix.postScale(totalRatio, totalRatio); // 再根据移动距离进行偏移 matrix.postTranslate(translateX, translateY); totalTranslateX = translateX; totalTranslateY = translateY; canvas.drawBitmap(sourceBitmap, matrix, null); &#125; /** * 对图片进行初始化操作，包括让图片居中，以及当图片大于屏幕宽高时对图片进行压缩。 * * @param canvas */ private void initBitmap(Canvas canvas) &#123; if (sourceBitmap != null) &#123; matrix.reset(); int bitmapWidth = sourceBitmap.getWidth(); int bitmapHeight = sourceBitmap.getHeight(); if (bitmapWidth &gt; width || bitmapHeight &gt; height) &#123; if (bitmapWidth - width &gt; bitmapHeight - height) &#123; // 当图片宽度大于屏幕宽度时，将图片等比例压缩，使它可以完全显示出来 float ratio = width / (bitmapWidth * 1.0f); matrix.postScale(ratio, ratio); float translateY = (height - (bitmapHeight * ratio)) / 2f; // 在纵坐标方向上进行偏移，以保证图片居中显示 matrix.postTranslate(0, translateY); totalTranslateY = translateY; totalRatio = initRatio = ratio; &#125; else &#123; // 当图片高度大于屏幕高度时，将图片等比例压缩，使它可以完全显示出来 float ratio = height / (bitmapHeight * 1.0f); matrix.postScale(ratio, ratio); float translateX = (width - (bitmapWidth * ratio)) / 2f; // 在横坐标方向上进行偏移，以保证图片居中显示 matrix.postTranslate(translateX, 0); totalTranslateX = translateX; totalRatio = initRatio = ratio; &#125; currentBitmapWidth = bitmapWidth * initRatio; currentBitmapHeight = bitmapHeight * initRatio; &#125; else &#123; // 当图片的宽高都小于屏幕宽高时，直接让图片居中显示 float translateX = (width - sourceBitmap.getWidth()) / 2f; float translateY = (height - sourceBitmap.getHeight()) / 2f; matrix.postTranslate(translateX, translateY); totalTranslateX = translateX; totalTranslateY = translateY; totalRatio = initRatio = 1f; currentBitmapWidth = bitmapWidth; currentBitmapHeight = bitmapHeight; &#125; canvas.drawBitmap(sourceBitmap, matrix, null); &#125; &#125; /** * 计算两个手指之间的距离。 * * @param event * @return 两个手指之间的距离 */ private double distanceBetweenFingers(MotionEvent event) &#123; float disX = Math.abs(event.getX(0) - event.getX(1)); float disY = Math.abs(event.getY(0) - event.getY(1)); return Math.sqrt(disX * disX + disY * disY); &#125; /** * 计算两个手指之间中心点的坐标。 * * @param event */ private void centerPointBetweenFingers(MotionEvent event) &#123; float xPoint0 = event.getX(0); float yPoint0 = event.getY(0); float xPoint1 = event.getX(1); float yPoint1 = event.getY(1); centerPointX = (xPoint0 + xPoint1) / 2; centerPointY = (yPoint0 + yPoint1) / 2; &#125; &#125; 方法3： 自定义OnTouchListener 使用用法： Activity文件中：imageView.setOnTouchListener(new MulitPointTouchListener ()); xml文件中：android:scaleType=”matrix” 下面是自定义监听代码：MulitPointTouchListener.java public class MulitPointTouchListener implements OnTouchListener { private static final String TAG = \"MulitPointTouchListener\"; // These matrices will be used to move and zoom image Matrix matrix = new Matrix(); Matrix savedMatrix = new Matrix(); // We can be in one of these 3 states static final int NONE = 0; static final int DRAG = 1; static final int ZOOM = 2; int mode = NONE; // Remember some things for zooming PointF start = new PointF(); PointF mid = new PointF(); float oldDist = 1f; @Override public boolean onTouch(View v, MotionEvent event) { ImageView view = (ImageView) v; // Log.e(\"view_width\", // view.getImageMatrix()..toString()+\"*\"+v.getWidth()); // Dump touch event to log dumpEvent(event); // Handle touch events here... switch (event.getAction() &amp; MotionEvent.ACTION_MASK) { case MotionEvent.ACTION_DOWN: matrix.set(view.getImageMatrix()); savedMatrix.set(matrix); start.set(event.getX(), event.getY()); //Log.d(TAG, \"mode=DRAG\"); mode = DRAG; //Log.d(TAG, \"mode=NONE\"); break; case MotionEvent.ACTION_POINTER_DOWN: oldDist = spacing(event); //Log.d(TAG, \"oldDist=\" + oldDist); if (oldDist &gt; 10f) { savedMatrix.set(matrix); midPoint(mid, event); mode = ZOOM; //Log.d(TAG, \"mode=ZOOM\"); } break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_POINTER_UP: mode = NONE; //Log.e(\"view.getWidth\", view.getWidth() + \"\"); //Log.e(\"view.getHeight\", view.getHeight() + \"\"); break; case MotionEvent.ACTION_MOVE: if (mode == DRAG) { // ... matrix.set(savedMatrix); matrix.postTranslate(event.getX() - start.x, event.getY() - start.y); } else if (mode == ZOOM) { float newDist = spacing(event); //Log.d(TAG, \"newDist=\" + newDist); if (newDist &gt; 10f) { matrix.set(savedMatrix); float scale = newDist / oldDist; matrix.postScale(scale, scale, mid.x, mid.y); } } break; } view.setImageMatrix(matrix); return true; // indicate event was handled } private void dumpEvent(MotionEvent event) { String names[] = { \"DOWN\", \"UP\", \"MOVE\", \"CANCEL\", \"OUTSIDE\", \"POINTER_DOWN\", \"POINTER_UP\", \"7?\", \"8?\", \"9?\" }; StringBuilder sb = new StringBuilder(); int action = event.getAction(); int actionCode = action &amp; MotionEvent.ACTION_MASK; sb.append(\"event ACTION_\").append(names[actionCode]); if (actionCode == MotionEvent.ACTION_POINTER_DOWN || actionCode == MotionEvent.ACTION_POINTER_UP) { sb.append(\"(pid \").append( action &gt;&gt; MotionEvent.ACTION_POINTER_ID_SHIFT); sb.append(\")\"); } sb.append(\"[\"); for (int i = 0; i &lt; event.getPointerCount(); i++) { sb.append(\"#\").append(i); sb.append(\"(pid \").append(event.getPointerId(i)); sb.append(\")=\").append((int) event.getX(i)); sb.append(\",\").append((int) event.getY(i)); if (i + 1 &lt; event.getPointerCount()) sb.append(\";\"); } sb.append(\"]\"); //Log.d(TAG, sb.toString()); } private float spacing(MotionEvent event) { float x = event.getX(0) - event.getX(1); float y = event.getY(0) - event.getY(1); return FloatMath.sqrt(x * x + y * y); } private void midPoint(PointF point, MotionEvent event) { float x = event.getX(0) + event.getX(1); float y = event.getY(0) + event.getY(1); point.set(x / 2, y / 2); } }","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Android基于Tcp协议的Socket长链接封装","date":"2017-01-20T16:00:00.000Z","path":"2017/01/21/Android/App/2017-01-21-Android基于Tcp协议的Socket长链接封装/","text":"在Service中使用，注意以下规则 1234//startService() 启动Service其生命周期为context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running--&gt;context.stopService() | -&gt;onDestroy() -&gt;Service stop //对于bindService()启动Service：context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running--&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop TcpSocketHelper封装类，使Socket保持长连接，便于手机跟服务器通讯，保持心跳实时更新数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191package com.irobotcity.psnclient.net;import android.text.format.DateFormat;import android.util.Log;import com.irobotcity.psnclient.listener.OnRecivedListener;import com.irobotcity.psnclient.utils.LogUtils;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.net.InetAddress;import java.net.Socket;import java.util.Calendar;import java.util.Date;/** * 使用Socket封装长连接 * Created by Jerry on 2017/1/18. */public class TcpSocketHelper &#123; private String mTag = \"TcpSocketHelper\"; private Socket socket; private boolean _connect; private ReceiveThread mReceiveThread; private boolean receiveStop; private Date lastKeepAliveOkTime; private OnRecivedListener mRecivedListener; private String mIpAddr = \"192.168.1.137\"; private int mPort = 9995; /** * 开启链接socket * @param ipAddr * @param port */ public void startConnect(String ipAddr, int port)&#123; LogUtils.e(mTag, \"准备链接...\"); this.mIpAddr = ipAddr; this.mPort = port; InetAddress serverAddr; try &#123; socket = new Socket(ipAddr, port); _connect = true; mReceiveThread = new ReceiveThread(); receiveStop = false; mReceiveThread.start(); LogUtils.e(mTag, \"链接成功...\"); &#125; catch (Exception e) &#123; LogUtils.e(mTag, \"链接出错...\" + e.getMessage().toString()); e.printStackTrace(); &#125; &#125; /** * 关闭链接 */ public void closeConnect()&#123; if (socket != null)&#123; try &#123; socket.close(); socket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 保持心跳 */ public void KeepAlive() &#123; // 判断socket是否已断开,断开就重连 if (lastKeepAliveOkTime != null) &#123; LogUtils.e(mTag, \"上次心跳成功时间:\"+ DateFormat.format(\"yyyy-MM-dd HH:mm:ss\", lastKeepAliveOkTime)); Date now = Calendar.getInstance().getTime(); long between = (now.getTime() - lastKeepAliveOkTime.getTime());// 得到两者的毫秒数 if (between &gt; 60 * 1000) &#123; LogUtils.e(mTag, \"心跳异常超过1分钟,重新连接:\"); lastKeepAliveOkTime = null; socket = null; &#125; &#125; else &#123; lastKeepAliveOkTime = Calendar.getInstance().getTime(); &#125; if (!checkIsAlive()) &#123; LogUtils.e(mTag, \"链接已断开,重新连接.\"); startConnect(mIpAddr, mPort); &#125; &#125; /** * 此方法是检测是否连接 * @return */ public boolean checkIsAlive() &#123; if (socket == null||!socket.isConnected()) return false;// try &#123;// socket.sendUrgentData(0xFF);// &#125; catch (IOException e) &#123;// return false;// &#125; return true; &#125; /** * 发送数据的方法 * @param msg */ public void sendmessage(String msg) &#123; boolean isAlive = checkIsAlive(); if (!isAlive) return; LogUtils.e(mTag, \"准备发送消息:\" + msg); try &#123; if (socket != null &amp;&amp; socket.isConnected()) &#123; if (!socket.isOutputShutdown()) &#123; //2.得到socket读写流 OutputStream os=socket.getOutputStream(); //true:是否自动flush PrintWriter outStream=new PrintWriter(os, true); outStream.print(msg); outStream.flush(); &#125; &#125; LogUtils.e(mTag, \"发送成功!\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置接收数据监听器 * @param mRecivedListener */ public void setmRecivedListener(OnRecivedListener mRecivedListener) &#123; this.mRecivedListener = mRecivedListener; &#125; /** * 数据接收线程 */ class ReceiveThread extends Thread&#123; @Override public void run() &#123; while (true) &#123; try &#123; sleep(500);// LogUtils.i(mTag, \"监听中...:\"+socket.isConnected()); // 判断 Socket 是否处于连接状态 if (socket != null &amp;&amp; socket.isConnected()) &#123; // 客户端接收服务器端的响应，读取服务器端向客户端的输入流 InputStream isRead = socket.getInputStream(); // 缓冲区 byte[] buffer = new byte[isRead.available()]; // 读取缓冲区 isRead.read(buffer); // 转换为字符串 String responseInfo = new String(buffer); // 日志中输出 if(responseInfo != null&amp;&amp;!responseInfo.equals(\"\"))&#123; Log.e(\"TcpManager\", \"返回：\"+responseInfo); mRecivedListener.onRecived(responseInfo); &#125; lastKeepAliveOkTime = Calendar.getInstance().getTime(); KeepAlive(); continue; &#125; else &#123; if (socket != null) LogUtils.e(mTag, \"链接状态:\" + socket.isConnected()); &#125; &#125; catch (Exception e) &#123; LogUtils.e(mTag, \"监听出错:\" + e.toString()); e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 以下是OnRecivedListener监听器 123456789package com.irobotcity.psnclient.listener;/** * Created by Jerry on 2017/1/18. */public interface OnRecivedListener &#123; public void onRecived(String data);&#125;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"基于Tcp协议的Socket-C++封装","date":"2017-01-19T16:00:00.000Z","path":"2017/01/20/C_C++/2017-01-20-基于Tcp协议的Socket-C++封装/","text":"C++ Tcp封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Tcp.h: 基本网络通讯封装类////////////////////////////////////////////////////////////////////////#ifndef TCP_H#define TCP_H#include &lt;winsock.h&gt;#pragma comment(lib, \"wsock32.lib\") // search for wsock32 lib at compile time#define WM_TCP WM_APP+100class CTcp&#123; public: CTcp(); ~CTcp(); //extern int sd_connect, sd_bind, sd_accept; int wsa_ok ; static void peek_message(void); static int get_local_ip(char *ip); int init(); int exit(); int bind_listen(int port,sockaddr_in&amp; addr,long &amp;err); int status(int sd, char *type, int timeout=5); int bind(HWND hWnd, int port); int bind2(HWND hWnd, char *ip, int port); int accept(int sd, int timeout); int connect(char *hostname, int port, int timeout, int f_noblock); int connect2(char *bind_ip, char *hostname, int port, int timeout, int f_noblock); void disconnect(int sd); void close(int&amp; sd); int send(int sd, char *buf, int len, int timeout=10); int recv(int sd, char *buf, int len, int timeout=10); int gethostnamebyip(char *ip, char *name); unsigned short htons(unsigned short); unsigned short ntohs(unsigned short); unsigned long int htonl(unsigned long int); unsigned long int ntohl(unsigned long int); unsigned __int64 ntohh(unsigned __int64); unsigned __int64 htonh(unsigned __int64); float htonf(float f); float ntohf(float f); double htond(double d); double ntohd(double d); char *get_remote_ip(int sd, char *ip);&#125;;#endif // TCP_H 下面是tcp.cpp类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700// Tcp.cpp: implementation of the CTcp class.////////////////////////////////////////////////////////////////////////#include \"tcp.h\"//#include \"stdafx.h\"#include &lt;winsock.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include \"tcp.h\"extern WriteLog(char *file_name, char *format, ...);extern WriteStat(char *format, ...);//////////////////////////////////////////////////////////////////////// Construction/Destruction//////////////////////////////////////////////////////////////////////CTcp::CTcp()&#123; wsa_ok =0;&#125;CTcp::~CTcp()&#123;&#125;int CTcp::init()&#123; if(!wsa_ok) &#123; WSAData wsa; //sd_bind =sd_connect =sd_accept =-1; if(WSAStartup(MAKEWORD(1, 1), &amp;wsa) !=0) return -1; wsa_ok =1; &#125; return 0;&#125;int CTcp::exit()&#123; if(wsa_ok) WSACleanup(); return 0;&#125;int CTcp::status(int sd, char *type, int timeout)&#123; fd_set rset, wset, eset; fd_set FAR *prset =NULL, *pwset =NULL, *peset =NULL; struct timeval tval; int i, status, err_no =0; time_t t1, t2; MSG msg; tval.tv_sec =0; tval.tv_usec =1; time(&amp;t1); t2 =t1; while(t2-t1 &lt; timeout) &#123; FD_ZERO(&amp;rset); FD_ZERO(&amp;wset); FD_ZERO(&amp;eset); for(i =0; i&lt;(int)strlen(type); i++) &#123; if(type[i] =='r') &#123; FD_SET(sd, &amp;rset); prset =&amp;rset; &#125; if(type[i] =='w') &#123; FD_SET(sd, &amp;wset); pwset =&amp;wset; &#125; if(type[i] =='e') &#123; FD_SET(sd, &amp;eset); peset =&amp;eset; &#125; &#125; status =select(-1, prset, pwset, peset, &amp;tval); err_no =WSAGetLastError(); int err=GetLastError(); //WriteStat(\"select err_no=%d, err=%d\", err_no, err); time(&amp;t2); if(status ==0) &#123; if(PeekMessage(&amp;msg, 0, NULL, NULL, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); if(msg.message ==WM_QUIT) &#123; //WSASetLastError(WSAETIMEOUT); return -1; &#125; &#125; if(t2-t1 &lt;timeout) continue; else &#123; if(prset) FD_CLR((UINT)sd,&amp;rset); if(pwset) FD_CLR((UINT)sd,&amp;wset); if(peset) FD_CLR((UINT)sd,&amp;eset); WSASetLastError(WSAEWOULDBLOCK); return -10; &#125; &#125; if(peset &amp;&amp; FD_ISSET(sd, peset)) &#123; if(prset !=NULL) FD_CLR((UINT)sd,&amp;rset); if(pwset !=NULL) FD_CLR((UINT)sd,&amp;wset); if(peset !=NULL) FD_CLR((UINT)sd,&amp;eset); //err_no =WSAGetLastError(); /* len =sizeof(errno); getsockopt(sd, SOL_SOCKET, SO_ERROR, (char *)&amp;errno, &amp;len); */ WSASetLastError(err_no); return -1; &#125; if((prset &amp;&amp; FD_ISSET(sd, prset)) || (pwset &amp;&amp; FD_ISSET(sd, pwset))) &#123; //err_no =WSAGetLastError(); /* len =sizeof(errno); getsockopt(sd, SOL_SOCKET, SO_ERROR, (char *)&amp;errno, &amp;len); */ &#125; if(prset !=NULL) FD_CLR((UINT)sd,&amp;rset); if(pwset !=NULL) FD_CLR((UINT)sd,&amp;wset); if(peset !=NULL) FD_CLR((UINT)sd,&amp;eset); //if(status &lt;0) //err_no =WSAGetLastError(); WSASetLastError(err_no); if(err_no ==WSAEINTR) &#123; return WSAEINTR; &#125; if(err_no) &#123; return -1; &#125; else break; &#125; return 0;&#125;int CTcp::bind(HWND hWnd, int port)&#123; struct sockaddr_in addr; char temp[200]; int sd; sd =-1; if((sd =socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt;0) &#123; sprintf(temp, \"socket failed! errno:%d\", WSAGetLastError()); return -1; &#125; memset(&amp;addr, 0, sizeof(addr)); addr.sin_family =AF_INET; addr.sin_port =htons((unsigned short)port); int l =1; setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;l, sizeof(l)); /*setsockopt(sd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;l, sizeof(l));*/ if(::bind(sd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt;0) &#123; sprintf(temp, \"bind failed! errno:%d\", WSAGetLastError()); closesocket(sd); return -1; &#125; if(hWnd &amp;&amp; WSAAsyncSelect(sd, hWnd, WM_TCP, FD_ACCEPT) !=0) &#123; sprintf(temp, \"tcp_bind:WSAAsyncSelect failed!\"); closesocket(sd); return -2; &#125; //sd_bind =sd; listen(sd, 5); return sd;&#125;int CTcp::bind2(HWND hWnd, char *ip, int port)&#123; struct sockaddr_in addr; char temp[200]; int sd; sd =-1; if((sd =socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt;0) &#123; sprintf(temp, \"socket failed! errno:%d\", WSAGetLastError()); return -1; &#125; if(ip &amp;&amp; *ip) &#123; memset(&amp;addr, 0, sizeof(addr)); ULONG ul =inet_addr(ip); if(ul ==0xffffffff) &#123; closesocket(sd); return -1; &#125; else addr.sin_addr.s_addr=ul; &#125; memset(&amp;addr, 0, sizeof(addr)); addr.sin_family =AF_INET; addr.sin_port =htons((unsigned short)port); int l =1; setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;l, sizeof(l)); /*setsockopt(sd, SOL_SOCKET, SO_REUSEPORT, (char *)&amp;l, sizeof(l));*/ if(::bind(sd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt;0) &#123; sprintf(temp, \"bind failed! errno:%d\", WSAGetLastError()); closesocket(sd); return -1; &#125; if(hWnd &amp;&amp; WSAAsyncSelect(sd, hWnd, WM_TCP, FD_ACCEPT) !=0) &#123; sprintf(temp, \"tcp_bind:WSAAsyncSelect failed!\"); closesocket(sd); return -2; &#125; //sd_bind =sd; listen(sd, 5); return sd;&#125;int CTcp::accept(int sd, int timeout)&#123; int sd_acc =-1; struct sockaddr_in sa; int len; /*unsigned long l;*/ if(status(sd, \"rw\", timeout) &lt;0) return -1; len =sizeof(sa); if((sd_acc =::accept(sd, (struct sockaddr *)&amp;sa, &amp;len)) &lt;0) return -1; //sd_accept =sd_acc; /* l =1; if(ioctlsocket(sd_acc, FIONBIO, &amp;l) &lt;0) &#123; closesocket(sd); return -1; &#125;*/ return sd_acc;&#125;int CTcp::connect(char *hostname, int port, int timeout, int f_noblock)&#123; struct hostent *hp; struct sockaddr_in addr; char temp[200]; unsigned long ul; long l; int sd =-1, ret; time_t t1, t2; sd =-1; if((sd =::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt;0) &#123; sprintf(temp, \"socket failed! errno:%d\", WSAGetLastError()); return -1; &#125; memset(&amp;addr, 0, sizeof(addr)); ul =inet_addr(hostname); if(ul ==0xffffffff) &#123; if((hp =gethostbyname(hostname)) ==NULL) &#123; sprintf(temp, \"gethostbyname and inet_addr failed! errno:%d\", WSAGetLastError()); closesocket(sd); return -1; &#125; memcpy(&amp;addr.sin_addr, hp-&gt;h_addr, hp-&gt;h_length); &#125; else addr.sin_addr.s_addr=ul; addr.sin_family =AF_INET; addr.sin_port =htons((unsigned short)port); l =1; if(/*f_noblock &amp;&amp; */ioctlsocket(sd, FIONBIO, (unsigned long *)&amp;l) &lt;0) &#123; closesocket(sd); return -1; &#125; /*if(setsockopt(sd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;l, sizeof(l)) &lt;0) &#123; closesocket(sd); return -1; &#125;*/ time(&amp;t1); int counter=0; while((ret =::connect(sd, (struct sockaddr *)&amp;addr, sizeof(addr))) !=0) &#123; time(&amp;t2); if((t2 -t1) &gt; timeout) &#123; closesocket(sd); return -1; &#125; peek_message(); int err_no =WSAGetLastError(); if(ret ==SOCKET_ERROR) &#123; if(counter++&gt;10) &#123; Sleep(100); counter=0; &#125; if(err_no ==WSAEISCONN) break; &#125; else if(err_no ==WSAEWOULDBLOCK /*|| err_no ==WSAEINPROGRESS*/ || err_no ==WSAEALREADY) &#123; continue; &#125; else &#123; closesocket(sd); return -1; &#125; &#125; if(status(sd, \"we\", timeout) &lt;0) &#123; sprintf(temp, \"status:Á¬½Ó·þÎñÆ÷Ê§°Ü!\\n¼ì²é·þÎñÆ÷¶Ë³ÌÐòÊÇ·ñÔËÐÐ\\nÇÒÖ÷»úµØÖ·ÊÇ·ñ%s, ¶Ë¿ÚÊÇ·ñ%d\\n\" \"errno=%d\", hostname, port, WSAGetLastError()); closesocket(sd); return -1; &#125; //sd_connect =sd; return sd;&#125;int CTcp::connect2(char *bind_ip, char *hostname, int port, int timeout, int f_noblock)&#123; struct hostent *hp; struct sockaddr_in addr; char temp[200]; unsigned long ul; long l; int sd =-1, ret; time_t t1, t2; sd =-1; if((sd =socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt;0) &#123; sprintf(temp, \"socket failed! errno:%d\", WSAGetLastError()); return -1; &#125; if(bind_ip &amp;&amp; *bind_ip) &#123; memset(&amp;addr, 0, sizeof(addr)); addr.sin_family =AF_INET; ul =inet_addr(bind_ip); if(ul ==0xffffffff) &#123; closesocket(sd); return -1; &#125; else addr.sin_addr.s_addr=ul; if(::bind(sd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt;0) &#123; sprintf(temp, \"tcp_connect: bind failed! errno:%d\", WSAGetLastError()); closesocket(sd); return -1; &#125; &#125; memset(&amp;addr, 0, sizeof(addr)); ul =inet_addr(hostname); if(ul ==0xffffffff) &#123; if((hp =gethostbyname(hostname)) ==NULL) &#123; sprintf(temp, \"gethostbyname and inet_addr failed! errno:%d\", WSAGetLastError()); closesocket(sd); return -1; &#125; memcpy(&amp;addr.sin_addr, hp-&gt;h_addr, hp-&gt;h_length); &#125; else addr.sin_addr.s_addr=ul; addr.sin_family =AF_INET; addr.sin_port =htons((unsigned short)port); l =1; if(/*f_noblock &amp;&amp; */ioctlsocket(sd, FIONBIO, (unsigned long *)&amp;l) &lt;0) &#123; closesocket(sd); return -1; &#125; /*if(setsockopt(sd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;l, sizeof(l)) &lt;0) &#123; closesocket(sd); return -1; &#125;*/ time(&amp;t1); int counter=0; while((ret =::connect(sd, (struct sockaddr *)&amp;addr, sizeof(addr))) !=0) &#123; time(&amp;t2); if((t2 -t1) &gt; timeout) &#123; closesocket(sd); return -1; &#125; peek_message(); int err_no =WSAGetLastError(); if(ret ==SOCKET_ERROR) &#123; if(counter++&gt;10) &#123; Sleep(100); counter=0; &#125; if(err_no ==WSAEISCONN) break; &#125; else if(err_no ==WSAEWOULDBLOCK /*|| err_no ==WSAEINPROGRESS*/ || err_no ==WSAEALREADY) &#123; continue; &#125; else &#123; closesocket(sd); return -1; &#125; &#125; if(status(sd, \"we\", timeout) &lt;0) &#123; sprintf(temp, \"status:Á¬½Ó·þÎñÆ÷Ê§°Ü!\\n¼ì²é·þÎñÆ÷¶Ë³ÌÐòÊÇ·ñÔËÐÐ\\nÇÒÖ÷»úµØÖ·ÊÇ·ñ%s, ¶Ë¿ÚÊÇ·ñ%d\\n\" \"errno=%d\", hostname, port, WSAGetLastError()); closesocket(sd); return -1; &#125; //sd_connect =sd; return sd;&#125;void CTcp::disconnect(int sd)&#123; if(sd &gt;0) &#123; closesocket(sd); //if(sd ==sd_connect) sd_connect =-1; //if(sd ==sd_accept) sd_accept =-1; //if(sd ==sd_bind) sd_bind =-1; &#125;&#125;int CTcp::send(int sd, char *buf, int len, int timeout)&#123; int len1, len_send =0; time_t t1, t2; len_send =0; time(&amp;t1); t2 =t1; int counter=0; while(len_send &lt;len) &#123; if(t2-t1 &gt;timeout) return len_send; if(status(sd, \"w\", timeout-(t2-t1)) &lt;0) &#123; return len_send; &#125; if((len1 =::send(sd, &amp;buf[len_send], len-len_send, 0)) &lt;=0) &#123; if(len1 ==SOCKET_ERROR &amp;&amp; GetLastError() ==WSAEWOULDBLOCK) &#123; time(&amp;t2); if(counter++&gt;100) &#123; Sleep(100); counter=0; &#125; continue; &#125; return len_send; &#125; len_send +=len1; time(&amp;t2); &#125; return len_send;&#125;int CTcp::recv(int sd, char *buf, int len, int timeout)&#123; int len1, len_recv; time_t t2, t1; len_recv =0; time(&amp;t1); t2 =t1; int err =0; int counter=0; while(len_recv &lt;len) &#123; if(t2 -t1 &gt;timeout) &#123; WSASetLastError(err); return len_recv; &#125; if(status(sd, \"r\", timeout-(t2-t1)) &lt;0) &#123; err =WSAGetLastError(); //WriteStat(\"tcp_status err=%d\", WSAGetLastError()); WSASetLastError(err); return len_recv; &#125; if((len1 =::recv(sd, &amp;buf[len_recv], len-len_recv, 0)) &lt;=0) &#123; err =WSAGetLastError(); //WriteStat(\"recv err=%d, len1=%d\", err, len1); if(timeout ==0) break; if(len1 ==SOCKET_ERROR &amp;&amp; err ==WSAEWOULDBLOCK) &#123; time(&amp;t2); if(counter++&gt;100) &#123; Sleep(100); counter=0; &#125; continue; &#125; WSASetLastError(err); return len_recv; &#125; len_recv +=len1; time(&amp;t2); &#125; WSASetLastError(err); return len_recv;&#125;int CTcp::gethostnamebyip(char *ip, char *host)&#123; struct hostent *hp; struct in_addr ul; host[0] =0; ul.S_un.S_addr =inet_addr(ip); if(ul.S_un.S_addr ==0xFFFFFFFF) return -1; // ip error or ip is hostname hp =gethostbyaddr((char *)&amp;ul, 4, AF_INET); if(hp ==NULL) return -1; // can not get hostname strcpy(host, hp-&gt;h_name); return 0;&#125;int CTcp::get_local_ip(char *ip)&#123; struct hostent *hp; char host[50], *p; if(gethostname(host, sizeof(host)) &lt;0) return -1; hp =gethostbyname(host); if(hp ==NULL) return -1; p =(char *)hp-&gt;h_addr; wsprintfA(ip, \"%d.%d.%d.%d\", (int)p[0]&amp;0xFF, (int)p[1]&amp;0xFF, (int)p[2]&amp;0xFF, (int)p[3]&amp;0xFF); return 0;&#125;char* CTcp::get_remote_ip(int sd, char *ip)&#123; struct sockaddr_in addr_in; int len =sizeof(addr_in); char *p1; if(sd &lt;0) return NULL; if(getpeername(sd, (struct sockaddr *)&amp;addr_in, &amp;len) &lt;0) return NULL; p1 =(char *)&amp;addr_in.sin_addr; sprintf(ip, \"%d.%d.%d.%d\", ((int)p1[0]) &amp;0xff, ((int)p1[1]) &amp;0xff, (int)p1[2] &amp;0xff, (int)p1[3]&amp;0xff); return ip;&#125;unsigned short CTcp::htons(unsigned short s)&#123; return ::htons(s);&#125;unsigned short CTcp::ntohs(unsigned short s)&#123; return ::ntohs(s);&#125;unsigned long int CTcp::htonl(unsigned long int l)&#123; return ::htonl(l);&#125;unsigned long int CTcp::ntohl(unsigned long int l)&#123; return ::ntohl(l);&#125;float CTcp::htonf(float f)&#123; unsigned char *p, p0, p1; if(htons(1) ==1) return f; p =(unsigned char *)&amp;f; p0 =p[0]; p1 =p[1]; p[0] =p[3]; p[3] =p0; p[1] =p[2]; p[2] =p1; return f;&#125;float CTcp::ntohf(float f)&#123; unsigned char *p, p0, p1; if(ntohs(1) ==1) return f; p =(unsigned char *)&amp;f; p0 =p[0]; p1 =p[1]; p[0] =p[3]; p[3] =p0; p[1] =p[2]; p[2] =p1; return f;&#125;double CTcp::htond(double d)&#123; unsigned char *p, p0, p1, p2, p3; if(htons(1) ==1) return d; p =(unsigned char *)&amp;d; p0 =p[0]; p1 =p[1]; p2 =p[2]; p3 =p[3]; p[0] =p[7]; p[7] =p0; p[1] =p[6]; p[6] =p1; p[2] =p[5]; p[5] =p2; p[3] =p[4]; p[4] =p3; return d;&#125;double CTcp::ntohd(double d)&#123; unsigned char *p, p0, p1, p2, p3; if(ntohs(1) ==1) return d; p =(unsigned char *)&amp;d; p0 =p[0]; p1 =p[1]; p2 =p[2]; p3 =p[3]; p[0] =p[7]; p[7] =p0; p[1] =p[6]; p[6] =p1; p[2] =p[5]; p[5] =p2; p[3] =p[4]; p[4] =p3; return d;&#125;unsigned __int64 CTcp::htonh(unsigned __int64 d)&#123; unsigned char *p, p0, p1, p2, p3; if(htons(1) ==1) return d; p =(unsigned char *)&amp;d; p0 =p[0]; p1 =p[1]; p2 =p[2]; p3 =p[3]; p[0] =p[7]; p[7] =p0; p[1] =p[6]; p[6] =p1; p[2] =p[5]; p[5] =p2; p[3] =p[4]; p[4] =p3; return d;&#125;unsigned __int64 CTcp::ntohh(unsigned __int64 d)&#123; unsigned char *p, p0, p1, p2, p3; if(ntohs(1) ==1) return d; p =(unsigned char *)&amp;d; p0 =p[0]; p1 =p[1]; p2 =p[2]; p3 =p[3]; p[0] =p[7]; p[7] =p0; p[1] =p[6]; p[6] =p1; p[2] =p[5]; p[5] =p2; p[3] =p[4]; p[4] =p3; return d;&#125;void CTcp::peek_message(void)&#123; MSG msg; if(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125;&#125;int CTcp::bind_listen(int port,sockaddr_in&amp; addr,long &amp;err)&#123; int sock; sock = socket(AF_INET, SOCK_STREAM, 0); // Create socket addr.sin_family = AF_INET; // Address family Internet addr.sin_port = htons (port); // Assign port 'port' to this socket addr.sin_addr.s_addr = htonl (INADDR_ANY); // No destination if (::bind (sock, (LPSOCKADDR) &amp;addr, sizeof (addr)) == SOCKET_ERROR) &#123; closesocket (sock); err = WSAGetLastError (); return -1; &#125; if (::listen (sock, 10) == SOCKET_ERROR) &#123; closesocket (sock); err = WSAGetLastError (); return -1; &#125; return sock;&#125;void CTcp::close(int &amp;sd)&#123; shutdown(sd,0); closesocket(sd); sd = INVALID_SOCKET;&#125; 下面是main.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include \"tcp.h\"#include &lt;WinSock2.h&gt;#pragma comment(lib, \"ws2_32.lib\");#define PORT 9995using namespace std;int main(int argc, char *argv[])&#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); ::WSAStartup(sockVersion, &amp;wsaData); char lv_name[50]; gethostname(lv_name, 50);// hostent * lv_pHostent;// lv_pHostent = (hostent *)malloc(sizeof(hostent));// if( NULL == (lv_pHostent = gethostbyname(lv_name)))// &#123;// printf(\"get Hosrname Fail \\n\");// return 0;// &#125;// SOCKADDR_IN lv_sa;// lv_sa.sin_family = AF_INET;// lv_sa.sin_port = htons(6000);// memcpy(&amp;lv_sa.sin_addr.S_un.S_addr, lv_pHostent-&gt;h_addr_list[0], lv_pHostent-&gt;h_length);// printf(\"%s\\n\", inet_ntoa(lv_sa.sin_addr)); CTcp tcp_client; tcp_client.init(); cout &lt;&lt; \"please input str\" &lt;&lt; endl; char buf[1024] = &#123;0&#125;; memset(buf, 0, sizeof(buf));// gets(buf); char *hostname = \"192.168.1.137\"; int sd = tcp_client.connect(hostname, PORT, 3000, 0); char *ip; if(sd != -1)&#123; tcp_client.get_remote_ip(sd, ip); cout &lt;&lt; \"success connection ip:\" &lt;&lt; ip &lt;&lt; endl; while(1)&#123; memset(buf, 0, sizeof(buf)); gets(buf); int re = tcp_client.send(sd, buf, sizeof(buf), 10); if(strncmp(buf, \"exit\", 4) == 0) break; &#125; &#125; cout &lt;&lt; \"over\" &lt;&lt; endl; return 0;&#125;","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.hsujee.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"}]},{"title":"《琵琶语》林海指弹吉他谱","date":"2017-01-03T16:00:00.000Z","path":"2017/01/04/Guitar/2017-01-04-《琵琶语》林海指弹吉他谱/","text":"《琵琶语》林海指弹吉他谱","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"},{"name":"指弹","slug":"指弹","permalink":"https://blog.hsujee.io/tags/指弹/"}]},{"title":"《漂》指弹吉他谱","date":"2017-01-02T16:00:00.000Z","path":"2017/01/03/Guitar/2017-01-03-《漂》指弹吉他谱/","text":"《漂》指弹吉他谱","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"},{"name":"指弹","slug":"指弹","permalink":"https://blog.hsujee.io/tags/指弹/"}]},{"title":"Pattern,Matcher,正则表达式的使用详解","date":"2017-01-02T16:00:00.000Z","path":"2017/01/03/Android/Tool/2017-1-3-Pattern,Matcher,正则表达式的使用详解/","text":"##Pattern,Matcher,正则表达式L## 在程序开发中，我们为了解决一些复杂的匹配，判断，查找，替换字符串等问题，如果使用代码，往往会特别复杂，围了解决这一问题，便使用正则表达式代替代码实现这些功能 如何使用正则表达式语法，请参考正则表达式文档 在Android中的使用方法： 1.定义正则表达式 1private final static Pattern name = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9_]&#123;5,19&#125;$\"); 2.使用正则表达式做匹配验证： 1boolean isName = name.matcher(_name).matches() 其中参数_name是你想要验证的目标字符串，类型为String 下面列举常用的正则表达式： 一、校验数字的表达式1 数字：^[0-9]*$ 2 n位的数字：^\\d{n}$ 3 至少n位的数字：^\\d{n,}$ 4 m-n位的数字：^\\d{m,n}$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 17 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 18 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ ###二、校验字符的表达式### 1 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3 长度为3-20的所有字符：^.{3,20}$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 15 钱的输入格式： 16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 26 中文字符的正则表达式：[\\u4e00-\\u9fa5] 27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.hsujee.io/tags/正则表达式/"}]},{"title":"《忆》完整版曲谱","date":"2017-01-01T16:00:00.000Z","path":"2017/01/02/Guitar/2017-01-02-《忆》指弹吉他谱/","text":"《忆》完整版曲谱","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"},{"name":"指弹","slug":"指弹","permalink":"https://blog.hsujee.io/tags/指弹/"}]},{"title":"《异乡人》张磊","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/Guitar/2017-01-01-《异乡人》张磊/","text":"《异乡人》张磊 中国好声音","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"}]},{"title":"《美丽的神话》指弹吉他谱","date":"2016-12-20T16:00:00.000Z","path":"2016/12/21/Guitar/2016-12-21-《美丽的神话》指弹吉他谱/","text":"美丽的神话指弹吉他谱","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"},{"name":"指弹","slug":"指弹","permalink":"https://blog.hsujee.io/tags/指弹/"}]},{"title":"Android系统OTG_usb链接摄像头的驱动和使用","date":"2016-12-13T16:00:00.000Z","path":"2016/12/14/Android/App/2016-12-14-Android系统OTG_usb链接摄像头的驱动和使用/","text":"这段时间做一个Android项目，需要在一台Android 4.4.4系统设备上链接usb摄像头，用作人脸识别，于是作为Android项目组“骨干”（哈哈臭屁一下^-^）的我开始了usb摄像头攻坚战，爬帖子，找博客，最后眼睛瞅准了一篇博客(感谢)http://blog.csdn.net/sukhoi27smk/article/details/18269097 在他的帮助下我找到了https://bitbucket.org/neuralassembly/simplewebcam/src 然后下载源码开始了我的usb摄像头驱动之旅 我整理的库文件下载点击查看 首先是在Linux Ubuntu系统下面配置环境，AS，NDK，如果想写C代码方便可以安装QT（个人推荐，其他都行，比如gedit就很好使）软件安装，环境配置，这些自当不必多说。。。网上有N多种方式可以搞定 接下来就开始代码改造 找到jni文件夹下的ImageProc.c文件修改其中的jni接口方法名，使之指向CameraPreview.java 我修改后如下所示，找到其他的jni方法用同样方式修改方法名（不要忘了同步.h文件中的方法名哦。。。）： 1void Java_com_mojsoft_usbcamera_view_CameraPreview_pixeltobmp( JNIEnv* env,jobject thiz,jobject bitmap) Ctrl+Alt+T打开终端，cd到你的jni目录下，运行ndk-build,编译成功 cd .. 回到jni目录外面，运行ls就可以看到libs,obj两个目录，将libs中的libImageProc.so文件拷贝到你项目中的jniLibs目录下（AS） 接下来是java调用 [注意：java包名和C文件方法格式一致] 将CameraPreview文件放到布局中，编译运行。。。 接下来就是盯着屏幕。。。 满满的惊喜，问题就这么解决了，哈哈 下面是主要的CameraSurfaView类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163class CameraPreview extends SurfaceView implements SurfaceHolder.Callback, Runnable &#123; private static final boolean DEBUG = true; private static final String TAG = \"WebCam\"; protected Context context; private SurfaceHolder holder; Thread mainLoop = null; private Bitmap bmp = null; private byte[] byteArrary; private boolean cameraExists = false; private boolean shouldStop = false; // /dev/videox (x=cameraId+cameraBase) is used. // In some omap devices, system uses /dev/video[0-3], // so users must use /dev/video[4-]. // In such a case, try cameraId=0 and cameraBase=4 private int cameraId = 0; private int cameraBase = 0; // This definition also exists in ImageProc.h. // Webcam must support the resolution 640x480 with YUYV format. static final int IMG_WIDTH = 640; static final int IMG_HEIGHT = 480; // The following variables are used to draw camera images. private int winWidth = 0; private int winHeight = 0; private Rect rect; private int dw, dh; private float rate; private boolean isFramAready = false; private AlreadyRGBListener listener; // JNI functions public native int prepareCamera(int videoid); public native int prepareCameraWithBase(int videoid, int camerabase); public native void processCamera(); public native void stopCamera(); public native void pixeltobmp(Bitmap bitmap); public native byte[] getRgb(); static &#123; System.loadLibrary(\"ImageProc\"); &#125; public CameraPreview(Context context) &#123; super(context); this.context = context; if (DEBUG) Log.d(TAG, \"CameraPreview constructed\"); setFocusable(true); holder = getHolder(); holder.addCallback(this); holder.setType(SurfaceHolder.SURFACE_TYPE_NORMAL); &#125; public CameraPreview(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; if (DEBUG) Log.d(TAG, \"CameraPreview constructed\"); setFocusable(true); holder = getHolder(); holder.addCallback(this); holder.setType(SurfaceHolder.SURFACE_TYPE_NORMAL); &#125; @Override public void run() &#123; while (true &amp;&amp; cameraExists) &#123; //obtaining display area to draw a large image if (winWidth == 0) &#123; winWidth = this.getWidth(); winHeight = this.getHeight(); if (winWidth * 3 / 4 &lt;= winHeight) &#123; dw = 0; dh = (winHeight - winWidth * 3 / 4) / 2; rate = ((float) winWidth) / IMG_WIDTH; rect = new Rect(dw, dh, dw + winWidth - 1, dh + winWidth * 3 / 4 - 1); &#125; else &#123; dw = (winWidth - winHeight * 4 / 3) / 2; dh = 0; rate = ((float) winHeight) / IMG_HEIGHT; rect = new Rect(dw, dh, dw + winHeight * 4 / 3 - 1, dh + winHeight - 1); &#125; &#125; // obtaining a camera image (pixel data are stored in an array in JNI). processCamera(); // camera image to bmp pixeltobmp(bmp); byte[] arr = getRgb(); isFramAready = true; Canvas canvas = getHolder().lockCanvas(); if (canvas != null) &#123; // draw camera bmp on canvas canvas.drawBitmap(bmp, null, rect, null); getHolder().unlockCanvasAndPost(canvas); &#125; listener.alreadyRGB(arr); if (shouldStop) &#123; shouldStop = false; break; &#125; &#125; &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; if (DEBUG) Log.d(TAG, \"surfaceCreated\"); if (bmp == null) &#123; bmp = Bitmap.createBitmap(IMG_WIDTH, IMG_HEIGHT, Bitmap.Config.ARGB_8888); &#125; if (byteArrary == null) &#123; byteArrary = new byte[IMG_WIDTH * IMG_HEIGHT]; &#125; // /dev/videox (x=cameraId + cameraBase) is used //下面一句是原代码，我尝试失败，于是我将其修改为 int ret = prepareCamera(0);后成功调用 // int ret = prepareCameraWithBase(cameraId, cameraBase); int ret = prepareCamera(0); if (ret != -1) cameraExists = true; mainLoop = new Thread(this); mainLoop.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; if (DEBUG) Log.d(TAG, \"surfaceChanged\"); &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; if (DEBUG) Log.d(TAG, \"surfaceDestroyed\"); if (cameraExists) &#123; shouldStop = true; while (shouldStop) &#123; try &#123; Thread.sleep(50); // wait for thread stopping &#125; catch (Exception e) &#123; &#125; &#125; &#125; stopCamera(); &#125; public void setGetBitmapListener(AlreadyRGBListener listener)&#123; this.listener = listener; &#125;&#125;","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.hsujee.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"https://blog.hsujee.io/tags/NDK/"}]},{"title":"《无题》指弹吉他谱-陈亮","date":"2016-12-13T16:00:00.000Z","path":"2016/12/14/Guitar/2016-12-14-《无题》指弹吉他谱-陈亮/","text":"一首特别好听的指弹吉他谱，里面指弹技巧全面，适合指弹练习曲","tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://blog.hsujee.io/tags/吉他谱/"},{"name":"指弹","slug":"指弹","permalink":"https://blog.hsujee.io/tags/指弹/"}]},{"title":"MarkDown常用技巧","date":"2016-12-12T16:00:00.000Z","path":"2016/12/13/Tools/2016-12-13-MarkDown常用技巧/","text":"Markdown 语法说明 (简体中文版) / (点击查看快速入门) 概述宗旨兼容 HTML特殊字符自动转换区块元素段落和换行标题区块引用列表代码区块分隔线区段元素链接强调代码图片其它反斜杠自动链接感谢Markdown 免费编辑器概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 、、、 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 Foo 这是另一个普通段落。请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。 HTML 的区段（行内）标签如 、、 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 或 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird你必须要把网址转换写为： http://images.google.com/images?num=30&amp;q=larry+bird才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &copy;Markdown 会保留它不动。而若你写： AT&amp;TMarkdown 就会将它转为： AT&amp;T类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5Markdown 将会把它转换为： 4 &lt; 5不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 标签。 如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 ，但是简单地「每个换行都转换为 」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1This is an H2任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 这是 H1这是 H2这是 H6你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 这是 H1这是 H2这是 H3区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： This is the first level of quoting. This is nested blockquote. Back to the first level.引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： Red Green Blue等同于： Red Green Blue也等同于： Red Green Blue有序列表则使用数字接着一个英文句点： Bird McHale Parish很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： Bird McHale Parish如果你的列表标记写成： Bird McHale Parish或甚至是： Bird McHale Parish你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing.但是如果你懒，那也行： Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing.如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 标签包起来，举例来说： Bird Magic会被转换为： Bird Magic但是这个： Bird Magic会被转换为： Bird Magic列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreetvitae, risus. Donec sit amet nisl. Aliquam semper ipsumsit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list.如果要在列表项目内放进引用，那 &gt; 就需要缩进： A list item with a blockquote: This is a blockquoteinside a list item.如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： What a great season.换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986. What a great season.代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 和 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： 这是一个普通段落： 这是一个代码区块。这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： Here is an example of AppleScript: tell application “Foo” beepend tell一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;div class=”footer”&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt;代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is an example inline link. This link has no title attribute.会产生： This is an example inline link. This link has notitle attribute.如果你是要链接到同样主机的资源，你可以使用相对路径：See my About page for details.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：This is an example reference-style link.你也可以选择性地在两个方括号中间加上一个空格：This is an example reference-style link.接着，在文件的任意处，你可以把这个标记的链接内容定义出来：id: http://example.com/ “Optional Title Here”链接内容定义的形式为：方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址选择性地接着 title 内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同：[foo]: http://example.com/ “Optional Title Here”[foo]: http://example.com/ ‘Optional Title Here’[foo]: http://example.com/ (Optional Title Here)请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。链接网址也可以用尖括号包起来：id: http://example.com/ “Optional Title Here”你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：id: http://example.com/longish/path/to/resource/here “Optional Title Here”网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：[link text][a][link text][A]隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：[Google][]然后定义链接内容：[Google]: http://google.com/由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：Visit [Daring Fireball][] for more information.然后接着定义链接：[Daring Fireball]: http://daringfireball.net/链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。下面是一个参考式链接的范例：I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ “Google” [2]: http://search.yahoo.com/ “Yahoo Search” [3]: http://search.msn.com/ “MSN Search”如果改成用链接名称的方式写：I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ “Google” [yahoo]: http://search.yahoo.com/ “Yahoo Search” [msn]: http://search.msn.com/ “MSN Search”上面两种写法都会产生下面的 HTML。I get 10 times more traffic from Google than fromYahooor MSN.下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：I get 10 times more traffic from Googlethan from Yahoo orMSN.参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号，被 或 包围的字词会被转成用 标签包围，用两个 * 或 包起来的话，则会被转成 ，例如：single asteriskssingle underscoresdouble asterisksdouble underscores会转成：single asteriskssingle underscoresdouble asterisksdouble underscores你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间：unfriggingbelievable但是如果你的 和 _ 两边都有空白的话，它们就只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\\this text is surrounded by literal asterisks*代码如果要标记一小段行内代码，你可以用反引号把它包起来（），例如： Use theprintf()function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick () here.这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` A backtick-delimited string in a code span: `` foo`` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt; A backtick-delimited string in a code span: foo在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any &lt;blink&gt; tags.转为： Please don’t use any &lt;blink&gt; tags.你也可以这样写： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;.以产生： &amp;#8212; is the decimal-encodedequivalent of &amp;mdash;.图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： 详细叙述如下： 一个惊叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。参考式的图片语法则长得像这样： 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/Markdown 会转为： http://example.com/邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &#97;&#x64;&#x64;&#114;&#x65;&#115;&#x73;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109;Markdown 会转成： &#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109;在浏览器里面，这段字串（其实是 address@example.com）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠： *literal asterisks*Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号 星号_ 底线{} 花括号[] 方括号() 括弧井字号 加号 减号. 英文句点! 惊叹号感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPadMarkPadLinux 平台 ReTextMac 平台 Mou在线编辑器 Markable.inDillinger.io浏览器插件 MaDe (Chrome)高级应用 Sublime Text 2 + MarkdownEditing / 教程* 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"应用","slug":"应用","permalink":"https://blog.hsujee.io/tags/应用/"}]},{"title":"Android录音和录像功能详解","date":"2016-11-19T16:00:00.000Z","path":"2016/11/20/Android/App/2015-11-20-Android录音和录像功能详解/","text":"本文使用Android系统自带Api import android.media.MediaRecorder; import android.media.MediaPlayer; 来进行Android录音和录像功能的实现，下面上主要代码 创建保存路径123456789101112131415161718/** * 根据Audio种类创建文件保存路径 * @param isAudio * @return */private File getFilePath(boolean isAudio) &#123; File file = null; File sampleDir = Environment.getExternalStorageDirectory(); if (!sampleDir.canWrite()) sampleDir = new File(\"/mnt/sdcard\"); try &#123; file = File.createTempFile(SAMPLE_PREFIX, isAudio ? \".amr\" : \".mp4\", sampleDir); &#125; catch (IOException e) &#123; &#125; return file;&#125; 录音代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@SuppressLint(\"InlinedApi\")public void startRecorderAudio(View view) &#123; stop(view); mtv.setText(\"开始录音...\"); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.AMR_NB); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mAudioFile = getFilePath(true); // Handle IOException try &#123; mRecorder.setOutputFile(mAudioFile.getAbsolutePath()); mRecorder.prepare(); &#125; catch (Exception exception) &#123; setError(INTERNAL_ERROR); mRecorder.reset(); mRecorder.release(); mRecorder = null; return; &#125; // Handle RuntimeException if the recording couldn't start try &#123; mRecorder.start(); &#125; catch (RuntimeException exception) &#123; AudioManager audioMngr = (AudioManager) this .getSystemService(Context.AUDIO_SERVICE); boolean isInCall = ((audioMngr.getMode() == AudioManager.MODE_IN_CALL) || (audioMngr .getMode() == AudioManager.MODE_IN_COMMUNICATION)); if (isInCall) &#123; setError(IN_CALL_RECORD_ERROR); &#125; else &#123; setError(INTERNAL_ERROR); &#125; mRecorder.reset(); mRecorder.release(); mRecorder = null; return; &#125;&#125;public void stopRecorderAudio(View view) &#123; if (mRecorder == null) return; mtv.setText(\"停止录音...\"); mRecorder.stop(); mRecorder.release(); mRecorder = null;&#125; 录像代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@SuppressLint(\"NewApi\")public void startRecorderVideo(View view) &#123; stop(view); mtv.setText(\"开始录像...\"); mMediaRecorder = new MediaRecorder(); mMediaRecorder.setPreviewDisplay(mSurfaceView.getHolder().getSurface()); // mMediaRecorder.setCamera(mCamera); mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); // 这两项需要放在setOutputFormat之后 mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264); // 设置立体声 mMediaRecorder.setAudioChannels(2); // 设置最大录像时间 单位：毫秒 mMediaRecorder.setMaxDuration(600000); // 设置最大录制的大小 单位，字节 mMediaRecorder.setMaxFileSize(1024 * 1024); // 音频一秒钟包含多少数据位 mMediaRecorder.setAudioEncodingBitRate(128); // 设置选择角度，顺时针方向，因为默认是逆向90度的，这样图像就是正常显示了， // 这里设置的是观看保存后的视频的角度 // mMediaRecorder.setOrientationHint(90); // 设置录像的分辨率 mMediaRecorder.setVideoSize(720, 480); // mMediaRecorder.setVideoFrameRate(20); try &#123; mMediaRecorder.setOutputFile(getFilePath(false).getAbsolutePath()); mMediaRecorder.prepare(); mMediaRecorder.start(); // Recording is now started &#125; catch (RuntimeException exception) &#123; exception.printStackTrace(); mMediaRecorder.reset(); mMediaRecorder.release(); mMediaRecorder = null; return; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;public void stopRecorderVideo(View view) &#123; if (mMediaRecorder == null) &#123; return; &#125; mtv.setText(\"停止录像...\"); mMediaRecorder.stop(); mMediaRecorder.release(); mMediaRecorder = null;&#125; 播放测试代码12345678910111213141516171819202122232425262728293031public void startPlayback(View view) &#123; stop(view); mtv.setText(\"开始播放...\"); mPlayer = new MediaPlayer(); try &#123; mPlayer.setDataSource(mAudioFile.getAbsolutePath()); mPlayer.setOnCompletionListener(this); mPlayer.setOnErrorListener(this); mPlayer.prepare(); mPlayer.start(); &#125; catch (IllegalArgumentException e) &#123; setError(INTERNAL_ERROR); mPlayer = null; return; &#125; catch (IOException e) &#123; setError(SDCARD_ACCESS_ERROR); mPlayer = null; return; &#125;&#125;public void stopPlayback(View view) &#123; if (mPlayer == null) // we were not in playback return; mtv.setText(\"停止播放...\"); mPlayer.stop(); mPlayer.release(); mPlayer = null;&#125;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"udp的封装和使用","date":"2016-09-30T16:00:00.000Z","path":"2016/10/01/C_C++/2016-10-01-udp的封装/","text":"使用C++ 将udp做一个简单的封装，实现及时通讯，以供大家参考学习和自己备用 本项目由QT编写， windows下需要在 .pro文件需要加入以下配置： #-lWs2_32 添加库Ws2_32 LIBS += -lWs2_32 测试方法：编译通过后，win+R 输入cmd 回车打开命令窗口发送端：输入.exe文件名后边加IP地址接受端：输入.exe文件名直接运行退出：输入exit回车退出 代码如下：udp.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef UDP_H#define UDP_H#ifdef MYLINUX#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define SOCKET int#else#include &lt;winsock2.h&gt;#endif//明确此函数是C语言函数，编译时候不要转换成C++格式了//extern \"C\"//&#123;//&#125;class myudp&#123;private: SOCKET st;public: myudp(); ~myudp(); int socket_bind(short int port); int socket_send(const char *IP, const short int port, const char *buf, int len); int socket_recv(char *buf, int len, char *srcIP);&#125;;#endif // UDP_H udp.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include \"udp.h\"int myudp::socket_send(const char *IP, const short int port, const char *buf, int len)&#123; /** * 建立socket * AF_INET 指定使用TCP/IP协议 * SOCK_DGRAM 指定使用UDP协议 */ st = socket(AF_INET, SOCK_DGRAM, 0); struct sockaddr_in addr; memset(&amp;addr, 0, sizeof(addr));//初始化结构 addr.sin_family = AF_INET; addr.sin_port = htons(port);//host to net short addr.sin_addr.s_addr = inet_addr(IP); //IP 内存原理解析// unsigned long laddr = inet_addr(\"192.168.6.200\");// unsigned char *p = &amp;laddr;// printf(\"IP_long:%x\\n\", laddr);// printf(\"IP_char:%u,%u,%u,%u\\n\", *(p),*(p+1),*(p+2),*(p+3)); size_t rc = sendto(st, buf, len, 0, (struct sockaddr *)&amp;addr, sizeof(addr)); return rc;&#125;int myudp::socket_recv(char *buf, int len, char *srcIP)&#123; struct sockaddr_in sendaddr; memset(&amp;sendaddr, 0, sizeof(sendaddr));#ifdef MYLINUX socklen_t addrlen;#else int addrlen;#endif addrlen = sizeof(sendaddr); memset(buf, 0, len); //接受UDP数据 size_t rc = recvfrom(st, buf, len, 0, (struct sockaddr *)&amp;sendaddr, &amp;addrlen);// printf(\"%s:%s\\n\", inet_ntoa(sendaddr.sin_addr), buf); if(srcIP) strcpy(srcIP, inet_ntoa(sendaddr.sin_addr)); return rc;&#125;myudp::myudp()&#123;#ifndef MYLINUX /** * 初始化socket */ DWORD ver; WSADATA wsaData; ver = MAKEWORD(1, 1);//在WSAStartup之前，告诉windows使用Socket的版本号 WSAStartup(ver, &amp;wsaData);//windows要求，使用socket必须调用这个函数#endif /** * 建立socket * AF_INET 指定使用TCP/IP协议 * SOCK_DGRAM 指定使用UDP协议 */ st = socket(AF_INET, SOCK_DGRAM, 0);&#125;myudp::~myudp()&#123;#ifdef MYLINUX close(st);#else closesocket(st);//关闭socket WSACleanup();//释放win中 socket相关资源#endif&#125;//将接收方和端口号绑定int myudp::socket_bind(short port)&#123; struct sockaddr_in addr; memset(&amp;addr, 0, sizeof(addr));//初始化结构 addr.sin_family = AF_INET; addr.sin_port = htons(port);//host to net short addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY接收方的主机ip int localBind = bind(st, (struct sockaddr *)&amp;addr, sizeof(addr)); return localBind;&#125; main.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include \"udp.h\"#define PORT 8080using namespace std;int main(int argc, char *args[])&#123; if(argc &gt; 1)&#123; myudp udp; char buf[1024] = &#123;0&#125;; while(1)&#123; memset(buf, 0, sizeof(buf)); gets(buf); udp.socket_send(args[1], PORT, buf, strlen(buf)); if(strncmp(buf, \"exit\", 4) == 0) break; &#125; &#125;else&#123; myudp udp; char buf[1024] = &#123;0&#125;; if(udp.socket_bind(PORT) &gt; -1)&#123; cout &lt;&lt; \"bind success !\" &lt;&lt; endl; char ip[100] = &#123;0&#125;; while(1)&#123; memset(buf, 0, sizeof(buf)); memset(ip, 0, sizeof(ip)); udp.socket_recv(buf, sizeof(buf), ip); if(strncmp(buf, \"exit\", 4) == 0) break; cout &lt;&lt; buf &lt;&lt; endl; cout &lt;&lt; ip &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; \"over\" &lt;&lt; endl; return 0;&#125;","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.hsujee.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"}]},{"title":"Awesome-RxJava 学习资料","date":"2016-09-24T16:00:00.000Z","path":"2016/09/25/Android/blog/2016-9-25-Awesome-RxJava 学习资料/","text":"Awesome-RxJava本文摘自：https://github.com/lzyzsd/Awesome-RxJava RxJava resources RxJava 学习资料 给 Android 开发者的 RxJava 详解 -强烈推荐 扔物线的文章 讲解非常详细 NotRxJava懒人专用指南 -这篇入门极力推荐，手把手，深入浅出教你实现一个简易的RxJava库，更好的理解RxJava的实现思路 深入浅出RxJava（一：基础篇） 深入浅出RxJava ( 二：操作符 ) 深入浅出RxJava ( 三–响应式的好处 ) 深入浅出RxJava ( 四-在Android中使用响应式编程 ) 如何升级到RxAndroid1.0 -适合使用Rx 0.x版本的用户升级的时候参考 可能是东半球最全的RxJava使用场景小结 开发者前线翻译的一系列很赞的教程 那些年我们错过的响应式编程 -非常棒的讲解响应式编程的文章。 使用RxJava从多个数据源中加载数据 使用RxJava.Observable取代AsyncTask和AsyncTaskLoader 当复仇者联盟遇上Dragger2、RxJava和Retrofit的巧妙结合 结合RxJava使用SQLite 比钢铁侠反应更灵敏-RxJava 一些不错的介绍操作符的文章 行云流水的博客 Android RxJava使用介绍（二） RxJava的操作符 木水川的博客 RxMarbles-Interactive diagrams of Rx Observables Android RxJava使用介绍（二） RxJava的操作符 一些不错的翻译文章 【译】Deferring Observable code until subscription in RxJava 【译】RxJava Observable tranformation: concatMap() vs flatMap() 【译】Loading data from multiple sources with RxJava 【译】Don’t break the chain: use RxJava’s compose() operator 一些原理分析的文章 彻底搞懂 RxJava — 基础篇 彻底搞懂 RxJava — 中级篇 彻底搞懂 RxJava — 高级篇 书籍 【译】RxJava Essentials 中文翻译版 -Ivan.Morgillo所写一书的中文翻译版本 Test Unit Testing RxJava Observables and Subscriptions Unit Testing RxJava Observables App android-gfycat -Android application that loads gifs via gfycat for efficiency’s sake JakeWharton/u2020 -Jake大神的项目，里面有RxJava和Retrofit一起使用的例子 Avengers - 一个使用Retrofit+RxJava+MVP的app TranslateApp - 一个使用 MVP+Dagger2+RxJava+Retrofit的实现手机端『划词翻译』功能的App - 咕咚翻译 AppPlus - 一个可以用于传送Apk文件，提取APK文件等的工具软件。 rx-android-architecture -Android中使用Rx的一种架构 android-boilerplate -使用RxJava+Retrofit+MVP的app，并了结合详细的测试用例 RxJavaApp -用于学习RxJava操作符的APP Example learnrxjava -RxJava例子 Intro-To-RxJava -RxJava实例入门 MovieGuide-An Android app that showcases the MVP pattern and RxJava RxWeather-Architecting Android with RxJava RxBlur-用RxJava处理和操作高斯模糊效果的简单用例。 RxJava-Android-Samples-Learning RxJava for Android by example Library rx-preferences -使SharedPreferences支持RxJava RxAndroid -RxJava的Android拓展 RxLifecycle -帮助使用了RxJava的安卓应用控制生命周期 RxBinding -安卓UI控件的RxJava绑定API storio -支持RxJava的数据库 retrofit -支持RxJava的网络请求库 sqlbrite -支持RxJava的sqlite数据库 RxPermissions -RxJava实现的Android运行时权限控制 reark -RxJava architecture library for Android frodo -Android Library for Logging RxJava Observables and Subscribers. Stackoverflow When should one use RxJava Observable and when simple Callback on Android? Video droidconDE 2015: Ivan Morgillo – Android reactive programming with Rxjava Common RxJava Mistakes","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"转载","slug":"转载","permalink":"https://blog.hsujee.io/tags/转载/"}]},{"title":"解决Detours编译报错","date":"2016-05-15T16:00:00.000Z","path":"2016/05/16/C_C++/2016-05-16-解决Detours编译报错（在Win10+vs2015开发环境下）/","text":"1、首先去官网下载安装包DetoursExpress30.msi，点击安装 express版本的特点：不能全局拦截，也不能源码级别拦截 2、编译我这里使用Windows10和vs1015，首先打开 所有应用-visual studio 2015-选择vs2015开发人员命令提示进入DetoursExpress30的安装目录cd D:\\Software\\DetourExpress30\\src输入nmake进行编译，出现如下错误 D:\\Software\\DetourExpress30&gt;nmake Microsoft (R) 程序维护实用工具 14.00.23026.0 版 版权所有 (C) Microsoft Corporation。 保留所有权利。 cd &quot;D:\\Software\\DetourExpress30\\src&quot; Created ..\\include Created ..\\lib.X86 Created ..\\bin.X86 Created obj.X86 cl /W4 /WX /Zi /MTd /Gy /Gm- /Zl /Od /DDETOURS_BITS=32 /DWIN32_LEAN_AND_MEAN /D_WIN32_WINNT=0x403 /Gs /DDETOURS_X86=1 /DDETOURS_32BIT=1 /D_X86_ /DDETOURS_OPTION_BITS=64 /Fd..\\lib.X86\\detours.pdb /Foobj.X86\\detours.obj /c .\\detours.cpp 用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.00.23026 版 版权所有(C) Microsoft Corporation。保留所有权利。 detours.cpp C:\\Program Files (x86)\\Windows Kits\\8.1\\include\\um\\dbghelp.h(1544): error C2220: 警告被视为错误 - 没有生成“object”文件 C:\\Program Files (x86)\\Windows Kits\\8.1\\include\\um\\dbghelp.h(1544): warning C4091: “typedef ”: 没有声明变量时忽略“” 的左侧 C:\\Program Files (x86)\\Windows Kits\\8.1\\include\\um\\dbghelp.h(3190): warning C4091: “typedef ”: 没有声明变量时忽略“” 的左侧 .\\detours.cpp(156): warning C4456: “pbNew”的声明隐藏了上一个本地声明 .\\detours.cpp(156): note: to simplify migration, consider the temporary use of /Wv:18 flag with the version of the compiler with which you used to build without warnings .\\detours.cpp(147): note: 参见“pbNew”的声明 .\\detours.cpp(163): warning C4456: “pbNew”的声明隐藏了上一个本地声明 .\\detours.cpp(163): note: to simplify migration, consider the temporary use of /Wv:18 flag with the version of the compiler with which you used to build without warnings .\\detours.cpp(147): note: 参见“pbNew”的声明 .\\detours.cpp(1263): warning C4456: “o”的声明隐藏了上一个本地声明 .\\detours.cpp(1263): note: to simplify migration, consider the temporary use of /Wv:18 flag with the version of the compiler with which you used to build without warnings .\\detours.cpp(1112): note: 参见“o”的声明 NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\cl.EXE&quot;”: 返回代码“0x2” Stop. NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\nmake.exe&quot;”: 返回代码“0x2” Stop. D:\\Software\\DetourExpress30&gt; ①使用文档编辑器打开 D:\\Software\\DetourExpress30\\src\\Makefile文件，搜索找到下面一行 CFLAGS=/W4 /WX /Zi /MTd /Gy /Gm- /Zl /Od /DDETOURS_BITS=$(DETOURS_BITS) 将这一句中的 /WX 删除，如下 CFLAGS=/W4 /Zi /MTd /Gy /Gm- /Zl /Od /DDETOURS_BITS=$(DETOURS_BITS) ②使用文档编辑器打开D:\\Software\\DetourExpress30\\samples\\common.mak 搜索找到下面一行 CFLAGS=/nologo /Zi $(CLIB) /Gm- /W4 /WX /Od /DDETOURS_BITS=$(DETOURS_BITS) 同样删除 /WX CFLAGS=/nologo /Zi $(CLIB) /Gm- /W4 /Od /DDETOURS_BITS=$(DETOURS_BITS) 然后运行nmake就会编译成功打开D:\\Software\\DetourExpress30\\lib.X86 已经生成detours.lib文件","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.hsujee.io/tags/C-C/"},{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"}]},{"title":"Android签名机制用法详解","date":"2016-05-09T16:00:00.000Z","path":"2016/05/10/Android/Tool/2016-05-10- Android签名机制用法详解/","text":"Android独有的安全机制有：权限机制，签名机制，混淆机制等，这里我们来了解签名机制的使用方法签名机制主要作用：升级App，检查权限 升级App 用户在升级一款已经安装过的App时，如果程序的修改来自于同一来源，则允许升级安装，否则会提示签名不一致无法安装的提示。 权限检查 对于申请权限的 protection level 为 signature 或者 signatureOrSystem 的，会检查权限申请者和权限声明者的证书是否是一致的。 生成keystore 1keytool -genkey -alias mykey -keyalg RSA -validity 40000 -keystore demo.keystore 命令说明： 1234567891011121314151617181920212223242526 -genkey 产生密钥 -alias mykey 别名 mykey -keyalg RSA 使用RSA算法对签名加密 -validity 40000 有效期限4000天 -keystore demo.keystore ``` **密钥和证书管理工具命令解释如下（keytool）**```mk -certreq 生成证书请求 -changealias 更改条目的别名 -delete 删除条目 -exportcert 导出证书 -genkeypair 生成密钥对 -genseckey 生成密钥 -gencert 根据证书请求生成证书 -importcert 导入证书或证书链 -importpass 导入口令 -importkeystore 从其他密钥库导入一个或所有条目 -keypasswd 更改条目的密钥口令 -list 列出密钥库中的条目 -printcert 打印证书内容 -printcertreq 打印证书请求的内容 -printcrl 打印 CRL 文件的内容 -storepasswd 更改密钥库的存储口令 对apk进行签名 12[plain] view plain copyjarsigner -verbose -keystore demo.keystore -signedjar test_signed.apk test.apk mykey test_signed.apk是签名之后的文件test.apk是需要签名的文件另外需要注意的是，如果你的jdk版本在1.7以上，你在对apk签名时，需要加上这个参数： 12[plain] view plain copy-digestalg SHA1 -sigalg MD5withRSA 否则会出现：Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]的错误。 签名工具用法:（jarsigner） 1234567891011121314151617181920212223242526jarsigner [选项] jar-file 别名jarsigner -verify [选项] jar-file [别名...][-keystore &lt;url&gt;] 密钥库位置[-storepass &lt;口令&gt;] 用于密钥库完整性的口令[-storetype &lt;类型&gt;] 密钥库类型[-keypass &lt;口令&gt;] 私有密钥的口令 (如果不同)[-certchain &lt;文件&gt;] 替代证书链文件的名称[-sigfile &lt;文件&gt;] .SF/.DSA 文件的名称[-signedjar &lt;文件&gt;] 已签名的 JAR 文件的名称[-digestalg &lt;算法&gt;] 摘要算法的名称[-sigalg &lt;算法&gt;] 签名算法的名称[-verify] 验证已签名的 JAR 文件[-verbose[:suboptions]] 签名/验证时输出详细信息。子选项可以是 all, grouped 或 summary[-certs] 输出详细信息和验证时显示证书[-tsa &lt;url&gt;] 时间戳颁发机构的位置[-tsacert &lt;别名&gt;] 时间戳颁发机构的公共密钥证书[-tsapolicyid &lt;oid&gt;] 时间戳颁发机构的 TSAPolicyID[-altsigner &lt;类&gt;] 替代的签名机制的类名[-altsignerpath &lt;路径列表&gt;] 替代的签名机制的位置[-internalsf] 在签名块内包含 .SF 文件[-sectionsonly] 不计算整个清单的散列[-protected] 密钥库具有受保护验证路径[-providerName &lt;名称&gt;] 提供方名称[-providerClass &lt;类&gt; 加密服务提供方的名称[-providerArg &lt;参数&gt;]]... 主类文件和构造器参数[-strict] 将警告视为错误 查看签名信息 1、查看keystore的信息 12[plain] view plain copykeytool -list -keystore demo.keystore -alias mykey -v 2、查看keystore的公钥证书信息 12[plain] view plain copykeytool -list -keystore demo.keystore -alias mykey -rfc （注：获取Base64格式的公钥证书，RFC 1421） 3、查看apk的签名信息 12[plain] view plain copyjarsigner -verify -verbose -certs &lt;your_apk_path.apk&gt;","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"}]},{"title":"Linux下AS环境配置","date":"2016-03-17T16:00:00.000Z","path":"2016/03/18/Android/Tool/2016-03-18- Linux下AS环境配置/","text":"sudo gedit /etc/profile 12345678910111213141516171819#set jdk environment#jdk1.7.0_25 jdk1.8.0_101export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_101export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATHexport PATH=$JAVA_HOME:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH#set android environmentexport ANDROID_HOME=/home/jerry/Softwares/android-sdk-linuxexport PATH=$PATH:/home/jerry/Softwares/android-sdk-linux/tools/export PATH=$PATH:/home/jerry/Softwares/android-sdk-linux/platform-tools/#set maven environmentexport M2_HOME=/home/jerry/Softwares/myEclipse/apache-maven-3.3.9export PATH=$M2_HOME/bin:$PATH#set tomcat environmentexport TOMCAT_HOME=/home/jerry/Softwares/myEclipse/apache-tomcat-7.0.72export CATALINA_HOME=$TOMCAT_HOMEexport PATH=$TOMCAT_HOME/bin:$PATH 快捷方式sudo gedit /usr/share/applications/Studio.desktop 1234567891011121314151617[Desktop Entry]Name = StudioComment= android studioExec=/home/young/android/android-studio/bin/studio.shIcon=/home/young/android/android-studio/bin/idea.pngTerminal=falseType=Application[Desktop Entry]Type=ApplicationName=Android StudioExec=~/Softwares/android-studio/bin/studio.sh %fIcon=~/Softwares/android-studio/bin/studio.pngCategories=development;IDE;Terminal=falseStartupNotify=trueStartupWMClass=jetbrains-android-studio","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.hsujee.io/tags/Linux/"}]},{"title":"Android技术博客地址收藏","date":"2016-03-09T16:00:00.000Z","path":"2016/03/10/Android/blog/2016-03-10- Android技术博客地址收藏/","text":"2017年初你绝对想尝试的25个新安卓库 Android官方培训课程中文版 国内一线互联网公司内部面试题库 GitHub收藏Android开发技术前线 ( android-tech-frontier ) RXJava学习笔记 Android屏幕适配全攻略（最权威的官方适配指导） 对Android开发者有益的40条优化建议 Android项目源码界面超级华丽的仿QQ最新版本 android各类优化方案 Android程序员个人简历范文 程序员简历应该怎么写 Android程序员简历模板 博客收藏 Werido小胖 weishu博客 阿拉神农,《深入理解Android》系列 工匠若水CSDN博客 有哪些 Android 大牛的 blog 值得推荐？ 《Android系统源代码情景分析》作者老罗的Android之旅 Android M Launcher3主流程源码浅析","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"博客收藏","slug":"博客收藏","permalink":"https://blog.hsujee.io/tags/博客收藏/"}]},{"title":"IdeaVim插件使用技巧","date":"2016-01-12T16:00:00.000Z","path":"2016/01/13/Tools/2016-01-13- IdeaVim插件使用技巧/","text":"在 IDEA Intellij小技巧和插件 一文中简单介绍了一下IdeaVim插件。在这里详细总结一下这个插件在日常编程中的一些常用小技巧。 供有兴趣使用这个插件，但对Vim还不十分熟悉的朋友参考。当然基本的hjkl移动光标和几种常见模式等等基本概念就略过不提了。 为了确保只包含常用操作，这里提到的技巧都没有从现成文档里抄，而是凭记忆列出（不常用自然就不记得了）。 估计会有所遗漏，慢慢再补充。 1. 切换Vim模拟器状态这个插件允许设置一个快捷键一键开启或关闭，在切换模式时会同时自动切换keymap，十分方便。默认键位是Ctrl+Alt+V，但这个键位覆盖了很常用的“抽取局部变量”功能，建议重设，在setting-&gt;keymap中查找VIM Emulator即可。 由于开启和关闭状态分别使用两套keymap，因此两套都需要设定。可以把两套keymap下的都设为一样的键，也就是用同一个键切换。但个人建议设为不同的键，这样能清楚知道当前处于那种模式中。并且，如果在开启Vim的插入模式下关闭Vim模拟器，下次进入时仍然是插入模式，比较混乱（因为你关闭模拟器就是为了使用默认keymap输入大段代码，重新开启Vim模拟器就是为了使用普通模式下的命令）。 因此建议把Vim keymap中的Exit Insert Mode设为与另一个keymap的Vim Emulator相同的键（也就是进入Vim模拟器的快捷键）。 例如，我使用的设定是： Default keymap -&gt; Vim Emulator : Ctrl+; (用Ctrl+分号开启Vim模拟器） Vim keymap -&gt; Vim Emulator : Ctrl+, (用Ctrl+逗号关闭Vim模拟器） Vim keymap -&gt; Vim Emulator : Ctrl+; (用Ctrl+分号退出插入模式，进入普通模式） 这样，在任何时候只要连按两下ctrl+分号，就能保证必定在Vim模拟器的普通模式中。 2. ScrollOff 参数启动Intellij后在Vim模拟器下输入命令 : set so=5 可以令屏幕滚动时在光标上下方保留5行预览代码（也就是光标会在第5行触发向上滚动，或者在倒数第5行触发向下滚动）。 在代码窗口比较狭小时（例如单步跟踪调试时）非常方便。可惜仅在Vim模拟器开启时有效。 3. 行号定位普通模式下输入 行号G 或 :行号&lt;回车&gt; 都能快速定位到某一行。 区别在于前者在输入行号时屏幕上没有任何提示，后者则在Vim命令输入框中可以看到输入过程。 （题外话：Sublime Text 2也是用 :行号 来快速定位到某行，应该是沿用了Vim的习惯） 4. 进入修改进入插入模式的方式有很多，直接选用合适的方式进入插入模式比进入后再用箭头键移动光标要好。常用的有： o - 在当前行下方插入新行并自动缩进 O - 在当前行上方插入新行并自动缩进 （普通模式下的大写字母命令用 shift+字母键 输入，下同） i - 在当前字符左方开始插入字符 a - 在当前字符右方开始插入字符 I - 光标移动到行首并进入插入模式 A - 光标移动到行尾并进入插入模式 s - 删除光标所在字符并进入插入模式 S - 删除光标所在行并进入插入模式 c&lt;范围&gt; - 删除光标所在位置周围某个范围的文本并进入插入模式。关于范围请看第5点，常用的组合有：caw - 删除一个单词包括它后面的空格并开始插入； ciw - 删除一个单词并开始插入； ci&quot; - 删除一个字符串内部文本并开始插入； c$ - 从光标位置删除到行尾并开始插入； ct字符 - 从光标位置删除本行某个字符之前（保留该字符）并开始插入。等等。 C - 删除光标位置到行尾的内容并进入插入模式 (相当于c$) r - 修改光标所在字符，然后返回普通模式 R - 进入覆盖模式 5. 范围操作某些普通模式的动作命令后面可以追加一些表示范围的指令，表示该动作将作用在整个范围上。这类命令常用的有： d&lt;范围&gt; - 删除一定范围内的文本 c&lt;范围&gt; - 删除一定范围内的文本并进入插入模式 y&lt;范围&gt; - 将范围内的文本放入0号和&quot;号注册栏 v&lt;范围&gt; - 选择范围内的文本 =&lt;范围&gt; - 自动缩进范围内的文本 gU&lt;范围&gt; - 将范围内的字符转换为大写 gu&lt;范围&gt; - 将范围内的字符转换为小写 &gt;&lt;范围&gt; - 将范围中的内容缩进一格 &lt;&lt;范围&gt; - 将范围中的内容取消缩进一格 常用的范围指令有： 空格 - 光标所在位置字符。（例如 gU空格 - 将光标位置字符转为大写） 重复某些动作命令 - 光标所在行。 （例如dd删除一行，yy复制一行，cc删除一行文本并开始插入，&gt;&gt; 当前行缩进一格，==自动缩进当前行） $ - 从光标位置到行尾 ^ - 从光标位置到行首，不包含缩进空白 0 - 从光标位置到行首，包含缩进空白 gg - 从光标位置到文件开头 G - 从光标位置到文件结尾 % - 从光标位置到另一边匹配的括号 f&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 t&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 /正则表达式 - 从光标位置到下一个匹配正则表达式的位置（跨行） ?正则表达式 - 从光标位置到上一个匹配正则表达式的位置（跨行） aw - 一个单词加一个空格 （a可理解为“一个”，下同） iw - 一个单词 （i可理解为in，下同） a&quot; - 一个字符串包括双引号 i&quot; - 一个字符串内部文本 a&lt; - 一组&lt; &gt;包含的文本，包括&lt; &gt;号本身 同理类推： i&lt;, a[, i[, a(, i( 注意：真正vim中的it范围（一对xml标签内部）在ideaVim中不生效。 用/或?命令查找时，正则表达式默认大小写敏感，如果需要不敏感，可以在正则表达式开始处加上\\c标志。 例如 /\\cabc 可以匹配到 ABC。下面提到的:s命令同样适用。 6. 选择文本在Vim中，选择文本需要进入“可视模式”（Visual Mode），这个名称比较奇怪，它的来由据说是因为在Vim的前身Vi中，选择区域是不可见的。 在Vim中选择区域会高亮显示，因此称为“可视模式”。 v - 进入字符选择模式， V - 进入行选择模式， Ctrl+v - 进入块选择模式。 进入相应模式后移动光标即可选中文本。过程中可按o键令光标在选区两端切换。 在块选择模式中选中多行，然后按I或A后输入文本，再退出插入模式，所输入的文本将自动加入到每一行的开头或结尾。 7. 复制粘贴在Vim模式下，复制粘贴并不直接使用系统的剪贴板，而是使用Vim提供的多个“寄存器”，每个寄存器都以一个字符来表示。 关于寄存器的详细说明可以看这里 http://blah.blogsome.com/2006/04/27/vim_tut_register/ （随便google的一个网页），这里简单列一些常用的操作技巧 （注意，vim使用双引号”来作为选择寄存器的命令，因此下文中的双引号均指在普通模式下按双引号键）： a）用y命令将文本存入寄存器后，如果想在别处替换原有内容，可以先用v命令选中原有内容，然后用p命令粘贴。 但第一次粘贴后，默认的寄存器”将被替换为刚刚删除的内容。如果要再次粘贴之前复制的内容，需要使用 “0p 命令组合来复制。 也可以进入插入模式后用 Ctrl+r 0 来复制，例如 ciw0 命令组合将用粘贴内容替换光标处的一个单词，并停留在插入模式。 b）在Windows下，寄存器 + 和 * 都代表系统剪贴板，可以互换使用，选一个顺手的即可。 例如 “+yy 命令组合可将当前行复制到系统剪贴板。 ci”* 命令组合则将系统剪贴板的内容替换字符串的内部文本。 c) 寄存器1至9记录之前九次的删除大段文本，每次超过一行的删除操作都会导致这9个寄存器的内容发生位移，最近删除的文本会存入寄存器1。 但只有删除超过1行时才会影响寄存器1至9，行内的删除内容则会被存入寄存器-（减号）。 如果用q命令录制宏时不涉及跨行删除，可以在宏中直接使用这9个寄存器来暂存文本。 （在Vim中，复制内容与录制宏共享同一套寄存器，因此我习惯把字母寄存器留给宏使用） d) 普通模式下小写p把寄存器内容复制到当前位置之后，大写P把寄存器内容复制到当前位置之前。 e) 使用 :regs 命令可以列出当前所有寄存器的内容 8.一些插入模式下的常用快捷键Ctrl+h - 删除光标左边字符 Ctrl+w - 删除光标左边的单词 Ctrl+y - 复制上方的一个字符 Ctrl+e - 复制下方的一个字符 Ctrl+r 0 - 插入前一次用y命令寄存的内容 Ctrl+r * - 插入系统剪贴板的内容 Ctrl+r &lt;寄存器名称&gt; - 插入指定寄存器的内容 Ctrl+a - 插入前一次插入模式所键入的内容 Ctrl+o - 执行一个普通模式下的命令然后返回插入模式。 例如 Ctrl+o A 相当于按 End键， Ctrl+o I相当于按Home键 9. 退出插入模式退出插入模式可以用 ESC 键，但键位太远。其实也可以用 Ctrl+[ 键退出插入模式 。 当然也可以用第1点自定义的Ctrl+;快捷键，但这不是标准vim按键，会养成不良习惯，不建议使用。 10. 重复操作普通模式下按. （小数点）可重复上一次的修改操作 &amp; - 重复上一次的:s替换命令 @@ - 重复上一次执行的宏 11. 跳转Ctrl+] 跳转到当前标识符的定义位置 （相当于在当前光标位置的单词上按住ctrl用鼠标点击） Ctrl+o 回退一步 (go back) Ctrl+i 前进一步 (go forward) `. 跳转到之前修改位置 `` 在前一次跳转位置与当前位置间切换 行号G 或 :行号&lt;回车&gt; 跳转到某一行 gg 跳转到文件开头 G 跳转到文件末尾 H 跳转到屏幕顶端（如果设置了set so=n，则跳转到第n行） L 跳转到屏幕底端（如果设置了set so=n，则跳转到倒数第n行） M 跳转到屏幕中间 f 或 F 跳转到本行某个字符，小写f向右查找，大写F向左查找。用;或,在匹配间切换 t 或 T 跳转到本行某个字符之前，小写t向右查找，大写T向左查找。用;或,在匹配间切换 /正则表达式 跳转到下一个匹配。用n或N在匹配间切换。 ?正则表达式 跳转到上一个匹配。用n或N在匹配间切换。 （结合前面第5点，你也许注意到了，在指定范围时，使用跳转命令将指定一个从光标位置到跳转目标的区域） 12 书签在普通模式下按 m&lt;小写字母&gt; 即可定义书签，按 `&lt;字母&gt; 则可跳转到某个书签的精确位置，按 ‘&lt;字母&gt;可跳转到某个书签所在行的行首（用来录制宏时比较有用）。 最常用的自然是mm, mn, mj, mk, ml这几个顺手的键位。 真正的vim中的全局书签 m&lt;大写字母&gt; 在目前IdeaVim版本中不生效。需要定义全局书签可以使用Idea原本的 F11 + 数字 方式 13 文本替换使用 :s/正则表达式/替换文本/ 可在本行内替换首次出现的匹配 使用 :s/正则表达式/替换文本/g 在本行内替换所有出现的匹配 使用 :%s/正则表达式/替换文本/g 在当前文件内替换所有出现的匹配 在可视模式下选中文本后，使用:’&lt;,’&gt;s/正则表达式/替换文本/g 命令可在选中区域中替换文本。 其中’&lt;,’&gt;部分在可视模式下，按:冒号后自动加入，直接输入s命令即可。但有效区域只能以行为单位。 真正Vim中的 \\%V 标志在IdeaVim中不生效。 11 代码折叠zo - 打开折叠 zc - 关闭折叠 14 宏定义在IdeaVim中定义宏比Idea自带的宏功能要轻量许多。 按在普通模式下 q&lt;寄存器名称&gt; 即可开始把后续按键序列录制到指定寄存器中（寄存器参考前面第7条）。录制完毕进入普通模式再按q键即可停止录制。 之后用 @&lt;寄存器名称&gt; 即可重放。需要注意的是宏和复制粘贴共用一套寄存器，因此在录制宏时就注意不要把当前宏正在使用的寄存器用来复制了。 寄存器内容是自动保存的，重启Idea仍然生效。但IdeaVim没有导出宏独立保存的功能。因此最好把用来保存宏的寄存器和用来复制粘贴的寄存器分开，不要同一个寄存器有时用来记录宏，有时用来复制粘贴。我的习惯是键盘左手区用来保存一些长期使用的宏（比如说我有一个宏专门用来把pom.xml中的版本号抽取到property区域，原来的位置则改用${property}引用）。 右手区的hjklnm键用来保存一些临时宏。yuiop五个寄存器保留用来复制粘贴。如果录制的宏不涉及删除大段代码，寄存器1至9也可以用来进行复制粘贴。 执行一次宏后，可以用@@命令重复上一次执行的宏。 在Idea中录制宏时，如果触发了代码自动完成，在自动完成列表启动的状态输入的字符不会被记录。因此最好在Setting -&gt; Code Completion -&gt; Autopopup code completion中把延迟设为500ms以上或干脆关掉。在录制宏的过程中避免触发代码自动完成功能。 录制一些长期有效的宏时，开始录制后，最好先用0，^，T, F, $等命令把光标对齐到行首行末或某个特定起始位置（比如说用 F” 跳转到字符串的左边引号），再用一个f或/指令跳转到操作位置，这样的宏就不用必须把光标放在某个特定字符才能使用了。 15. 一些常用组合技全选： ggvG 调换两个字符位置： xp 复制一行： yyp 调换两行位置： ddp 插入模式下到行尾继续输入（相当于End键）： Ctrl+o A 或 Ctrl+[ A 插入模式下到行首继续输入（相当于Home键）： Ctrl+o I 或 Ctrl+[ I 到类定义位置（适用于正确缩进的public，protected类） ： ?^p回车 16. 一些在目前版本已知没有实现的一些常用Vim功能（如果对Vim不熟悉可以跳过这节） a）let命令 （没有let命令就无法导出/导入寄存器内容，也就是无法导入宏） b）:g命令 （在文本处理中很有用的一个命令，在编程中倒是不那么常用） c）!命令 （执行shell命令） d）大部分正则表达式标记 （例如 \\%V， \\v 等等） e) 某些多键命令双击最后一个字符表示作用于当前行。例如在Vim中gUU可以把当前行转换为大写，在IdeaVim中无效，实现同样功能可以先用V命令选中当前行，再用gU转换为大写。 f）关于窗口操作的大部分命令 （Ctrl+w系列命令, :split等） g）所有Vim脚本插件 （不过大部分可以用Idea自身的功能和插件来补偿） 嗯，差点忘了，在普通模式下按u撤销上一个修改（相当于其他IDE的Ctrl+z），按Ctrl+r重做被撤销的修改。","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"}]},{"title":"AS混淆打包","date":"2015-07-10T16:00:00.000Z","path":"2015/07/11/Android/Tool/2015-07-11- AS混淆打包/","text":"Android Studio中的项目可以用compile的形式引入github上的开源项目，可以引用module，而不一定都要用libs文件夹中添加jar包的形式。 在最终realease打包时，混淆的设置是比较重要的，否则会导致生成的包有很多功能不能正常使用。下面列举一个基本的app的build.gradle和混淆文件。并注意，混淆打包后的apk文件大小会比不使用混淆要小。 在app根目录下设置build.gradle和混淆文件，然后把混淆选项写入混淆文件就可以。虽然app项目中可能引用了一些module，但这些module工程可以不定义自己的混淆，我的工程目录结构如下： 其中app是应用主模块，引用剩余的module，被引用module的build.gradle中都使用默认的设置不启用混淆： 123456buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 在主目录的build.gradle: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103apply plugin: 'com.android.application'def releaseTime() &#123; return new Date().format(\"yyyy-MM-dd\", TimeZone.getTimeZone(\"UTC\"))&#125;repositories &#123; maven &#123; url 'https://oss.sonatype.org/content/repositories/snapshots' &#125;&#125;android &#123; compileSdkVersion 22 buildToolsVersion '22.0.1' defaultConfig &#123; applicationId \"com.*****.****\" //自己的applicationId minSdkVersion 14 targetSdkVersion 19 versionCode 1 versionName \"1.0\" &#125; //执行lint检查，有任何的错误或者警告提示，都会终止构建，我们可以将其关掉。 lintOptions &#123; abortOnError false &#125; //签名 signingConfigs &#123; debug &#123; &#125; release &#123;// 自己的签名文件 storeFile file(\"doc/****.jks\") storePassword \"******\" keyAlias \"******\" keyPassword \"******\" &#125; &#125; buildTypes &#123; debug &#123; // 显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\" versionNameSuffix \"-debug\" minifyEnabled false zipAlignEnabled false shrinkResources false signingConfig signingConfigs.debug &#125; release &#123; // 不显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\" //混淆 minifyEnabled true //Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true //前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //签名 signingConfig signingConfigs.release applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为app_v1.0_2015-xx-xx_xxxx.apk //def fileName = \"app_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;.apk\" def fileName = \"app_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; //渠道Flavors，配置不同风格的app,友盟渠道统计时用到 productFlavors &#123; \"offical\" &#123;&#125; \"360\" &#123;&#125; yingyongbao &#123;&#125; wandoujia &#123;&#125; baidu &#123;&#125; \"91\" &#123;&#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile project(':appsdk') compile 'com.jakewharton:butterknife:7.0.1' //compile 'com.faradaj:blur-behind:1.1' compile 'com.github.ksoichiro:android-observablescrollview:1.6.0' compile 'com.nineoldandroids:library:2.4.0' compile 'in.srain.cube:ultra-ptr:1.0.10' compile 'com.android.support:cardview-v7:22.1.0' compile project(':multi-image-selector')&#125; proguard-rules.pro文件中则定义了项目的混淆选项，定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207# Add project specific ProGuard rules here.# By default, the flags in this file are appended to flags specified# in D:\\Android\\sdk/tools/proguard/proguard-android.txt# You can edit the include path and order by changing the proguardFiles# directive in build.gradle.## For more details, see# http://developer.android.com/guide/developing/tools/proguard.html# Add any project specific keep options here:# If your project uses WebView with JS, uncomment the following# and specify the fully qualified class name to the JavaScript interface# class:-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;#指定代码的压缩级别-optimizationpasses 5#包明不混合大小写-dontusemixedcaseclassnames#不去忽略非公共的库类-dontskipnonpubliclibraryclasses #优化 不优化输入的类文件-dontoptimize #预校验-dontpreverify #混淆时是否记录日志-verbose # 混淆时所采用的算法-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*#保护注解-keepattributes *Annotation*# 保持哪些类不被混淆-keep public class * extends android.app.Fragment-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class com.android.vending.licensing.ILicensingService#如果有引用v4包可以添加下面这行-keep public class * extends android.support.v4.app.Fragment#忽略警告-ignorewarning##记录生成的日志数据,gradle build时在本项目根目录输出###apk 包内所有 class 的内部结构-dump proguard/class_files.txt#未混淆的类和成员-printseeds proguard/seeds.txt#列出从 apk 中删除的代码-printusage proguard/unused.txt#混淆前后的映射-printmapping proguard/mapping.txt########记录生成的日志数据，gradle build时 在本项目根目录输出-end#######如果引用了v4或者v7包-dontwarn android.support.**####混淆保护自己项目的部分代码以及引用的第三方jar包library-end#####保持 native 方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保持自定义控件类不被混淆-keepclasseswithmembers class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet);&#125;#保持自定义控件类不被混淆-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;-keep public class * extends android.view.View &#123; public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); public void set*(...);&#125;#保持 Parcelable 不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;#保持 Serializable 不被混淆-keepnames class * implements java.io.Serializable#保持 Serializable 不被混淆并且enum 类也不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;#保持枚举 enum 类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keepclassmembers class * &#123; public void *ButtonClicked(android.view.View);&#125;#不混淆资源类-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;#避免混淆泛型 如果混淆报错建议关掉#-keepattributes Signature#移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用，另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制#-assumenosideeffects class android.util.Log &#123;# public static *** v(...);# public static *** i(...);# public static *** d(...);# public static *** w(...);# public static *** e(...);#&#125;##################################################################################################################### 以上通用 ###################################################################################################################################################### 常用第三方模块的混淆选项 ####################################gson#如果用用到Gson解析包的，直接添加下面这几行就能成功混淆，不然会报错。-keepattributes Signature# Gson specific classes-keep class sun.misc.Unsafe &#123; *; &#125;# Application classes that will be serialized/deserialized over Gson-keep class com.google.gson.** &#123; *; &#125;-keep class com.google.gson.stream.** &#123; *; &#125;#mob-keep class android.net.http.SslError-keep class android.webkit.**&#123;*;&#125;-keep class cn.sharesdk.**&#123;*;&#125;-keep class com.sina.**&#123;*;&#125;-keep class m.framework.**&#123;*;&#125;-keep class **.R$* &#123;*;&#125;-keep class **.R&#123;*;&#125;-dontwarn cn.sharesdk.**-dontwarn **.R$*#butterknife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;######引用的其他Module可以直接在app的这个混淆文件里配置# 如果使用了Gson之类的工具要使被它解析的JavaBean类即实体类不被混淆。-keep class com.matrix.app.entity.json.** &#123; *; &#125;-keep class com.matrix.appsdk.network.model.** &#123; *; &#125;#####混淆保护自己项目的部分代码以及引用的第三方jar包library########如果在当前的application module或者依赖的library module中使用了第三方的库，并不需要显式添加规则#-libraryjars xxx#添加了反而有可能在打包的时候遭遇同一个jar多次被指定的错误，一般只需要添加忽略警告和保持某些class不被混淆的声明。#以libaray的形式引用了开源项目,如果不想混淆 keep 掉，在引入的module的build.gradle中设置minifyEnabled=false-keep class com.nineoldandroids.** &#123; *; &#125;-keep interface com.nineoldandroids.** &#123; *; &#125;-dontwarn com.nineoldandroids.**# 下拉刷新-keep class in.srain.cube.** &#123; *; &#125;-keep interface in.srain.cube.** &#123; *; &#125;-dontwarn in.srain.cube.**# observablescrollview：tab fragment-keep class com.github.ksoichiro.** &#123; *; &#125;-keep interface com.github.ksoichiro.** &#123; *; &#125;-dontwarn com.github.ksoichiro.** 然后执行build的release打包，会在app目录下生成一个proguard文件夹，里面有混淆前后文件的映射信息等文本文件，以后bug定位就靠它了：","tags":[{"name":"Android","slug":"Android","permalink":"https://blog.hsujee.io/tags/Android/"},{"name":"打包","slug":"打包","permalink":"https://blog.hsujee.io/tags/打包/"}]},{"title":"Java代码获取汉字首字母","date":"2015-05-16T16:00:00.000Z","path":"2015/05/17/Java/2015-05-17- Java代码获取汉字首字母/","text":"方法1 public class PinYin2Abbreviation { // 简体中文的编码范围从B0A1（45217）一直到F7FE（63486） private static int BEGIN = 45217; private static int END = 63486; // 按照声 母表示，这个表是在GB2312中的出现的第一个汉字，也就是说“啊”是代表首字母a的第一个汉字。 // i, u, v都不做声母, 自定规则跟随前面的字母 private static char[] chartable = {&apos;啊&apos;, &apos;芭&apos;, &apos;擦&apos;, &apos;搭&apos;, &apos;蛾&apos;, &apos;发&apos;, &apos;噶&apos;, &apos;哈&apos;, &apos;哈&apos;, &apos;击&apos;, &apos;喀&apos;, &apos;垃&apos;, &apos;妈&apos;, &apos;拿&apos;, &apos;哦&apos;, &apos;啪&apos;, &apos;期&apos;, &apos;然&apos;, &apos;撒&apos;, &apos;塌&apos;, &apos;塌&apos;, &apos;塌&apos;, &apos;挖&apos;, &apos;昔&apos;, &apos;压&apos;, &apos;匝&apos;,}; // 二十六个字母区间对应二十七个端点 // GB2312码汉字区间十进制表示 private static int[] table = new int[27]; // 对应首字母区间表 private static char[] initialtable = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;t&apos;, &apos;t&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;,}; // 初始化 static { for (int i = 0; i &lt; 26; i++) { table[i] = gbValue(chartable[i]);// 得到GB2312码的首字母区间端点表，十进制。 } table[26] = END;// 区间表结尾 } // ------------------------public方法区------------------------ // 根据一个包含汉字的字符串返回一个汉字拼音首字母的字符串 最重要的一个方法，思路如下：一个个字符读入、判断、输出 public static String cn2py(String SourceStr) { String Result = &quot;&quot;; int StrLength = SourceStr.length(); int i; try { for (i = 0; i &lt; StrLength; i++) { Result += Char2Initial(SourceStr.charAt(i)); } } catch (Exception e) { Result = &quot;&quot;; e.printStackTrace(); } return Result; } // ------------------------private方法区------------------------ /** * 输入字符,得到他的声母,英文字母返回对应的大写字母,其他非简体汉字返回 &apos;0&apos; * */ private static char Char2Initial(char ch) { // 对英文字母的处理：小写字母转换为大写，大写的直接返回 if (ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;) { return (char) (ch - &apos;a&apos; + &apos;A&apos;); } if (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) { return ch; } // 对非英文字母的处理：转化为首字母，然后判断是否在码表范围内， // 若不是，则直接返回。 // 若是，则在码表内的进行判断。 int gb = gbValue(ch);// 汉字转换首字母 if ((gb &lt; BEGIN) || (gb &gt; END))// 在码表区间之前，直接返回 { return ch; } int i; for (i = 0; i &lt; 26; i++) {// 判断匹配码表区间，匹配到就break,判断区间形如“[,)” if ((gb &gt;= table[i]) &amp;&amp; (gb &lt; table[i + 1])) { break; } } if (gb == END) {// 补上GB2312区间最右端 i = 25; } return initialtable[i]; // 在码表区间中，返回首字母 } /** * 取出汉字的编码 cn 汉字 */ private static int gbValue(char ch) {// 将一个汉字（GB2312）转换为十进制表示。 String str = new String(); str += ch; try { byte[] bytes = str.getBytes(&quot;GB2312&quot;); if (bytes.length &lt; 2) { return 0; } return (bytes[0] &lt;&lt; 8 &amp; 0xff00) + (bytes[1] &amp; 0xff); } catch (Exception e) { return 0; } } public static void main(String[] args) throws Exception { System.out.println(cn2py(&quot;重庆重视发展IT行业，大多数外企，如，IBM等进驻山城&quot;)); } } 方法2 怎样获取中文字串的首字母？ GB2312我想提取一串中文的拼音的首字母的集合，应该怎么办？例如：我是中国人 提取出 wszgr /** * Created by jerry on 16-10-9. */ public class ChineseLetter { // 国标码和区位码转换常量 private static final int GB_SP_DIFF = 160; // 存放国标一级汉字不同读音的起始区位码 private static final int[] secPosValueList = { 1601, 1637, 1833, 2078, 2274, 2302, 2433, 2594, 2787, 3106, 3212, 3472, 3635, 3722, 3730, 3858, 4027, 4086, 4390, 4558, 4684, 4925, 5249, 5600 }; // 存放国标一级汉字不同读音的起始区位码对应读音 private static final char[] firstLetter = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos; }; // 获取一个字符串的拼音码 public static String getFirstLetter(String oriStr) { String str = oriStr.toLowerCase(); StringBuffer buffer = new StringBuffer(); char ch; char[] temp; for (int i = 0; i &lt; str.length(); i++) { // 依次处理str中每个字符 ch = str.charAt(i); temp = new char[] { ch }; byte[] uniCode = new String(temp).getBytes(); if (uniCode[0] &lt; 128 &amp;&amp; uniCode[0] &gt; 0) { // 非汉字 buffer.append(temp); } else { buffer.append(convert(uniCode)); } } return buffer.toString(); } // 获取一个汉字的首字母 public static char convert(byte[] bytes) { char result = &apos;-&apos;; int secPosValue = 0; int i; for (i = 0; i &lt; bytes.length; i++) { bytes[i] -= GB_SP_DIFF; } secPosValue = bytes[0] * 100 + bytes[1]; for (i = 0; i &lt; 23; i++) { if (secPosValue &gt;= secPosValueList[i] &amp;&amp; secPosValue &lt; secPosValueList[i + 1]) { result = firstLetter[i]; break; } } return result; } public static void main(String[] args) { System.out.println(ChineseLetter.getFirstLetter(&quot;我是中国人&quot;)); } } 输出结果：wszgr","tags":[{"name":"编程","slug":"编程","permalink":"https://blog.hsujee.io/tags/编程/"},{"name":"Java","slug":"Java","permalink":"https://blog.hsujee.io/tags/Java/"}]},{"title":"Hexo博客yilia模板配置","date":"2015-05-09T16:00:00.000Z","path":"2015/05/10/Hoxe/2015-05-10-Hexo博客yilia模板配置/","text":"配置环境 安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须） 作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装Hexo Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 执行如下命令安装Hexo： 1sudo npm install -g hexo 初始化然后，执行init命令初始化hexo,命令： 1hexo init 好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面 1hexo generate（hexo g也可以） 本地启动 启动本地服务，进行文章预览调试，命令： 1hexo server 浏览器输入http://localhost:4000 我不知道你们能不能，反正我不能，因为我还有环境没配置好 配置Github 建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有： 123_config.yml node_modules public sourcedb.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： 1vim _config.yml 翻到最下面，改成我这样子的 1234567deploy: type: git repo: https://github.com/leopardpan/leopardpan.github.io.git branch: master 然后执行命令： 1npm install hexo-deployer-git --save 网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令： 1hexo deploy 然后再浏览器中输入http://leopardpan.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了 部署步骤 每次部署的步骤，可按以下三步来进行。 12345hexo cleanhexo generatehexo deploy 一些常用命令： 12345678910111213hexo new\"postName\" #新建文章hexo new page\"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 E:\\Blog_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 徐彦杰的博客subtitle: 如果真有奇迹,那只是努力的另一个名字description: Yanjie.Xu Worldauthor: 墨迹流韶email: xuyjcode@gmail.comlanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://blog.cocoper.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/hchjerry/hchjerry.github.io.git branch: mastersitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmfeed: type: atom path: atom.xml limit: 100jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: true tags: true E:\\Blog\\themes\\yilia_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# Headermenu: 主页: / 博客: /archives 相册: /photos #随笔: /tags# SubNavsubnav: github: \"https://github.com/hchjerry\" weibo: \"http://weibo.com/hchjerry\" #rss: \"#\" #zhihu: \"#\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #segmentfault: \"#\" #bilibili: \"#\" #acfun: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: ''google_analytics: ''favicon: /favicon.png#你的头像urlavatar: /img/head.jpg#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#4A708B' # 右滑板块背景 slider: 'linear-gradient(200deg,#d1e3eb,#4A708B)'# slider的设置slider: # 是否默认展开tags板块 showTags: false # 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '博客' friends: '友链' aboutme: '关于我' #tagcloud: '标签云'friends: 百度: http://www.baidu.com #tagcloud: true aboutme: &lt;div id=\"nav\"&gt; 邮箱：xuyanjie@cocoper.com &lt;br&gt;&lt;br&gt; QQ：825194169 &lt;br&gt;&lt;br&gt; &lt;a href=\"http://blog.csdn.net/github_19529589\" target=\"_blank\"&gt;CSDN博客&lt;/a&gt; &lt;/div&gt; E:\\Blog\\themes\\yilia\\layout_partial\\left-col.ejs 12345&lt;!-- 开启网易云播放器 --&gt;&lt;nav class=\"header-music\"&gt; &lt;!--&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=400 src=\"//music.163.com/outchain/player?type=0&amp;id=509985151&amp;auto=0&amp;height=380\"&gt;&lt;/iframe&gt;--&gt; &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=110 src=\"//music.163.com/outchain/player?type=0&amp;id=509985151&amp;auto=0&amp;height=90\"&gt;&lt;/iframe&gt;&lt;/nav&gt; E:\\Blog\\themes\\yilia\\source\\main.05aabf.css 12345.header-music &#123; position:fixed; bottom:0;&#125;","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"应用","slug":"应用","permalink":"https://blog.hsujee.io/tags/应用/"}]},{"title":"Svn常用的命令","date":"2015-03-26T16:00:00.000Z","path":"2015/03/27/Tools/2015-03-27- SVN常用的命令/","text":"1、将文件checkout到本地目录 svn checkout path（path是服务器上的目录） 例如：svn checkout svn://192.168.1.1/pro/domain 简写：svn co 2、往版本库中添加新的文件 svn add file 例如：svn add test.php(添加test.php) svn add *.php(添加当前目录下所有的php文件) 3、将改动的文件提交到版本库 svn commit -m “LogMessage” [-N] [–no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关) 例如：svn commit -m “add test file for my test” test.php 简写：svn ci 4、加锁/解锁 svn lock -m “LockMessage” [–force] PATH 例如：svn lock -m “lock test file” test.php svn unlock PATH 5、更新到某个版本 svn update -r m path 例如： svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200) svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit) 简写：svn up 6、查看文件或者目录状态 1）svn status path（目录下的文件和子目录的状态，正常状态不显示） 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 2）svn status -v path(显示文件和子目录状态) 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 简写：svn st 7、删除文件 svn delete path -m “delete test fle” 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file” 或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种 简写：svn (del, remove, rm) 8、查看日志 svn log path 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、查看文件详细信息 svn info path 例如：svn info test.php10、比较差异 svn diff path(将修改的文件与基础版本比较) 例如：svn diff test.php svn diff -r m:n path(对版本m和版本n比较差异) 例如：svn diff -r 200:201 test.php 简写：svn di 11、将两个版本之间的差异合并到当前文件 svn merge -r m:n path 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、SVN 帮助 svn help svn help ci 以上是常用命令，下面写几个不经常用的 ——————— 13、版本库下的文件和目录列表 svn list path 显示path目录下的所有属于版本库的文件和目录 简写：svn ls 14、创建纳入版本控制下的新目录 svn mkdir: 创建纳入版本控制下的新目录。 用法: 1、mkdir PATH… 2、mkdir URL… 15、恢复本地修改 svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert: 用法: revert PATH… 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复 被删除的目录 16、代码库URL变更 svn switch (sw): 更新工作副本至不同的URL。 用法: 1、switch URL [PATH] 2、switch --relocate FROM TO [PATH...] 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 方法。 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用 这个命令更新工作副本与仓库的对应关系。 17、解决冲突 svn resolved: 移除工作副本的目录或文件的“冲突”状态。 用法: resolved PATH… 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的 相关文件，然后让 PATH 可以再次提交。 18、输出指定文件或URL的内容。 svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。 svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"版本控制","slug":"版本控制","permalink":"https://blog.hsujee.io/tags/版本控制/"}]},{"title":"Git常用的命令","date":"2015-03-26T16:00:00.000Z","path":"2015/03/27/Tools/2015-03-27- Git常用的命令/","text":"在提交时解决冲突的方式 使用git pull拉取文件时，如果本地和远程仓库的文件之间有冲突的时候，会出现如下提示： error: Your local changes to the following files would be overwritten by merge: protected/config/main.cpp Please, commit your changes or stash them before you can merge. 上面提示中列出产生冲突的文件，那么我们就需要执行下面命令进行文件合并，解决冲突 git stash //暂存本地的修改 git pull //拉取远程仓库文件到本地 git stash pop //弹出本地修改暂存 这时候就会提示auto-merged 文件已经自动合并 git diff -w +文件名 //查看文件合并情况 运行上面命令查看，就可以看到文件中增加了如下标记 &lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream //远端仓库修改 ======= //分隔符 &gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes //本地修改 然后使用vi等编辑器对文件进行编辑，修改到你想要的结果，并且删除所有冲突标记 然后再命令行正常流程进行提交即可 如果希望用代码库中的文件完全覆盖本地工作版本 git reset --hard git pull 单个文件覆盖 git checkout HEAD file/to/restore 查看、添加、提交、删除、找回，重置修改文件 git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot; git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diff git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异 git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异 git diff --cached # 比较暂存区和版本库差异 git diff --stat # 仅仅比较统计信息 查看提交记录 git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支 git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br --merged # 查看已经被合并到当前分支的分支 git br --no-merged # 查看尚未被合并到当前分支的分支 git co &lt;branch&gt; # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d &lt;branch&gt; # 删除某个分支 git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase git merge &lt;branch&gt; # 将branch分支合并到当前分支 git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用) git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理 git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理 git pull # 抓取远程仓库所有分支更新并合并到本地 git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理 GitHub git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库 git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch --set-upstream master origin/master git branch --set-upstream develop origin/develop","tags":[{"name":"工具","slug":"工具","permalink":"https://blog.hsujee.io/tags/工具/"},{"name":"版本控制","slug":"版本控制","permalink":"https://blog.hsujee.io/tags/版本控制/"}]}]