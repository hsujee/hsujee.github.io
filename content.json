[{"title":"ContactsProvider 数据库操作","date":"2017-06-09T16:00:00.000Z","path":"2017/06/10/Android/Provider/2017-06-10-Android联系人代码分析/","text":"通过之前的文章对联系人以及联系人数据做了大概的了解和梳理，这里继续深入到联系人的数据存储做出相应总结 数据结构一条Contact数据是由此账户下的所有raw contacts组合起来生成的，方便手机某一用户的所有信息，用户不允许增加Contact（只能增加raw contacts）。通常联系人应用中看到的联系人用的就是 contacts 表中的一条记录。一个 contact 可以拥有多个 raw contacts，这时候点击这个联系人的编辑界面，就会发现可以同时编辑多个 raw contacts.这边所谓的组合，也就是 raw contacts 的 contact_id，只是让这几个 raw contacts 在界面上组合起来显示，本身的数据还是完全独立的。Contacts Provider 通过 ContactsContract.RawContacts 表中的 _ID 列将 contacts 表中的数据和 raw contacts 表中的数据链接起来。 ContactsContract.RawContacts 表中 CONTACT_ID 的值就是 contacts 表中的 _ID，说明这条 raw contact 记录属于_ID所在的这个联系人。下面是Contact数据组成关系图 访问权限、用户私密信息访问读取权限：android.permission.READ_CONTACTS修改权限：android.permission.WRITE_CONTACTSContactsContract.Profile定义私密信息ProfileProvider继承自AbstractContactsProvider，负责对用户私密信息数据的操作想要访问用户私密信息除了以上两个权限还需要添加READ_PROFILE和WRITE_PROFILE两个权限 同步适配器主要用来同步Web服务器上的用户数据Contacts Provider 为了处理设备和服务器之间的同步做了特别的设计。允许用户从服务器下载数据，并且也可以上传数据。同步使得设备端总能有最新的数据，不管数据源发生什么变化。同步的另一个好处是即使没有联网，设备还是能够使用服务器上存在的数据(当然是同步号的数据)。 尽管你可以有很多办法来实现同步，Android 提供了一个插件式的同步框架，它可以自动完成下面的工作： 检查网络是否可用按照用户偏好，周期性地执行同步重新启动停止的同步操作想要使用这个框架，应该实现一个同步适配器插件。每一个同步适配器都对应一个服务器和一个 provider，但是每一个服务器下可以有多个账户名。这个框架下也允许有一个服务器和 provider 对应多个同步适配器。 数据库改变记录Contacts Provider 对数据库中数据的状态改变都有记录。 数据库操作 Entity查询 联系人的结构是由层次组织的，因此想要查找一个联系人的信息，就要先查找其下面所有RawContacts，还要查出所有RawContacts下关联的所有ContactsContract.CommonDataKinds.Email等，因此为了方便查询，Contacts Provider提供了Entity结构，它可将各个表连接起来。 Entity就像是一张从父表和子表中选出一些列重新组合的一张表。当查询 entity 时，只能根据entity中的列来定制查询结果和查询条件。查询结果的 Cursor 里包含了子表中被查询到的记录。Entity的机构可参考上图，在源码中进行查看。Entity的使用非常方便，通过查询它我们可以一次就得到一个联系人的所有数据。不许要先去查询父表，得到 ID 后，再用这个 ID 去子表中查询。Entity通常不会包含父表和子表中所有的列，如果使用的列并不在 entity 中时，程序就会抛出Exception通过下面查询示例可以帮助理解加载流程： 1234567891011121314151617181920212223242526272829303132//将Entity路径追加到URI。 在联系人提供者中//预期的URI是content：//com.google.contacts/#/entity（＃是ID值）。mContactUri = Uri.withAppendedPath( mContactUri, ContactsContract.Contacts.Entity.CONTENT_DIRECTORY);.....................//初始化由LOADER_CONTACT_ID标识的加载器，并添加加载回调mContactLoader = (ContactLoader) getLoaderManager().initLoader( LOADER_CONTACT_ID, // The identifier of the loader to initialize null, // Arguments for the loader (in this case, none) mLoaderContactCallbacks);.....................//给联系人加载器设置UrimContactLoader.setLookupUri(mContactUri);.....................//联系人加载回调private final LoaderCallbacks&lt;Contact&gt; mLoaderContactCallbacks = new LoaderCallbacks&lt;Contact&gt;() &#123; @Override public void onLoadFinished(Loader&lt;Contact&gt; loader, Contact data) &#123; //此方法中的data就是查询之后返回的结果..................... @Override public Loader&lt;Contact&gt; onCreateLoader(int id, Bundle args) &#123; if (mLookupUri == null) &#123; Log.wtf(TAG, \"Lookup uri wasn't initialized. Loader was started too early\"); &#125; //加载所有联系人数据。 我们需要loadGroupMetaData = true来确定是否 //联系是看不见的。 如果是，我们需要显示一个“添加到联系人”菜单项。 return new ContactLoader(getApplicationContext(), mLookupUri, true /*loadGroupMetaData*/, false /*loadInvitableAccountTypes*/, true /*postViewNotification*/, true /*computeFormattedPhoneNumber*/); 当 load 完成数据加载后，LoaderManager 会调用 onLoadFinished() 方法。到此就可以根据监听器中onLoadFinished()方法返回的data使用了监听器中的onCreateLoader()返回具体的加载器，在这里我们创建了联系人加载器ContactLoader() 批量修改 Contacts Provider 中执行新增、修改、删除操作时，应该尽可能地使用“批处理”，通过创建一个 ContentProviderOperation 对象的 ArrayList 集合然后调用 applyBatch() 方法。因为 Contacts Provider 会把一个 applyBatch() 中的所有操作当成一个事务来处理，你的修改将不会让数据库处于一个不一致的状态中。批处理还方便同时插入 raw contact 和它对应的 data 数据。 Yield points(挂起点)批量处理中有很多的操作，这又可能会阻塞其他进程的运行，这是很差的用户体验。为了改善这种情况，应该尽可能地将所要做的操作分散到多个集合中，同时也为了避免阻塞系统运行，应该为 ContentProviderOperation 设置一个或多个yield points. 通过让 ContentProviderOperation的 isYieldAllowed() 的返回值置为 true. 当Contacts Provider 遇到一个挂起点时，它会停止工作来让其他进程得以运行，并且会关闭当前事务。当Contacts Provider 再次工作时，它将会开启一个新的事务来进行 ArrayList 集合中的下一个操作。 挂起点会导致调用一次 applyBatch() 时开启多个事务。因此，我们应该为某一行记录所有操作的最后一个操作设置一个挂起点。比如说，在我们插入 raw contact 和它相关的 data 数据时，我们应该为最后一步操作设置一个挂起点。 挂起点是原子操作，也就是说两个挂起点之间的所有操作要么成功要么失败。如果没有设置挂起点，原子操作将会是每一步具体的操作。使用挂起点，可以阻止系统性能的下降，还可以确保一些列的操作集合具有原子性。 Modification back references修改反回参考当我们使用 ContentProviderOperation 来插入新的 raw contacts 和与它相关的 data 数据时，必须要将 data 数据的 raw contact’s _ID 这一列关联到 raw contact 的RAW_CONTACT_ID 列上。然而，这个值在创建 ContentProviderOperation 对象时还没有，因为插入 raw contact 的操作还没有完成。为了解决这个问题，ContentProviderOperation.Builder 类提供了withValueBackReference()这个方法，它允许基于上一条操作的结果来插入或者修改数据。 withValueBackReference() 方法有两个参数: key键值对的键。这个值应该是表中的列名。previousResultapplyBatch() 的结果存储在一个索引从0开始的 ContentProviderResult 对象数组中。执行批处理操作时，指向结果存储在一个中间数组中。previousResult 的值就是数组中的一个索引，它以key值来进行存取。这允许我们在插入一个 raw contact 记录时得到插入的 _ID 值，接下来在插入 data 记录时使用。结果数组在调用 applyBatch() 时就被创建完成，它的大小等于 ContentProviderOperation 的 ArrayList 数组的大小。数组初始值都是null，当我们想要获取一个还没有被执行操作的向后引用时，withValueBackReference() 方法将会抛出 异常。下面是Contact新建联系人的示例图： 下面为批量修改示例，代码出自com.android.contacts.ContactSaveService类，其中主要方法为applyBatch()请求批量插入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void createRawContact(Intent intent) &#123; //获取用户输入的所有信息 String accountName = intent.getStringExtra(EXTRA_ACCOUNT_NAME); String accountType = intent.getStringExtra(EXTRA_ACCOUNT_TYPE); String dataSet = intent.getStringExtra(EXTRA_DATA_SET); List&lt;ContentValues&gt; valueList = intent.getParcelableArrayListExtra(EXTRA_CONTENT_VALUES); Intent callbackIntent = intent.getParcelableExtra(EXTRA_CALLBACK_INTENT); //创建一个插入到ContactsContract.RawContacts表中 raw contact 记录的操作 ArrayList&lt;ContentProviderOperation&gt; operations = new ArrayList&lt;ContentProviderOperation&gt;(); operations.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI) .withValue(RawContacts.ACCOUNT_NAME, accountName) .withValue(RawContacts.ACCOUNT_TYPE, accountType) .withValue(RawContacts.DATA_SET, dataSet) .build()); int size = valueList.size(); for (int i = 0; i &lt; size; i++) &#123; ContentValues values = valueList.get(i); values.keySet().retainAll(ALLOWED_DATA_COLUMNS); operations.add(ContentProviderOperation.newInsert(Data.CONTENT_URI) .withValueBackReference(Data.RAW_CONTACT_ID, 0) .withValues(values) .build()); &#125; ContentResolver resolver = getContentResolver(); ContentProviderResult[] results; //调用 applyBatch() 来新增一个 raw contact 和与它相关的 data 记录。 try &#123; results = resolver.applyBatch(ContactsContract.AUTHORITY, operations); &#125; catch (Exception e) &#123; throw new RuntimeException(\"Failed to store new contact\", e); &#125; Uri rawContactUri = results[0].uri; callbackIntent.setData(RawContacts.getContactLookupUri(resolver, rawContactUri)); deliverCallback(callbackIntent); &#125; public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations) throws OperationApplicationException &#123; incrementStats(mBatchStats); if (VERBOSE_LOGGING) &#123; Log.v(TAG, \"applyBatch: \" + operations.size() + \" ops\"); &#125; int ypCount = 0; int opCount = 0; //开启数据操作事务，循环operations处理每一个ops，最大挂起点为500个，如果超过将抛出 //OperationApplicationException异常 ContactsTransaction transaction = startTransaction(true); try &#123; final int numOperations = operations.size(); final ContentProviderResult[] results = new ContentProviderResult[numOperations]; for (int i = 0; i &lt; numOperations; i++) &#123; if (++opCount &gt;= MAX_OPERATIONS_PER_YIELD_POINT) &#123; throw new OperationApplicationException( \"Too many content provider operations between yield points. \" + \"The maximum number of operations per yield point is \" + MAX_OPERATIONS_PER_YIELD_POINT, ypCount); &#125; final ContentProviderOperation operation = operations.get(i); if (i &gt; 0 &amp;&amp; operation.isYieldAllowed()) &#123; if (VERBOSE_LOGGING) &#123; Log.v(TAG, \"applyBatch: \" + opCount + \" ops finished; about to yield...\"); &#125; opCount = 0; try &#123; if (yield(transaction)) &#123; ypCount++; &#125; &#125; catch (RuntimeException re) &#123; transaction.markYieldFailed(); throw re; &#125; &#125; //调用ContentProviderOperation.apply(),开始具体的对数据库的操作，并返回结果 results[i] = operation.apply(this, results, i); &#125; transaction.markSuccessful(true); return results; &#125; finally &#123; endTransaction(true); &#125; &#125; 联系人批量处理过程中使用了事务，和乐观并发控制概念批处理允许我们实现乐观并发控制，它可以让我们在执行修改事务时不去锁定数据库。要是用这个方法，我们先执行事务然后检查是否有其他修改发生。如果检测到不一致的变化，应该回滚事务在重新执行。 乐观并发控制在手机上非常有用，因为只有一个用户，极少发生对一个数据库的同时访问。因为锁没有被使用，所以没有时间浪费在加锁和等待锁的操作上。 为了使用乐观并发控制，我们在更新 ContactsContract.RawContacts 表中的数据时，要遵循以下步骤: ①在获取其他数据时，一并将 VERSION 获取出来②通过 newAssertQuery(Uri) 方法来创建一个 ContentProviderOperation.Builder 对象。将 raw contact’s _ID 附在 RawContacts.CONTENT_URI 后面来形成 URI参数。③调用 ContentProviderOperation.Builder 对象的 withValue() 方法，将得到的 VERSION 的值添加进来。④调用 ContentProviderOperation.Builder 的 withExpectedCount() 方法来保证这个断言只检测一条数据记录。⑤调用 build() 创建 ContentProviderOperation 对象，并将这个对象加入到需要通过 applyBatch() 执行的 ArrayList 数组中去。⑥执行批处理。如果在读取和修改某条记录的过程中，这条记录被其他程序修改了，那么这个断言 ContentProviderOperation 将会失败，事务将会回滚。此时你可以尝试重新执行或者采取其他措施。 使用intents进行检索和修改 要去修改单个 raw contact 记录，最好是通过发送 intent 来让联系人应用去修改，而不是直接用代码进行修改。发送特定的 intent 可以通过设备的联系人应用间接接触 Contacts Provider.这些 intent 会启动联系人应用界面，用户可以在这些界面中完成联系人相关的工作。 数据的完整性（数据协议） 由于联系人数据是非常重要并且敏感的数据，所以用户期望这些数据是正确的，Contacts Provider 为了保证数据的完整性定义了一些规则。当用户修改联系人数据时，你要确保所做的操作都能够满足这些规则。下面是几个比较重要的规则: 要给每一个 ContactsContract.RawContacts 记录都添加 ContactsContract.CommonDataKinds.StructuredName 数据。一个没有 ContactsContract.CommonDataKinds.StructuredName 数据的 ContactsContract.RawContacts 记录在与其他 raw contact 进行组合时可能会遇到问题。每一条 ContactsContract.Data 记录都必须要链接到一条 ContactsContract.RawContacts 记录上去。一个没有链接到 ContactsContract.RawContacts 记录上的 ContactsContract.Data 记录将永远不会显示在联系人应用中，并且可能会影响同步适配器的工作。仅修改属于你自己 raw contact 的数据Contacts Provider 通常管理着几个账户类型的数据。你需要确保你的应用值修改属于你自己的数据，只向自己的账户下新增数据。开发时总是使用 ContactsContract 类中定义的常量来表示authorities、content URIs、URI paths、MIME、以及 TYPE 值。使用这些常量可以帮助你避免一些错误的发生。编译器将会对那些废除的常量给出警告。 自定义数据行 通过定义自己的 MIME 类型，我们可以向 ContactsContract.Data 表中添加自己的数据类型。尽管你可以为你的数据类型定义一些特别的列名（比如phone、Email）,但是还是只能使用定义在 ContactsContract.DataColumns 中的列。在联系人应用中，用户只能显示出你定义的数据类型，但是无法编辑、删除、增加它，所以需要在你自己的应用中实现这样一个界面来完成这些操作。 为了显示自定义的数据类型，需要提供一个 contacts.xml 文件，这个文件中得有一个 元素和它的子元素 .这将在 element 中详细描述。 其他 ContactsContract.StreamItems 表和 ContactsContract.StreamItemPhotos 表管理着来自与社交网络的数据。可以编写同步适配器来将网络上的数据添加到这两张表中，也可以将表中的数据显示在自己的应用中。这个功能可以将社交网络服务和应用集成到Android的社交网络体验中来。","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.hsujee.io/tags/Android/"},{"name":"Contact","slug":"Contact","permalink":"http://blog.hsujee.io/tags/Contact/"},{"name":"Provider","slug":"Provider","permalink":"http://blog.hsujee.io/tags/Provider/"}]},{"title":"Android联系人代码分析","date":"2017-05-11T16:00:00.000Z","path":"2017/05/12/Android/App/2017-05-12-Android联系人代码分析/","text":"项目结构 PeopleActivity为项目启动后的主界面，就从此Activity开始 特殊成员概览： 1234567891011121314151617181920212223242526272829303132333435363738private MultiSelectContactsListFragment mAllFragment; //收藏联系人列表private ContactTileListFragment mFavoritesFragment; //全部联系人列表onCreate()&#123; //申请权限 刷新sim卡 加载联系人列表筛选控制器 添加切换状态监听 初始化界面和fragment，createViewsAndFragments() 初始化全选按钮&#125;onClick()&#123; case R.id.floating_action_button:// 点击悬浮按钮 Intent intent = new Intent(Intent.ACTION_INSERT, Contacts.CONTENT_URI);//新增联系人 case R.id.selection_count_text://点击全选按钮&#125;onAction()&#123; CHANGE_SEARCH_QUERY = 0; //搜索改变后更新模式 START_SEARCH_MODE = 1; //开始搜索模式 START_SELECTION_MODE = 2; //开始选择模式 STOP_SEARCH_AND_SELECTION_MODE = 3; //停止搜索进入选择模式 BEGIN_STOPPING_SEARCH_AND_SELECTION_MODE = 4; //绑定停止搜索和进入选择模式&#125;onOptionsItemSelected()&#123; case android.R.id.home: //点击ActionBar，如果menu显示，则隐藏 case R.id.menu_settings: //设置 case R.id.menu_contacts_filter: //要显示的联系人，联系人筛选器 case R.id.menu_share: //分享 case R.id.menu_join: //关联 case R.id.menu_delete: //删除 case R.id.menu_import_export: //导入/导出 case R.id.menu_clear_frequents: //清理常用联系人 case R.id.menu_help: //帮助 case R.id.menu_accounts: //管理账号 case R.id.menu_search: //搜索 case R.id.menu_blocked_numbers: //已屏蔽的号码 case R.id.export_database: //输出数据 case R.id.menu_groups: //群组 case R.id.menu_conference_call: //电话会议&#125; 新建联系人/修改联系人 12345PeopleActivity-&gt;onClick()-&gt;case R.id.floating_action_button:------&gt; ContactEditorActivity------&gt; ContactEditorFragmentContactEditorBaseFragment编辑联系人界面有两种状态分别如下：Intent.ACTION_EDIT//编辑模式Intent.ACTION_INSERT//新建模式由以上方式进入联系人编辑界面，对联系人的个人信息进行输入操作后，点击optionMenu进行添加 新建联系人 123456789101112131415161718//保存ContactEditorBaseFragment.onOptionsItemSelected()-&gt;case R.id.menu_save://保存按钮点击事件入口ContactEditorBaseFragment. Listener//监听器，处理所有对联系人的操作ContactEditorBaseFragment.save()-&gt;doSaveAction() //保存联系人，调用子类该方法ContactEditorFragment-&gt;doSaveAction();//此方法调用服务对联系人进行保存处理，具体保存实现如下：......protected boolean doSaveAction(int saveMode, Long joinContactId) &#123; final Intent intent = ContactSaveService.createSaveContactIntent(mContext, mState, SAVE_MODE_EXTRA_KEY, saveMode, isEditingUserProfile(), ((Activity) mContext).getClass(), ContactEditorActivity.ACTION_SAVE_COMPLETED, mUpdatedPhotos, JOIN_CONTACT_ID_EXTRA_KEY, joinContactId); return startSaveService(mContext, intent, saveMode);&#125;......startSaveService()&#123; final boolean result = ContactSaveService.startService(context, intent, saveMode);&#125;...... 通过以上流程，对联系人成员protected RawContactDeltaList mState 进行了保存，具体的ContactSaveService中的保存操作后面有整理 修改联系人 保存部分新增联系人中已做解析，下面看看其他操作选项 12345678ContactEditorBaseFragment .onOptionsItemSelected()&#123; case R.id.menu_save: //保存 case R.id.menu_delete: //删除 case R.id.menu_split: //取消关联 case R.id.menu_join: //关联 case R.id.menu_set_ringtone: //设置铃声 case R.id.menu_send_to_voicemail: //发送邮件&#125; 1、删除联系人 123456mListener.onDeleteRequested(mLookupUri);ContactEditorBaseActivity. mFragmentListener-&gt; @Override public void onDeleteRequested(Uri contactUri) &#123; ContactDeletionInteraction.start(ContactEditorBaseActivity.this, contactUri, true);//删除联系人 &#125; 2、取消关联 1234doSplitContactAction() SplitContactConfirmationDialogFragment.show(this, hasPendingChanges());hasPendingChanges()-&gt;hasPendingRawContactChanges() RawContactModifier.hasChanges(mState, accountTypes, excludedMimeTypes);//取消联系人关联 3、关联： 1234567891011showJoinAggregateActivity() //弹出关联选择窗口 startActivityForResult(intent, REQUEST_CODE_JOIN);......onActivityResulte() case REQUEST_CODE_JOIN: //如果返回数据，并且确定关联继续往下走......joinAggregate()-&gt;ContactEditorFragment.joinAggregete(); //选择确定关联，对关联的联系人信息进行保存 final Intent intent = ContactSaveService.createJoinContactsIntent( mContext, mContactIdForJoin, contactId, ContactEditorActivity.class, ContactEditorActivity.ACTION_JOIN_COMPLETED); mContext.startService(intent); 4、设置铃声： 12345678doPickRingtone() //设置联系人铃声 startActivityForResult(intent, REQUEST_CODE_PICK_RINGTONE);//开启铃声选择界面onActivityResult() case REQUEST_CODE_PICK_RINGTONE: onRingtonePicked(pickedUri);onRingtonePicked() //根据参数URI传递的铃声地址，设置该联系人的铃声 Intent intent = ContactSaveService.createSetRingtone(mContext, mLookupUri, mCustomRingtone); mContext.startService(intent); 5、发送邮件： 12345mSendToVoicemailState = !mSendToVoicemailState;item.setChecked(mSendToVoicemailState);final Intent intent = ContactSaveService.createSetSendToVoicemail(mContext, mLookupUri, mSendToVoicemailState);mContext.startService(intent); 查找联系人 查找流程分析 123456789101112PeopleActivity-&gt;onOptionsItemSelected-&gt; case R.id.menu_search:------&gt; onSearchRequested(); mActionBarAdapter.setSearchMode(true); //设置标题栏为搜索模式ActionBarAdapter. SearchTextWatcher-&gt;onTextChanged() mListener.onAction(Action.CHANGE_SEARCH_QUERY);PeopleAction-&gt;onAction(); case ActionBarAdapter.Listener.Action.CHANGE_SEARCH_QUERY:PeopleAction-&gt;setQueryTextToFragment(queryString); 到此处由MultiSelectContactsListFragment的父类实现，如下所示：ContactEntryListFragment-&gt; setQueryString() mAdapter.setQueryString(queryString);ContactEntryListAdapter-&gt; setQueryString() mUpperCaseQueryString = SearchUtil.cleanStartAndEndOfSearchQuery(queryString.toUpperCase()) ; 具体的查询代码在SearchUtil中，查询流程就此告一段落，具体查询算法后面补充 注：在搜索栏输入debug debug! ，界面进入到debug模式，显示按钮，导出数据库文件 1PeopleActivity-&gt;updateDebugOptionsVisibility() 联系人详情页QuickContactActivity 123456789onOptionsItemSelected()&#123; case R.id.menu_star: //加入收藏 final Intent intent = ContactSaveService.createSetStarredIntent(); case R.id.menu_edit: //编辑按钮进入修改联系人界面 case R.id.menu_delete: //删除联系人 case R.id.menu_share: //分享联系人 case R.id.menu_create_contact_shortcut: //创建联系人快捷方式 case R.id.menu_help: //帮助&#125; 删除联系人 删除联系人按钮，将联系人URI出入并打开ContactDeletionInteraction.java,显示提示窗口，点击删除按钮将进行联系人删除操作，具体操作如下： 12ContactDeletionInteraction-&gt;doDeleteContact() ContactSaveService.createDeleteContactIntent(mContext, contactUri) 分享联系人 点击分享联系人按钮，进行如下操作： 12final Intent intent = new Intent(Intent.ACTION_SEND);ImplicitIntentsUtil.startActivityOutsideApp(this, chooseIntent); 通过Intent.ACTION_SEND启动系统提供的分享功能进行分享操作 导入/导出联系人 通过点击事件开启导入/到处界面： ContactImportExportActivity.java 12345678//选择导入/导出源//选择导入/导出目标//打开联系人选择列表界面ContactListMultiChoiceActivity.java， configureListFragment() case ContactsRequestAction.ACTION_PICK_MULTIPLE_CONTACTS //多重选择联系人 | ContactsIntentResolverEx.MODE_MASK_IMPORT_EXPORT_PICKER: // 导入/导出选择器 在这里初始化选择器：MultiDuplicationPickerFragment 在选择器界面，对需要操作的联系人进行选中，点击ExportVCardActivity确定按钮进行导入导出操作 1234567onOptionAction() //处理动作if (mDstStoreType == DST_STORE_TYPE_STORAGE) &#123;//如果存储目标类型是SDCard doExportVCardToSDCard();doExportVCardToSDCard()//中开启ExportVCardActivity界面ExportVCardActivity.java，在该类中使用VCardService进行导入/导出的具体操作&#125; else &#123; mRequestHandler.sendMessage(mRequestHandler.obtainMessage( SendRequestHandler.MSG_REQUEST, mRequests)); 发送msg到handler 1234567handleMessage() //方法中进行导入/导出请求 //调用CopyRequestConnection-&gt;sendCopyRequest方法进行操作请求 mCopyRequestConnection.sendCopyRequest((List&lt;MultiChoiceRequest&gt;) msg.obj)MultiChoiceService.class //批量选择服务 handleCopyRequest() tryExecute(new CopyProcessor(this, listener, requests, sCurrentJobId, sourceAccount, destinationAccount)) 通过CopyProcessor对文件进行最后的拷贝 要显示的联系人 12case R.id.menu_blocked_numbers: //屏蔽号码 createManageBlockedNumbersIntent//打开系统提供的屏蔽号码界面 关联/取消关联联系人 关联联系人 12345case R.id.menu_join: joinSelectedContacts();打开JoinContactsDialogFragment，选择确定关联联系人，执行以下代码final Intent intent = ContactSaveService.createJoinSeveralContactsIntent(getActivity(), contactIdsArray2); 群组 点击群组按钮，开启GroupBrowserActivity 1startActivity(new Intent(PeopleActivity.this, GroupBrowseActivity.class)); 界面中加载GroupBrowseListFragment 新建群组 123456789101112131415161718192021GroupBrowserActivity-&gt;onOptionItemSelected() case R.id.menu_add_group://开启群组编辑界面进行群组创建GroupEditorActivity-GroupEditorFragment//在此编辑界面对群组的信息进行输入，点击去定按钮saveMenuItem-&gt;onClicked() mFragment.onDoneClicked();GroupEditorFragment-&gt;onDoneClicked() if (isGroupMembershipEditable()) &#123; save(SaveMode.CLOSE); //调用保存群组方法，进行保存 &#125; else &#123;doRevertAction();//仅仅返回操作&#125;GroupEditorFragment-&gt;save() if (Intent.ACTION_INSERT.equals(mAction)) //如果是插入模式，进行群组新建操作 saveIntent = ContactSaveService.createNewGroupIntent(activity, new AccountWithDataSet(mAccountName, mAccountType, mDataSet), mGroupNameView.getText().toString(), membersToAddArray, activity.getClass(), GroupEditorActivity.ACTION_SAVE_COMPLETED); Intent.ACTION_EDIT.equals(mAction) //如果是编辑模式，进行更新操作 saveIntent = ContactSaveService.createGroupUpdateIntent(activity, mGroupId, getUpdatedName(), membersToAddArray, membersToRemoveArray, activity.getClass(), GroupEditorActivity.ACTION_SAVE_COMPLETED); 群组详情 123456789101112131415161718192021222324252627GroupBrowseListFragment-&gt;configOnItemClickListener() //Item项目点击事件 viewGroup(); mListener.onViewGroupAction(groupUri); GroupBrowseActivity-&gt;GroupBrowserActionListener onViewGroupAction(); //此方法中执行打开群组详情界面 Intent intent = new Intent(GroupBrowseActivity.this, GroupDetailActivity.class); startActivity(intent);GroupDetailActivity -&gt;onContactSelected() //点击群组中的联系人，打开联系人详情GroupDetailFragment-&gt; onOptionsItemSelected()&#123;case R.id.menu_edit_group: // 修改 GroupDetailActivity -&gt;onEditRequested() //点击修改按钮，进入联系人编辑界面GroupEditorActivitycase R.id.menu_delete_group: //删除 GroupDeletionDialogFragment-&gt;PositiveButtonClick //点击删除按钮后，打开删除窗口，点击确认按钮进行删除 getActivity().startService(SimGroupUtils.createGroupDeletionIntentForIcc()); serviceIntent.setAction(ContactSaveService.ACTION_DELETE_GROUP); //通过上面代码开启SimProcessorService，在sim进程中，调用ContactSaveService.ACTION_DELETE_GROUP ContactSaveService.deleteGroup //进行删除群组操作case R.id.menu_move_group: //移动群组case R.id.menu_message_group: //发送群组信息 SendGroupSmsTask-&gt; execute //异步发送群组短信执行任务 Intent intent = new Intent(Intent.ACTION_SENDTO); startActivity(intent);case R.id.menu_email_group: //发送群组邮件 SendGroupEmailTask-&gt;execute //异步发送群组邮件执行任务 Intent intent = new Intent(Intent.ACTION_SENDTO, dataUri); startActivity(intent);&#125; 管理账号 1234567891011121314151617181920212223Intent intent = new Intent(Settings.ACTION_SYNC_SETTINGS); //调用系统账号管理界面设置startActivity(new Intent(this, ContactsPreferenceActivity.class));ContactsPreferenceActivity -&gt; DisplayOptionsPreferenceFragmentContactSaveService解析负责保存对内容提供者的更改的服务createRawContact() //创建联系人saveContact() //保存联系人createGroup() //创建群组renameGroup() //重命名群组deleteGroup() //删除群组updateGroup() //更新群组setStarred() //设置收藏setSuperPrimary() //设置主要联系人clearPrimary() //清除主要联系人deleteMultipleContacts() //删除多个联系人deleteContact() //删除联系人joinContacts() //关联联系人joinSeveralContacts() //取消联系人关联setSendToVoicemail() //设置发送语音邮箱setRingtone() //设置铃声这些方法是联系人项目中用的的对联系人的增删改查操作，方法里面通过ContentResolver来实现数据库的操作，示例如下：getContentResolver().XXX(); 联系人数据库之ContactsProvider packages/providers/ContactsProvider是Android设备上的联系人数据存储，组织，管理组件 ContactsProvider模块中主要有： 1、ContactsProvider处理联系人数据，操作raw_contacts, contacts, accounts, agg_exception, data, group, mimetypes, name_lookup, phone_lookup, settings, v1_settings数据表 2、CallLogProvider主要处理通话记录，操作calls表 3、SocialProvider主要处理社交整合的数据，操作activitys和status_updates表 ContactsProvider的API路径\\frameworks\\base\\core\\java\\android\\provider\\ 数据库创建 作为数据存储组件，最重要的就是数据，那么ContactsProvider的数据库的表结构是什么？ 在ContactsProvider中数据库的创建和表的创建在com.android.providers.contacts. ContactsDatabaseHelper类中实现 下面具体分析ContactsDatabaseHelper类： ContactsDatabaseHelper继承SQLiteOpenHelper类 类中使用单例设计模式，创建对象，在构造方法中创建数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Contacts DB version ranges: * &lt;pre&gt; * 0-98 Cupcake/Donut * 100-199 Eclair * 200-299 Eclair-MR1 * 300-349 Froyo * 350-399 Gingerbread * 400-499 Honeycomb * 500-549 Honeycomb-MR1 * 550-599 Honeycomb-MR2 * 600-699 Ice Cream Sandwich * 700-799 Jelly Bean * 800-899 Kitkat * 900-999 Lollipop * 1000-1099 M * 1100-1199 N * &lt;/pre&gt; */static final int DATABASE_VERSION = 1111; //当前数据库版本1111private static final String DATABASE_NAME = \"contacts2.db\"; //数据库名称/** *主要的三个表，contacts, raw_contacts, data存储所有的联系人信息 *其他表是辅助表，Contact provider利用它们来管理其操作， *或为设备的联系人或电话应用中的特定功能提供支持。 */public interface Tables &#123; ........ //表示不同联系人的行，基于聚合的原始联系人行 public static final String CONTACTS = \"contacts\"; //包含联系人数据摘要的行，针对特定用户帐户和类型 public static final String RAW_CONTACTS = \"raw_contacts\"; public static final String STREAM_ITEMS = \"stream_items\"; public static final String STREAM_ITEM_PHOTOS = \"stream_item_photos\"; public static final String PHOTO_FILES = \"photo_files\"; public static final String PACKAGES = \"packages\"; public static final String MIMETYPES = \"mimetypes\"; public static final String PHONE_LOOKUP = \"phone_lookup\"; public static final String NAME_LOOKUP = \"name_lookup\"; public static final String AGGREGATION_EXCEPTIONS = \"agg_exceptions\"; public static final String SETTINGS = \"settings\"; //包含原始联系人详细信息（例如电子邮件地址或电话号码）的行 public static final String DATA = \"data\"; public static final String GROUPS = \"groups\"; public static final String PRESENCE = \"presence\"; public static final String AGGREGATED_PRESENCE = \"agg_presence\"; public static final String NICKNAME_LOOKUP = \"nickname_lookup\"; public static final String CALLS = \"calls\"; public static final String STATUS_UPDATES = \"status_updates\"; public static final String PROPERTIES = \"properties\"; public static final String ACCOUNTS = \"accounts\"; public static final String VISIBLE_CONTACTS = \"visible_contacts\"; public static final String DIRECTORIES = \"directories\"; public static final String DEFAULT_DIRECTORY = \"default_directory\"; public static final String SEARCH_INDEX = \"search_index\"; public static final String VOICEMAIL_STATUS = \"voicemail_status\"; ........&#125; onCreate方法中进行所有的表的创建，下面是代码 1234567891011public void onCreate(SQLiteDatabase db) &#123; //创建_sync_state和_sync_state_metadata表，主要用于同步时，状态的记录 mSyncState.createDatabase(db); //首先创建属性表，以便尽快确定创建时间。 PropertyUtils.createPropertiesTable(db); ............ db.execSQL()..........//此类语句都是执行相关表和视图的创建 ............ //创建视图和settings表 LegacyApiSupport.createDatabase(db);&#125; 数据库操作 数据库操作，主要分为两个模块ContactsProvider2和LegacyApiSupport进行处理 用户通过传递参数URL，先匹配ContactsProvider2中定义的URL，如果匹配成功则进行数据操作并返回 如果匹配不成功，则进入LegacyApiSupport中进行匹配，进行数据操作数据库涉及到读操作的行为，主要是数据查询，程序直接通过URL匹配查询，返回数据集 数据库涉及到写操作的行为，主要包括增加、删除、修改，针对多个数据表的操作ContactsProvider采用事务机制，多个数据表的数据的操作全部完成后，统一进行提交。单表操作，则不会使用 事务机制具体定义如下： 1234mDb.beginTransactionWithListener(this)insertInTransaction() / updatnTransaction() / deleteInTransaction()mDb.setTransactionSuccessful()mDb.endTransaction() beginTransactionWithListener中调用onBegin()方法，实现事务处理前期准备工作 endTransaction 中调用onCommit()方法，根据事务的执行状态，进行数据提交 ContactsProvider模块通过在SQLiteContentProvider文件的applyBatch()方法中进行标志变量的设置，来判断是否为多操作 单表操作都是通过URL匹配，完成数据库造作 多表操作主要是通过构建ContentProviderOperation数组，设计多个表的数据变化，最为常见的为联系人的增删改，联系人数据会涉及到下面的表 1raw_contacts，contacts，data，name_lookup，phone_lookup，mimetypes 下面主要分析联系人的增删改操作： 增加联系人 用户在联系人新增界面，填入需要的联系人信息数据，比如名字，电话号码，电子邮件等信息，用户点击保存会调用ContactSaveService.java中的createRawContact()方法来进行联系人插入操作 1234567891011121314private void createRawContact(Intent intent) &#123; .......... //先构造带有RawContacts.CONTENT_URI的数据，然后根据用户输入的数据的mimetype类型， //构造带有Data.CONTENT_URI的数据。 ArrayList&lt;ContentProviderOperation&gt; operations = new ArrayList&lt;ContentProviderOperation&gt;(); operations.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI) .withValue(RawContacts.ACCOUNT_NAME, accountName) .withValue(RawContacts.ACCOUNT_TYPE, accountType) .withValue(RawContacts.DATA_SET, dataSet) .build()); ........... //最后会调用applyBatch()函数进行数据写入。 results = resolver.applyBatch(ContactsContract.AUTHORITY, operations);&#125; 关于AbstractContactsProvider. applyBatch()： 调用applyBatch()函数过程中，会读取ContentProviderOperation数组，而数组的每一条记录都会带有一个URI，通过匹配URI，找到对应的表进行插入操作。操作成功后得到返回结果，并对关联数据mValuesBackReferences中的字段值进行更新。 获取mimetype，并根据mimetype类型数据，获得不同的DataRowHandler，进行data数据的写入。（data数据操作具体见Data表数据增加、修改、删除） 查询联系人 由于数据查询涉及多个表间关系，大量数据的查询都是通过视图来完成的，创建了如下视图，而这几个视图是大家在调用api进行查询时显示的数据： 123456789101112public interface Views &#123; public static final String DATA = \"view_data\"; public static final String RAW_CONTACTS = \"view_raw_contacts\"; public static final String CONTACTS = \"view_contacts\"; public static final String ENTITIES = \"view_entities\"; public static final String RAW_ENTITIES = \"view_raw_entities\"; public static final String GROUPS = \"view_groups\"; public static final String DATA_USAGE_STAT = \"view_data_usage_stat\"; public static final String STREAM_ITEMS = \"view_stream_items\"; public static final String METADATA_SYNC = \"view_metadata_sync\"; public static final String METADATA_SYNC_STATE = \"view_metadata_sync_state\";&#125; Data表数据增加、修改、删除 AbstractContactsProvider联系人数据库操作基类，他的两个子类分别是ContactsProvider2和ProfileProvider 其中ProfileProvider是ContactsProvider2的委托类AbstractContactsProvider类中定义了以下三个抽象方法，分别负责对联系人数据的增加，删除，修改 该类使用了模板模式的设计模式,模板方法如下 该类在对数据库进行事务操作的同时，对子类开放了onRollback，onCommit等事物回调方法 子类可以根据自己的业务特点进行扩展 123protected abstract Uri insertInTransaction(Uri uri, ContentValues values);protected abstract int deleteInTransaction(Uri uri, String selection, String[] selectionArgs);protected abstract int updateInTransaction(Uri uri, ContentValues values, String selection, String[] selectionArgs); ContactsTransaction.java是对事务的管理类，主要对进行的事务进行管理，类似一个事务池 是AbstractContactsProvider.java中事务处理的核心类 DataRowHandler.java是数据处理抽象类，实现了对数据的增删改操作，下面都是它的实现类 123456789101112DataRowHandlerForCommonDataKind.java DataRowHandlerForCustomMimetype.java DataRowHandlerForEmail.java DataRowHandlerForGroupMembership.java DataRowHandlerForIm.java DataRowHandlerForNickname.java DataRowHandlerForNote.java DataRowHandlerForOrganization.java DataRowHandlerForPhoneNumber.java DataRowHandlerForPhoto.java DataRowHandlerForStructuredName.java DataRowHandlerForStructuredPostal.java 在ContactsProvider2.initDataRowHandlers() 方法中对所有的DataRowHandler进行了初始化操作 其调用在ContactsProvider2.getDataRowHandler()方法之通过 mimetype匹配调用 所有数据的mimetype都被存储在表Tables.MIMETYPES中，该只有两个字段_id和mimetype","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.hsujee.io/tags/Android/"},{"name":"Contact","slug":"Contact","permalink":"http://blog.hsujee.io/tags/Contact/"},{"name":"App","slug":"App","permalink":"http://blog.hsujee.io/tags/App/"}]},{"title":"Hexo博客yilia模板配置","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/Hoxe/2017-05-10-Hexo博客yilia模板配置/","text":"配置环境 安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须） 作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装Hexo Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 执行如下命令安装Hexo： 1sudo npm install -g hexo 初始化然后，执行init命令初始化hexo,命令： 1hexo init 好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面 1hexo generate（hexo g也可以） 本地启动 启动本地服务，进行文章预览调试，命令： 1hexo server 浏览器输入http://localhost:4000 我不知道你们能不能，反正我不能，因为我还有环境没配置好 配置Github 建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有： 123_config.yml node_modules public sourcedb.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，命令： 1vim _config.yml 翻到最下面，改成我这样子的 1234567deploy: type: git repo: https://github.com/leopardpan/leopardpan.github.io.git branch: master 然后执行命令： 1npm install hexo-deployer-git --save 网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令： 1hexo deploy 然后再浏览器中输入http://leopardpan.github.io/就行了，我的github的账户叫leopardpan,把这个改成你github的账户名就行了 部署步骤 每次部署的步骤，可按以下三步来进行。 12345hexo cleanhexo generatehexo deploy 一些常用命令： 12345678910111213hexo new\"postName\" #新建文章hexo new page\"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 E:\\Blog_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 徐彦杰的博客subtitle: 如果真有奇迹,那只是努力的另一个名字description: Yanjie.Xu Worldauthor: 墨迹流韶email: xuyjcode@gmail.comlanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://blog.cocoper.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/hchjerry/hchjerry.github.io.git branch: mastersitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmfeed: type: atom path: atom.xml limit: 100jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: true tags: true E:\\Blog\\themes\\yilia_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# Headermenu: 主页: / 博客: /archives 相册: /photos #随笔: /tags# SubNavsubnav: github: \"https://github.com/hchjerry\" weibo: \"http://weibo.com/hchjerry\" #rss: \"#\" #zhihu: \"#\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #segmentfault: \"#\" #bilibili: \"#\" #acfun: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: ''google_analytics: ''favicon: /favicon.png#你的头像urlavatar: /img/head.jpg#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#4A708B' # 右滑板块背景 slider: 'linear-gradient(200deg,#d1e3eb,#4A708B)'# slider的设置slider: # 是否默认展开tags板块 showTags: false # 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '博客' friends: '友链' aboutme: '关于我' #tagcloud: '标签云'friends: 百度: http://www.baidu.com #tagcloud: true aboutme: &lt;div id=\"nav\"&gt; 邮箱：xuyanjie@cocoper.com &lt;br&gt;&lt;br&gt; QQ：825194169 &lt;br&gt;&lt;br&gt; &lt;a href=\"http://blog.csdn.net/github_19529589\" target=\"_blank\"&gt;CSDN博客&lt;/a&gt; &lt;/div&gt; E:\\Blog\\themes\\yilia\\layout_partial\\left-col.ejs 12345&lt;!-- 开启网易云播放器 --&gt;&lt;nav class=\"header-music\"&gt; &lt;!--&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=400 src=\"//music.163.com/outchain/player?type=0&amp;id=509985151&amp;auto=0&amp;height=380\"&gt;&lt;/iframe&gt;--&gt; &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=110 src=\"//music.163.com/outchain/player?type=0&amp;id=509985151&amp;auto=0&amp;height=90\"&gt;&lt;/iframe&gt;&lt;/nav&gt; E:\\Blog\\themes\\yilia\\source\\main.05aabf.css 12345.header-music &#123; position:fixed; bottom:0;&#125;","tags":[{"name":"工具","slug":"工具","permalink":"http://blog.hsujee.io/tags/工具/"},{"name":"应用","slug":"应用","permalink":"http://blog.hsujee.io/tags/应用/"}]},{"title":"Android快捷键启动解析","date":"2017-03-24T16:00:00.000Z","path":"2017/03/25/Android/Framework/2017-03-25-Android快捷键启动解析/","text":"Android快捷方式作为Android设备的杀手锏技能，一直都是非常重要的一个功能，也正是如此，各种流氓App也不断通过快捷方式霸占着这样一个用户入口,下面咱们就来说道说道，关于Android快捷方式的那些事。 同时，各大国产ROM和Luncher的崛起，让这个桌面之争变的更加激烈。毕竟大家都只想用户用自己的App资源，所以，现在各大App不仅仅是要抢占入口，同时还要和各大ROM斗智斗勇。本文将对这个快捷方式进行深度解密，同时给出App适配各种ROM的整合方案。 系统提供的方式 首先大家要知道各种Launcher的区别，原生的Launcher，是两层结构，桌面是快捷方式，而进去后的App列表是App的Launch Icon；而以小米为首的一帮ROM，参考iOS风格，将Launcher改为了一层，即直接显示Launch Icon。 权限设置 123456&lt;!-- 添加快捷方式 --&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\" /&gt;&lt;!-- 移除快捷方式 --&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\" /&gt;&lt;!-- 查询快捷方式 --&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.READ_SETTINGS\" /&gt; 通过Action创建快捷方式 参数相信大家都能看得懂，只是有一点需要注意的，duplicate这个属性，是设置该快捷方式是否允许多次创建的属性，但是，在很多ROM上都不能成功识别，嗯，这就是我们最开始说的快捷方式乱现象。 1234567891011121314151617181920212223// Action 添加Shortcutpublic static final String ACTION_ADD_SHORTCUT = com.android.launcher.action.INSTALL_SHORTCUT;/** * 添加快捷方式 * * @param context context * @param actionIntent 要启动的Intent * @param name name */public static void addShortcut(Context context, Intent actionIntent, String name, boolean allowRepeat, Bitmap iconBitmap) &#123; Intent addShortcutIntent = new Intent(ACTION_ADD_SHORTCUT); // 是否允许重复创建 addShortcutIntent.putExtra(duplicate, allowRepeat); // 快捷方式的标题 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); // 快捷方式的图标 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, iconBitmap); // 快捷方式的动作 addShortcutIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, actionIntent); context.sendBroadcast(addShortcutIntent);&#125; 通过Action删除快捷方式 123456789101112131415161718// Action 移除Shortcutpublic static final String ACTION_REMOVE_SHORTCUT = com.android.launcher.action.UNINSTALL_SHORTCUT;/** * 移除快捷方式 * * @param context context * @param actionIntent 要启动的Intent * @param name name */public static void removeShortcut(Context context, Intent actionIntent, String name) &#123; Intent intent = new Intent(ACTION_REMOVE_SHORTCUT); intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, name); //intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.putExtra(duplicate, false); intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, actionIntent); context.sendBroadcast(intent);&#125; 从原理来理解如何来适配各种Launcher 原生的快捷方式添加方法，虽然是官方提供的，但在天国这样一个怎么说呢的国家里，基本是很难使用、适配的，也就是我们最开始说的那些原因。下面我们先从快捷方式的整个生命周期来了解下产生、添加、删除快捷方式的原理，再来思考如何实现多ROM、Launcher的适配。 1、快捷方式的存储 快捷方式其实都存储在Launcher的数据库中，我们在手机上打开SQLite Editor打开Launcher的数据库。 我们打开Launcher.db的”/kf/ware/vc/“ target=”_blank” 123class=&quot;keylink&quot;&gt;vcml0ZbHto6zV4sDvvs3Kx87Sw8exo7TmtcS/7L3dt73Kvcr9vt2jujwvcD4NCjxwPjxpbWcgYWx0PQ==&quot;2.png&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1176696-074d7b877de7c6bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; title=&quot;\\&quot; /&gt; 几个主要的字段大家基本一看就懂：title、intent、iconResource、icon，分别对应快捷方式名称，快捷方式intent，快捷方式图标来源，快捷方式图标二进制数据。 2、快捷方式的创建 了解了快捷方式的存储原理，我们就可以针对这个数据库来做文章，所有的快捷方式都可以通过修改这个数据库来实现，同时还不用太考虑兼容性问题。 对于快捷方式的创建，我们依然可以使用系统提供的方法，所以这里不再多说。 3、快捷方式的判断是否存在 前面我们说了，通过duplicate属性可以区分是否允许创建重复的快捷方式，但是，很多ROM是无法兼容到的，所以，这里我们使用查询Launcher数据库的方式来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 检查快捷方式是否存在 * &lt;font color=\"red\"&gt;注意：&lt;/font&gt; 有些手机无法判断是否已经创建过快捷方式 * 因此，在创建快捷方式时，请添加 * shortcutIntent.putExtra(duplicate, false);// 不允许重复创建 * 最好使用&#123;@link #isShortCutExist(Context, String, Intent)&#125; * 进行判断，因为可能有些应用生成的快捷方式名称是一样的的 */public static boolean isShortCutExist(Context context, String title) &#123; boolean result = false; try &#123; ContentResolver cr = context.getContentResolver(); Uri uri = getUriFromLauncher(context); Cursor c = cr.query(uri, new String[]&#123;title&#125;, title=? , new String[]&#123;title&#125;, null); if (c != null &amp;&amp; c.getCount() &gt; 0) &#123; result = true; &#125; if (c != null &amp;&amp; !c.isClosed()) &#123; c.close(); &#125; &#125; catch (Exception e) &#123; result = false; e.printStackTrace(); &#125; return result;&#125;/** * 不一定所有的手机都有效，因为国内大部分手机的桌面不是系统原生的 * 更多请参考&#123;@link #isShortCutExist(Context, String)&#125; * 桌面有两种，系统桌面(ROM自带)与第三方桌面，一般只考虑系统自带 * 第三方桌面如果没有实现系统响应的方法是无法判断的，比如GO桌面 */public static boolean isShortCutExist(Context context, String title, Intent intent) &#123; boolean result = false; try &#123; ContentResolver cr = context.getContentResolver(); Uri uri = getUriFromLauncher(context); Cursor c = cr.query(uri, new String[]&#123;title, intent&#125;, title=? and intent=?, new String[]&#123;title, intent.toUri(0)&#125;, null); if (c != null &amp;&amp; c.getCount() &gt; 0) &#123; result = true; &#125; if (c != null &amp;&amp; !c.isClosed()) &#123; c.close(); &#125; &#125; catch (Exception ex) &#123; result = false; ex.printStackTrace(); &#125; return result;&#125;private static Uri getUriFromLauncher(Context context) &#123; StringBuilder uriStr = new StringBuilder(); String authority = LauncherUtil.getAuthorityFromPermissionDefault(context); if (authority == null || authority.trim().equals()) &#123; authority = LauncherUtil.getAuthorityFromPermission(context, LauncherUtil.getCurrentLauncherPackageName(context) + .permission.READ_SETTINGS); &#125; uriStr.append(content://); if (TextUtils.isEmpty(authority)) &#123; int sdkInt = android.os.Build.VERSION.SDK_INT; if (sdkInt &lt; 8) &#123; // Android 2.1.x(API 7)以及以下的 uriStr.append(com.android.launcher.settings); &#125; else if (sdkInt &lt; 19) &#123;// Android 4.4以下 uriStr.append(com.android.launcher2.settings); &#125; else &#123;// 4.4以及以上 uriStr.append(com.android.launcher3.settings); &#125; &#125; else &#123; uriStr.append(authority); &#125; uriStr.append(/favorites?notify=true); return Uri.parse(uriStr.toString());&#125; 这里有两个重载的isShortCutExist方法，唯一的区别就是最后一个参数——intent，加这个参数的原因，在注释中已经写了，更加精确。而getUriFromLauncher方法，是给调用的ContentResolver提供Uri。构造的时候，可以看见，Android的版本话碎片问题，是多么的严重…… 这样在添加快捷方式前，通过这个判断下，就可以只添加一个快捷方式了。 4、为任意PackageName的App添加快捷方式 知道了我们是如何判断快捷方式是是否存在的，我们就可以通过这种思路来为任意PackageName的App添加快捷方式，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 为PackageName的App添加快捷方式 * * @param context context * @param pkg 待添加快捷方式的应用包名 * @return 返回true为正常执行完毕 */public static boolean addShortcutByPackageName(Context context, String pkg) &#123; // 快捷方式名 String title = unknown; // MainActivity完整名 String mainAct = null; // 应用图标标识 int iconIdentifier = 0; // 根据包名寻找MainActivity PackageManager pkgMag = context.getPackageManager(); Intent queryIntent = new Intent(Intent.ACTION_MAIN, null); queryIntent.addCategory(Intent.CATEGORY_LAUNCHER);// 重要，添加后可以进入直接已经打开的页面 queryIntent.setFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); queryIntent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY); List&lt;resolveinfo&gt; list = pkgMag.queryIntentActivities(queryIntent, PackageManager.GET_ACTIVITIES); for (int i = 0; i &lt; list.size(); i++) &#123; ResolveInfo info = list.get(i); if (info.activityInfo.packageName.equals(pkg)) &#123; title = info.loadLabel(pkgMag).toString(); mainAct = info.activityInfo.name; iconIdentifier = info.activityInfo.applicationInfo.icon; break; &#125; &#125; if (mainAct == null) &#123; // 没有启动类 return false; &#125; Intent shortcut = new Intent( com.android.launcher.action.INSTALL_SHORTCUT); // 快捷方式的名称 shortcut.putExtra(Intent.EXTRA_SHORTCUT_NAME, title); // 不允许重复创建 shortcut.putExtra(duplicate, false); ComponentName comp = new ComponentName(pkg, mainAct); shortcut.putExtra(Intent.EXTRA_SHORTCUT_INTENT, queryIntent.setComponent(comp)); // 快捷方式的图标 Context pkgContext = null; if (context.getPackageName().equals(pkg)) &#123; pkgContext = context; &#125; else &#123; // 创建第三方应用的上下文环境，为的是能够根据该应用的图标标识符寻找到图标文件。 try &#123; pkgContext = context.createPackageContext(pkg, Context.CONTEXT_IGNORE_SECURITY | Context.CONTEXT_INCLUDE_CODE); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; if (pkgContext != null) &#123; Intent.ShortcutIconResource iconRes = Intent.ShortcutIconResource .fromContext(pkgContext, iconIdentifier); shortcut.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconRes); &#125; // 发送广播，让接收者创建快捷方式 // 需权限&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\"&gt; context.sendBroadcast(shortcut); return true;&#125; 使用一些Trick来解决多Launcher适配的问题 由于快捷方式的碎片化非常严重，所以，你顾得上这种ROM，顾不上其它ROM。例如，在原生ROM上，你需要使用类似原生的Launcher权限： 12&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\" /&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\" /&gt; 但是，在其它ROM上呢，例如华为，你需要这样的权限： 12&lt;uses-permission android:name=\"com.huawei.launcher3.permission.READ_SETTINGS\" /&gt;&lt;uses-permission android:name=\"com.huawei.launcher3.permission.WRITE_SETTINGS\" /&gt; 为了程序能够通用性够强，理论上我们得为所有不使用原生Launcher权限的Launcher配置权限代码，是的，你妹听错，是所有，只有通过这种奇技淫巧，才能适配更多的Launcher，这里贴一部分给大家爽一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE/\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE/\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_SETTINGS/\" /&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.INSTALL_SHORTCUT\"&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.UNINSTALL_SHORTCUT\"&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher2.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher2.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher3.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.launcher3.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.htc.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.htc.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.qihoo360.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.qihoo360.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.lge.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.lge.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"net.qihoo.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"net.qihoo.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adwfreak.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adwfreak.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher_donut.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"org.adw.launcher_donut.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher3.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher3.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.fede.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.fede.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.sec.android.app.twlauncher.settings.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.sec.android.app.twlauncher.settings.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.anddoes.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.anddoes.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.tencent.qqlauncher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.tencent.qqlauncher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher2.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.launcher2.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.mylauncher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.android.mylauncher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.ebproductions.android.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.ebproductions.android.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.oppo.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.oppo.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.miui.mihome2.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.miui.mihome2.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.android.launcher.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"com.huawei.android.launcher.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"telecom.mdesk.permission.READ_SETTINGS\"&gt;&lt;uses-permission android:name=\"telecom.mdesk.permission.WRITE_SETTINGS\"&gt;&lt;uses-permission android:name=\"dianxin.permission.ACCESS_LAUNCHER_DATA\"&gt; 这时候大家肯定要问了，你申请这么多权限，用户在安装App的时候，不是要崩溃了，尼玛，这么多看都看不过来啊，其实，根本不需要担心，因为这些基本都是各自ROM中的第三方ROM权限，在用户安装的时候，他们通常会被解析成原生Launcher的权限，例如：添加、修改桌面快捷方式。并不会将所有的权限都写出来。 使用其他方式来实现类似快捷方式的方法 快捷方式的确是我们为应用导流的一个非常重要的入口，但是，由于碎片化实在太严重，所以，我们可以使用在Launcher App列表中为应用增加一个入口的方式来为App导流，简单的说，就是增进一个App的入口Activity。 123&lt;intent-filter&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt; 非常简单，相信大家都知道这种方式来给App增加一个Activity入口。但是，这种方式，我们如何能够自由的控制这个入口是否显示呢？ 1、奇技PackageManager PackageManager提供了一系列Package的管理方法，当然，也包含了我们非常关心的启用、停用组件这一方法，这个方法在Root情况下，可以修改任一App的任意组件，在普通情况下，对自身App有绝对权限。使用方法也非常简单： 12345678910111213141516171819public static void toggleFlowEntrance(Context context, Class launcherClass) &#123; PackageManager packageManager = context.getPackageManager(); ComponentName componentName = new ComponentName(context, launcherClass); int res = packageManager.getComponentEnabledSetting(componentName); if (res == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || res == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) &#123; // 隐藏应用图标 packageManager.setComponentEnabledSetting( componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP); &#125; else &#123; // 显示应用图标 packageManager.setComponentEnabledSetting( componentName, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT, PackageManager.DONT_KILL_APP); &#125;&#125; 总结 前面我们分析了各种快捷方式、Launcher入口的方式来对App进行导流，当然，这不是我们的目的，我们的目的是能够掌握Android快捷方式的哭花宝典而不用那个啥。 下面是GitHub的开源项目 项目地址： https://github.com/xuyisheng/ShortcutHelper","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.hsujee.io/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","permalink":"http://blog.hsujee.io/tags/FrameWork/"}]}]